From b52e9aa1c4c8308c3d89ab9d201997ad86143400 Mon Sep 17 00:00:00 2001
From: Panu Matilainen <pmatilai@redhat.com>
Date: Wed, 9 Feb 2022 14:47:14 +0200
Subject: [PATCH 01/32] Add optional callback on directory changes during rpmfi
 iteration

Internal only for now in case we need to fiddle with the API some more,
but no reason this couldn't be made public later.
---
 lib/rpmfi.c          | 24 +++++++++++++++++++++++-
 lib/rpmfi_internal.h | 17 +++++++++++++++++
 2 files changed, 40 insertions(+), 1 deletion(-)

diff --git a/lib/rpmfi.c b/lib/rpmfi.c
index 4673fbb850..e8e7d08bf1 100644
--- a/lib/rpmfi.c
+++ b/lib/rpmfi.c
@@ -55,6 +55,9 @@ struct rpmfi_s {
     int intervalStart;		/*!< Start of iterating interval. */
     int intervalEnd;		/*!< End of iterating interval. */
 
+    rpmfiChdirCb onChdir;	/*!< Callback for directory changes */
+    void *onChdirData;		/*!< Caller private callback data */
+
     rpmfiles files;		/*!< File info set */
     rpmcpio_t archive;		/*!< Archive with payload */
     unsigned char * found;	/*!< Bit field of files found in the archive */
@@ -303,6 +306,17 @@ rpm_count_t rpmfiDC(rpmfi fi)
     return (fi != NULL ? rpmfilesDC(fi->files) : 0);
 }
 
+int rpmfiSetOnChdir(rpmfi fi, rpmfiChdirCb cb, void *data)
+{
+    int rc = -1;
+    if (fi != NULL) {
+	fi->onChdir = cb;
+	fi->onChdirData = data;
+	rc = 0;
+    }
+    return rc;
+}
+
 int rpmfiFX(rpmfi fi)
 {
     return (fi != NULL ? fi->i : -1);
@@ -313,9 +327,17 @@ int rpmfiSetFX(rpmfi fi, int fx)
     int i = -1;
 
     if (fi != NULL && fx >= 0 && fx < rpmfilesFC(fi->files)) {
+	int dx = fi->j;
+	i = fi->i;
 	fi->i = fx;
 	fi->j = rpmfilesDI(fi->files, fi->i);
 	i = fi->i;
+
+	if (fi->j != dx && fi->onChdir) {
+	    int chrc = fi->onChdir(fi, fi->onChdirData);
+	    if (chrc < 0)
+		i = chrc;
+	}
     }
     return i;
 }
@@ -1780,9 +1802,9 @@ static rpmfi initIter(rpmfiles files, int itype, int link)
     if (files && itype>=0 && itype<=RPMFILEITERMAX) {
 	fi = xcalloc(1, sizeof(*fi)); 
 	fi->i = -1;
+	fi->j = -1;
 	fi->files = link ? rpmfilesLink(files) : files;
 	fi->next = nextfuncs[itype];
-	fi->i = -1;
 	if (itype == RPMFI_ITER_BACK) {
 	    fi->i = rpmfilesFC(fi->files);
 	} else if (itype >=RPMFI_ITER_READ_ARCHIVE
diff --git a/lib/rpmfi_internal.h b/lib/rpmfi_internal.h
index dccc6ccbe8..37f1d45f5c 100644
--- a/lib/rpmfi_internal.h
+++ b/lib/rpmfi_internal.h
@@ -13,6 +13,23 @@
 extern "C" {
 #endif
 
+/** \ingroup rpmfi
+ * Callback on file iterator directory changes
+ * @param fi		file info
+ * @param data		caller private callback data
+ * @return		0 on success, < 0 on error (to stop iteration)
+ */
+typedef int (*rpmfiChdirCb)(rpmfi fi, void *data);
+
+/** \ingroup rpmfi
+ * Set a callback for directory changes during iteration.
+ * @param fi		file info
+ * @param cb		callback function
+ * @param data		caller private callback data
+ * @return		string pool handle (weak reference)
+ */
+int rpmfiSetOnChdir(rpmfi fi, rpmfiChdirCb cb, void *data);
+
 /** \ingroup rpmfi
  * Return file info set string pool handle
  * @param fi		file info

From 97905cc911801d0e8d00c5011074bdc548eaa4c2 Mon Sep 17 00:00:00 2001
From: Panu Matilainen <pmatilai@redhat.com>
Date: Thu, 10 Feb 2022 14:32:43 +0200
Subject: [PATCH 02/32] Validate intermediate symlinks during installation,
 CVE-2021-35939

Whenever directory changes during unpacking, walk the entire tree from
starting from / and validate any symlinks crossed, fail the install
on invalid links.

This is the first of step of many towards securing our file operations
against local tamperers and besides plugging that one CVE, paves the way
for the next step by adding the necessary directory fd tracking.
This also bumps the rpm OS requirements to a whole new level by requiring
the *at() family of calls from POSIX-1.2008.

This necessarily does a whole lot of huffing and puffing we previously
did not do. It should be possible to cache secure (ie root-owned)
directory structures to avoid validating everything a million times
but for now, just keeping things simple.
---
 INSTALL      |   2 +
 configure.ac |   3 +-
 lib/fsm.c    | 144 ++++++++++++++++++++++++++++++++++++++++++++++++---
 3 files changed, 142 insertions(+), 7 deletions(-)

diff --git a/INSTALL b/INSTALL
index 677ef88c42..961a160e0d 100644
--- a/INSTALL
+++ b/INSTALL
@@ -103,6 +103,8 @@ option to configure).  For GCC, OpenMP 4.5 is fully supported since GCC 6.1,
 which is available from
     http://www.gnu.org/
 
+Rpm requires a POSIX.1-2008 level operating system.
+
 To compile RPM:
 --------------
 
diff --git a/configure.ac b/configure.ac
index 3ee3407268..0099e5f34e 100644
--- a/configure.ac
+++ b/configure.ac
@@ -580,7 +580,8 @@ AC_CHECK_FUNCS([secure_getenv __secure_getenv])
 
 AC_CHECK_FUNCS(
    [mkstemp getcwd basename dirname realpath setenv unsetenv regcomp lchown \
-    utimes getline localtime_r statvfs getaddrinfo ],
+    utimes getline localtime_r statvfs getaddrinfo \
+    openat mkdirat fstatat ],
    [], [AC_MSG_ERROR([function required by rpm])])
 
 AC_LIBOBJ(fnmatch)
diff --git a/lib/fsm.c b/lib/fsm.c
index 9118983479..b6b152ab10 100644
--- a/lib/fsm.c
+++ b/lib/fsm.c
@@ -8,6 +8,7 @@
 #include <inttypes.h>
 #include <utime.h>
 #include <errno.h>
+#include <fcntl.h>
 #if WITH_CAP
 #include <sys/capability.h>
 #endif
@@ -20,6 +21,7 @@
 #include "rpmio/rpmio_internal.h"	/* fdInit/FiniDigest */
 #include "lib/fsm.h"
 #include "lib/rpmte_internal.h"	/* XXX rpmfs */
+#include "lib/rpmfi_internal.h" /* rpmfiSetOnChdir */
 #include "lib/rpmplugins.h"	/* rpm plugins hooks */
 #include "lib/rpmug.h"
 
@@ -406,17 +408,118 @@ static int fsmRmdir(const char *path)
     return rc;
 }
 
-static int fsmMkdir(const char *path, mode_t mode)
+static int fsmMkdir(int dirfd, const char *path, mode_t mode)
 {
-    int rc = mkdir(path, (mode & 07777));
+    int rc = mkdirat(dirfd, path, (mode & 07777));
     if (_fsm_debug)
-	rpmlog(RPMLOG_DEBUG, " %8s (%s, 0%04o) %s\n", __func__,
-	       path, (unsigned)(mode & 07777),
+	rpmlog(RPMLOG_DEBUG, " %8s (%d %s, 0%04o) %s\n", __func__,
+	       dirfd, path, (unsigned)(mode & 07777),
 	       (rc < 0 ? strerror(errno) : ""));
     if (rc < 0)	rc = RPMERR_MKDIR_FAILED;
     return rc;
 }
 
+static int fsmOpenat(int dirfd, const char *path, int flags)
+{
+    struct stat lsb, sb;
+    int sflags = flags | O_NOFOLLOW;
+    int fd = openat(dirfd, path, sflags);
+
+    /*
+     * Only ever follow symlinks by root or target owner. Since we can't
+     * open the symlink itself, the order matters: we stat the link *after*
+     * opening the target, and if the link ownership changed between the calls
+     * it could've only been the link owner or root.
+     */
+    if (fd < 0 && errno == ELOOP && flags != sflags) {
+	int ffd = openat(dirfd, path, flags);
+	if (ffd >= 0 && fstatat(dirfd, path, &lsb, AT_SYMLINK_NOFOLLOW) == 0) {
+	    if (fstat(ffd, &sb) == 0) {
+		if (lsb.st_uid == 0 || lsb.st_uid == sb.st_uid) {
+		    fd = ffd;
+		} else {
+		    close(ffd);
+		}
+	    }
+	}
+    }
+    return fd;
+}
+
+static int fsmDoMkDir(rpmPlugins plugins, int dirfd, const char *dn,
+			int owned, mode_t mode)
+{
+    int rc;
+    rpmFsmOp op = (FA_CREATE);
+    if (!owned)
+	op |= FAF_UNOWNED;
+
+    /* Run fsm file pre hook for all plugins */
+    rc = rpmpluginsCallFsmFilePre(plugins, NULL, dn, mode, op);
+
+    if (!rc)
+	rc = fsmMkdir(dirfd, dn, mode);
+
+    if (!rc) {
+	rc = rpmpluginsCallFsmFilePrepare(plugins, NULL, dn, dn, mode, op);
+    }
+
+    /* Run fsm file post hook for all plugins */
+    rpmpluginsCallFsmFilePost(plugins, NULL, dn, mode, op, rc);
+
+    if (!rc) {
+	rpmlog(RPMLOG_DEBUG,
+		"%s directory created with perms %04o\n",
+		dn, (unsigned)(mode & 07777));
+    }
+
+    return rc;
+}
+
+static int ensureDir(rpmPlugins plugins, const char *p, int owned, int create)
+{
+    char *path = xstrdup(p);
+    char *dp = path;
+    char *sp = NULL, *bn;
+    int oflags = O_RDONLY;
+
+    int dirfd = fsmOpenat(-1, "/", oflags);
+    int fd = dirfd; /* special case of "/" */
+
+    while ((bn = strtok_r(dp, "/", &sp)) != NULL) {
+	struct stat sb;
+	fd = fsmOpenat(dirfd, bn, oflags);
+
+	if (fd < 0 && errno == ENOENT && create) {
+	    mode_t mode = S_IFDIR | (_dirPerms & 07777);
+	    if (fsmDoMkDir(plugins, dirfd, bn, owned, mode) == 0) {
+		fd = fsmOpenat(dirfd, bn, oflags|O_NOFOLLOW);
+	    }
+	}
+
+	if (fd >= 0 && fstat(fd, &sb) == 0 && !S_ISDIR(sb.st_mode)) {
+	    close(fd);
+	    errno = ENOTDIR;
+	    fd = -1;
+	}
+
+	close(dirfd);
+	if (fd >= 0) {
+	    dirfd = fd;
+	} else {
+	    dirfd = -1;
+	    rpmlog(RPMLOG_ERR, _("failed to open dir %s of %s: %s\n"),
+				bn, p, strerror(errno));
+	    break;
+	}
+
+	dp = NULL;
+    }
+
+    free(path);
+    return dirfd;
+}
+
 static int fsmMkfifo(const char *path, mode_t mode)
 {
     int rc = mkfifo(path, (mode & 07777));
@@ -507,7 +610,7 @@ static int fsmMkdirs(rpmfiles files, rpmfs fs, rpmPlugins plugins)
 		rc = rpmpluginsCallFsmFilePre(plugins, NULL, dn, mode, op);
 
 		if (!rc)
-		    rc = fsmMkdir(dn, mode);
+		    rc = fsmMkdir(-1, dn, mode);
 
 		if (!rc) {
 		    rc = rpmpluginsCallFsmFilePrepare(plugins, NULL, dn, dn,
@@ -874,6 +977,21 @@ static void setFileState(rpmfs fs, int i)
     }
 }
 
+struct diriter_s {
+    int dirfd;
+};
+
+static int onChdir(rpmfi fi, void *data)
+{
+    struct diriter_s *di = data;
+
+    if (di->dirfd >= 0) {
+	close(di->dirfd);
+	di->dirfd = -1;
+    }
+    return 0;
+}
+
 int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
               rpmpsm psm, char ** failedFile)
 {
@@ -890,6 +1008,7 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
     char *tid = NULL;
     struct filedata_s *fdata = xcalloc(fc, sizeof(*fdata));
     struct filedata_s *firstlink = NULL;
+    struct diriter_s di = { -1 };
 
     /* transaction id used for temporary path suffix while installing */
     rasprintf(&tid, ";%08x", (unsigned)rpmtsGetTid(ts));
@@ -932,6 +1051,7 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
         rc = RPMERR_BAD_MAGIC;
         goto exit;
     }
+    rpmfiSetOnChdir(fi, onChdir, &di);
 
     /* Detect and create directories not explicitly in package. */
     if (!rc)
@@ -946,6 +1066,16 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
 	    if (!fp->suffix) {
 		rc = fsmBackup(fi, fp->action);
 	    }
+
+	    if (di.dirfd == -1) {
+		di.dirfd = ensureDir(plugins, rpmfiDN(fi), 0,
+				    (fp->action == FA_CREATE));
+		if (di.dirfd == -1) {
+		    rc = RPMERR_OPEN_FAILED;
+		    break;
+		}
+	    }
+
 	    /* Assume file does't exist when tmp suffix is in use */
 	    if (!fp->suffix) {
 		if (fp->action == FA_TOUCH) {
@@ -980,7 +1110,7 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
                     mode_t mode = fp->sb.st_mode;
                     mode &= ~07777;
                     mode |=  00700;
-                    rc = fsmMkdir(fp->fpath, mode);
+                    rc = fsmMkdir(di.dirfd, fp->fpath, mode);
                 }
             } else if (S_ISLNK(fp->sb.st_mode)) {
 		if (rc == RPMERR_ENOENT) {
@@ -1022,6 +1152,8 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
 	fp->stage = FILE_UNPACK;
     }
     fi = rpmfiFree(fi);
+    close(di.dirfd);
+    di.dirfd = -1;
 
     if (!rc && fx < 0 && fx != RPMERR_ITER_END)
 	rc = fx;

From 5e9c915feb85fce02eab30140d28de389ec22351 Mon Sep 17 00:00:00 2001
From: Panu Matilainen <pmatilai@redhat.com>
Date: Thu, 10 Feb 2022 15:03:22 +0200
Subject: [PATCH 03/32] Drop unsafe and now redundant unowned directories
 creation code

Any unowned directories will be created inline during processing now
so we can just flush this big pile of code that was insecure anyhow.

As an additional bonus creating the directories inline gives us an
opportunity to track the creation so we can undo too, but that is
not done here.
---
 lib/fsm.c | 229 ------------------------------------------------------
 1 file changed, 229 deletions(-)

diff --git a/lib/fsm.c b/lib/fsm.c
index b6b152ab10..ec6ee2c36d 100644
--- a/lib/fsm.c
+++ b/lib/fsm.c
@@ -77,143 +77,6 @@ static char * fsmFsPath(rpmfi fi, const char * suffix)
     return rstrscat(NULL, rpmfiDN(fi), rpmfiBN(fi), suffix ? suffix : "", NULL);
 }
 
-/** \ingroup payload
- * Directory name iterator.
- */
-typedef struct dnli_s {
-    rpmfiles fi;
-    char * active;
-    int reverse;
-    int isave;
-    int i;
-} * DNLI_t;
-
-/** \ingroup payload
- * Destroy directory name iterator.
- * @param dnli		directory name iterator
- * @param[out]		NULL always
- */
-static DNLI_t dnlFreeIterator(DNLI_t dnli)
-{
-    if (dnli) {
-	if (dnli->active) free(dnli->active);
-	free(dnli);
-    }
-    return NULL;
-}
-
-/** \ingroup payload
- * Create directory name iterator.
- * @param fi		file info set
- * @param fs		file state set
- * @param reverse	traverse directory names in reverse order?
- * @return		directory name iterator
- */
-static DNLI_t dnlInitIterator(rpmfiles fi, rpmfs fs, int reverse)
-{
-    DNLI_t dnli;
-    int i, j;
-    int dc;
-
-    if (fi == NULL)
-	return NULL;
-    dc = rpmfilesDC(fi);
-    dnli = xcalloc(1, sizeof(*dnli));
-    dnli->fi = fi;
-    dnli->reverse = reverse;
-    dnli->i = (reverse ? dc : 0);
-
-    if (dc) {
-	dnli->active = xcalloc(dc, sizeof(*dnli->active));
-	int fc = rpmfilesFC(fi);
-
-	/* Identify parent directories not skipped. */
-	for (i = 0; i < fc; i++)
-            if (!XFA_SKIPPING(rpmfsGetAction(fs, i)))
-		dnli->active[rpmfilesDI(fi, i)] = 1;
-
-	/* Exclude parent directories that are explicitly included. */
-	for (i = 0; i < fc; i++) {
-	    int dil;
-	    size_t dnlen, bnlen;
-
-	    if (!S_ISDIR(rpmfilesFMode(fi, i)))
-		continue;
-
-	    dil = rpmfilesDI(fi, i);
-	    dnlen = strlen(rpmfilesDN(fi, dil));
-	    bnlen = strlen(rpmfilesBN(fi, i));
-
-	    for (j = 0; j < dc; j++) {
-		const char * dnl;
-		size_t jlen;
-
-		if (!dnli->active[j] || j == dil)
-		    continue;
-		dnl = rpmfilesDN(fi, j);
-		jlen = strlen(dnl);
-		if (jlen != (dnlen+bnlen+1))
-		    continue;
-		if (!rstreqn(dnl, rpmfilesDN(fi, dil), dnlen))
-		    continue;
-		if (!rstreqn(dnl+dnlen, rpmfilesBN(fi, i), bnlen))
-		    continue;
-		if (dnl[dnlen+bnlen] != '/' || dnl[dnlen+bnlen+1] != '\0')
-		    continue;
-		/* This directory is included in the package. */
-		dnli->active[j] = 0;
-		break;
-	    }
-	}
-
-	/* Print only once per package. */
-	if (!reverse) {
-	    j = 0;
-	    for (i = 0; i < dc; i++) {
-		if (!dnli->active[i]) continue;
-		if (j == 0) {
-		    j = 1;
-		    rpmlog(RPMLOG_DEBUG,
-	"========== Directories not explicitly included in package:\n");
-		}
-		rpmlog(RPMLOG_DEBUG, "%10d %s\n", i, rpmfilesDN(fi, i));
-	    }
-	    if (j)
-		rpmlog(RPMLOG_DEBUG, "==========\n");
-	}
-    }
-    return dnli;
-}
-
-/** \ingroup payload
- * Return next directory name (from file info).
- * @param dnli		directory name iterator
- * @return		next directory name
- */
-static
-const char * dnlNextIterator(DNLI_t dnli)
-{
-    const char * dn = NULL;
-
-    if (dnli) {
-	rpmfiles fi = dnli->fi;
-	int dc = rpmfilesDC(fi);
-	int i = -1;
-
-	if (dnli->active)
-	do {
-	    i = (!dnli->reverse ? dnli->i++ : --dnli->i);
-	} while (i >= 0 && i < dc && !dnli->active[i]);
-
-	if (i >= 0 && i < dc)
-	    dn = rpmfilesDN(fi, i);
-	else
-	    i = -1;
-	dnli->isave = i;
-    }
-    return dn;
-}
-
 static int fsmLink(const char *opath, const char *path)
 {
     int rc = link(opath, path);
@@ -553,94 +416,6 @@ static int fsmMknod(const char *path, mode_t mode, dev_t dev)
     return rc;
 }
 
-/**
- * Create (if necessary) directories not explicitly included in package.
- * @param files		file data
- * @param fs		file states
- * @param plugins	rpm plugins handle
- * @return		0 on success
- */
-static int fsmMkdirs(rpmfiles files, rpmfs fs, rpmPlugins plugins)
-{
-    DNLI_t dnli = dnlInitIterator(files, fs, 0);
-    struct stat sb;
-    const char *dpath;
-    int rc = 0;
-    int i;
-    size_t ldnlen = 0;
-    const char * ldn = NULL;
-
-    while ((dpath = dnlNextIterator(dnli)) != NULL) {
-	size_t dnlen = strlen(dpath);
-	char * te, dn[dnlen+1];
-
-	if (dnlen <= 1)
-	    continue;
-
-	if (dnlen == ldnlen && rstreq(dpath, ldn))
-	    continue;
-
-	/* Copy as we need to modify the string */
-	(void) stpcpy(dn, dpath);
-
-	/* Assume '/' directory exists, "mkdir -p" for others if non-existent */
-	for (i = 1, te = dn + 1; *te != '\0'; te++, i++) {
-	    if (*te != '/')
-		continue;
-
-	    /* Already validated? */
-	    if (i < ldnlen &&
-		(ldn[i] == '/' || ldn[i] == '\0') && rstreqn(dn, ldn, i))
-		continue;
-
-	    /* Validate next component of path. */
-	    *te = '\0';
-	    rc = fsmStat(dn, 1, &sb); /* lstat */
-	    *te = '/';
-
-	    /* Directory already exists? */
-	    if (rc == 0 && S_ISDIR(sb.st_mode)) {
-		continue;
-	    } else if (rc == RPMERR_ENOENT) {
-		*te = '\0';
-		mode_t mode = S_IFDIR | (_dirPerms & 07777);
-		rpmFsmOp op = (FA_CREATE|FAF_UNOWNED);
-
-		/* Run fsm file pre hook for all plugins */
-		rc = rpmpluginsCallFsmFilePre(plugins, NULL, dn, mode, op);
-
-		if (!rc)
-		    rc = fsmMkdir(-1, dn, mode);
-
-		if (!rc) {
-		    rc = rpmpluginsCallFsmFilePrepare(plugins, NULL, dn, dn,
-						      mode, op);
-		}
-
-		/* Run fsm file post hook for all plugins */
-		rpmpluginsCallFsmFilePost(plugins, NULL, dn, mode, op, rc);
-
-		if (!rc) {
-		    rpmlog(RPMLOG_DEBUG,
-			    "%s directory created with perms %04o\n",
-			    dn, (unsigned)(mode & 07777));
-		}
-		*te = '/';
-	    }
-	    if (rc)
-		break;
-	}
-	if (rc) break;
-
-	/* Save last validated path. */
-	ldn = dpath;
-	ldnlen = dnlen;
-    }
-    dnlFreeIterator(dnli);
-
-    return rc;
-}
-
 static void removeSBITS(const char *path)
 {
     struct stat stb;
@@ -1053,10 +828,6 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
     }
     rpmfiSetOnChdir(fi, onChdir, &di);
 
-    /* Detect and create directories not explicitly in package. */
-    if (!rc)
-	rc = fsmMkdirs(files, fs, plugins);
-
     /* Process the payload */
     while (!rc && (fx = rpmfiNext(fi)) >= 0) {
 	struct filedata_s *fp = &fdata[fx];

From 7e0134299874081172c49d0732b34ff7d722516f Mon Sep 17 00:00:00 2001
From: Panu Matilainen <pmatilai@redhat.com>
Date: Fri, 11 Feb 2022 13:05:45 +0200
Subject: [PATCH 04/32] Consolidate skipped hardlink with content case with the
 others

Handling this in a separate clause makes the logic much clearer and
(in theory at least) lets us handle hardlinks to any content, not
just regular files.
---
 lib/fsm.c | 20 ++++++++++----------
 1 file changed, 10 insertions(+), 10 deletions(-)

diff --git a/lib/fsm.c b/lib/fsm.c
index ec6ee2c36d..82610c77dd 100644
--- a/lib/fsm.c
+++ b/lib/fsm.c
@@ -832,9 +832,18 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
     while (!rc && (fx = rpmfiNext(fi)) >= 0) {
 	struct filedata_s *fp = &fdata[fx];
 
+	/*
+	 * Tricksy case: this file is a being skipped, but it's part of
+	 * a hardlinked set and has the actual content linked with it.
+	 * Write the content to the first non-skipped file of the set
+	 * instead.
+	 */
+	if (fp->skip && firstlink && rpmfiArchiveHasContent(fi))
+	    fp = firstlink;
+
         if (!fp->skip) {
 	    /* Directories replacing something need early backup */
-	    if (!fp->suffix) {
+	    if (!fp->suffix && fp != firstlink) {
 		rc = fsmBackup(fi, fp->action);
 	    }
 
@@ -904,15 +913,6 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
                 if (!IS_DEV_LOG(fp->fpath))
                     rc = RPMERR_UNKNOWN_FILETYPE;
             }
-	} else if (firstlink && rpmfiArchiveHasContent(fi)) {
-	    /*
-	     * Tricksy case: this file is a being skipped, but it's part of
-	     * a hardlinked set and has the actual content linked with it.
-	     * Write the content to the first non-skipped file of the set
-	     * instead.
-	     */
-	    rc = fsmMkfile(fi, firstlink, files, psm, nodigest,
-			   &firstlink, &firstlinkfile);
 	}
 
 	/* Notify on success. */

From 558ca2f597515f989f598f24eac9d611600a699f Mon Sep 17 00:00:00 2001
From: Panu Matilainen <pmatilai@redhat.com>
Date: Fri, 11 Feb 2022 13:18:11 +0200
Subject: [PATCH 05/32] Fix + sanitize the hardlink metadata setting logic

Fix the initial setmeta value to something meaningful: we will never
set metadata on skipped files, and hardlinks are handled with a special
logic during install. They'd need different kind of special logic on
FA_TOUCH so just play it safe and always apply metadata on those.

Harlink metadata setting on install should happen on the *last* entry
of hardlinked set that gets installed (wrt various skip scenarios)
as otherwise creating those additional links affects the timestamp.
Note in particular the "last file of..." case in fsmMkfile() where we
the comment said just that, but set the metadata on the *first* file
which would then be NULL'ed away.

This all gets current masked by the fact that we do the metadata setting on
a separate round, but that is about to change plus this makes the overall
logic clearer anyhow.
---
 lib/fsm.c | 8 +++++---
 1 file changed, 5 insertions(+), 3 deletions(-)

diff --git a/lib/fsm.c b/lib/fsm.c
index 82610c77dd..d9cfe6fa99 100644
--- a/lib/fsm.c
+++ b/lib/fsm.c
@@ -193,7 +193,6 @@ static int fsmMkfile(rpmfi fi, struct filedata_s *fp, rpmfiles files,
 	/* Create hard links for others and avoid redundant metadata setting */
 	if (*firstlink != fp) {
 	    rc = fsmLink((*firstlink)->fpath, fp->fpath);
-	    fp->setmeta = 0;
 	}
 	fd = *firstlinkfile;
     }
@@ -204,7 +203,7 @@ static int fsmMkfile(rpmfi fi, struct filedata_s *fp, rpmfiles files,
 	    rc = fsmUnpack(fi, fd, psm, nodigest);
 	/* Last file of hardlink set, ensure metadata gets set */
 	if (*firstlink) {
-	    (*firstlink)->setmeta = 1;
+	    fp->setmeta = 1;
 	    *firstlink = NULL;
 	    *firstlinkfile = NULL;
 	}
@@ -797,7 +796,6 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
 	else
 	    fp->action = rpmfsGetAction(fs, fx);
 	fp->skip = XFA_SKIPPING(fp->action);
-	fp->setmeta = 1;
 	if (XFA_CREATING(fp->action) && !S_ISDIR(rpmfiFMode(fi)))
 	    fp->suffix = tid;
 	fp->fpath = fsmFsPath(fi, fp->suffix);
@@ -805,6 +803,10 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
 	/* Remap file perms, owner, and group. */
 	rc = rpmfiStat(fi, 1, &fp->sb);
 
+	/* Hardlinks are tricky and handled elsewhere for install */
+	fp->setmeta = (fp->skip == 0) &&
+		      (fp->sb.st_nlink == 1 || fp->action == FA_TOUCH);
+
 	setFileState(fs, fx);
 	fsmDebug(fp->fpath, fp->action, &fp->sb);
 

From efe19bc1c3126311aeb6d6f0f623ea7a5f8f1e51 Mon Sep 17 00:00:00 2001
From: Panu Matilainen <pmatilai@redhat.com>
Date: Fri, 11 Feb 2022 13:28:25 +0200
Subject: [PATCH 06/32] Move file metadata setting back to unpack stage

Commit a82251b44ee2d2802ee8aea1b3d89f88beee4bad moved metadata setting
to a separate step because there are potential benefits to doing so, but
the current downsides are worse: as long as we operate in potentially
untrusted directories, we'd need to somehow verify the content is what we
initially laid down to avoid possible privilege escalation from non-root
owned directories.

This commit does not fix that vulnerability, only makes the window much
smaller and paves the way for the real fix(es) without introducing a
second round of directory tree validation chase to the picture.
---
 lib/fsm.c | 22 +++++++---------------
 1 file changed, 7 insertions(+), 15 deletions(-)

diff --git a/lib/fsm.c b/lib/fsm.c
index d9cfe6fa99..ae1bd3f486 100644
--- a/lib/fsm.c
+++ b/lib/fsm.c
@@ -880,7 +880,7 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
 
 	    /* When touching we don't need any of this... */
 	    if (fp->action == FA_TOUCH)
-		continue;
+		goto setmeta;
 
             if (S_ISREG(fp->sb.st_mode)) {
 		if (rc == RPMERR_ENOENT) {
@@ -915,6 +915,12 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
                 if (!IS_DEV_LOG(fp->fpath))
                     rc = RPMERR_UNKNOWN_FILETYPE;
             }
+
+setmeta:
+	    if (!rc && fp->setmeta) {
+		rc = fsmSetmeta(fp->fpath, fi, plugins, fp->action,
+				&fp->sb, nofcaps);
+	    }
 	}
 
 	/* Notify on success. */
@@ -931,20 +937,6 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
     if (!rc && fx < 0 && fx != RPMERR_ITER_END)
 	rc = fx;
 
-    /* Set permissions, timestamps etc for non-hardlink entries */
-    fi = rpmfilesIter(files, RPMFI_ITER_FWD);
-    while (!rc && (fx = rpmfiNext(fi)) >= 0) {
-	struct filedata_s *fp = &fdata[fx];
-	if (!fp->skip && fp->setmeta) {
-	    rc = fsmSetmeta(fp->fpath, fi, plugins, fp->action,
-			    &fp->sb, nofcaps);
-	}
-	if (rc)
-	    *failedFile = xstrdup(fp->fpath);
-	fp->stage = FILE_PREP;
-    }
-    fi = rpmfiFree(fi);
-
     /* If all went well, commit files to final destination */
     fi = rpmfilesIter(files, RPMFI_ITER_FWD);
     while (!rc && (fx = rpmfiNext(fi)) >= 0) {

From 9937aae89eec8f7492fff2558b3f28cd601e6efc Mon Sep 17 00:00:00 2001
From: Panu Matilainen <pmatilai@redhat.com>
Date: Fri, 11 Feb 2022 15:35:16 +0200
Subject: [PATCH 07/32] Convert the file creation steps the *at() family of
 calls

Supposedly no functional changes here, we just need all these things
converted before we can swap over to relative paths.
---
 configure.ac |  2 +-
 lib/fsm.c    | 59 ++++++++++++++++++++++++++--------------------------
 2 files changed, 31 insertions(+), 30 deletions(-)

diff --git a/configure.ac b/configure.ac
index 0099e5f34e..ac9003768a 100644
--- a/configure.ac
+++ b/configure.ac
@@ -581,7 +581,7 @@ AC_CHECK_FUNCS([secure_getenv __secure_getenv])
 AC_CHECK_FUNCS(
    [mkstemp getcwd basename dirname realpath setenv unsetenv regcomp lchown \
     utimes getline localtime_r statvfs getaddrinfo \
-    openat mkdirat fstatat ],
+    openat mkdirat fstatat linkat symlinkat mkfifoat mknodat ],
    [], [AC_MSG_ERROR([function required by rpm])])
 
 AC_LIBOBJ(fnmatch)
diff --git a/lib/fsm.c b/lib/fsm.c
index ae1bd3f486..8443954f2e 100644
--- a/lib/fsm.c
+++ b/lib/fsm.c
@@ -77,13 +77,13 @@ static char * fsmFsPath(rpmfi fi, const char * suffix)
     return rstrscat(NULL, rpmfiDN(fi), rpmfiBN(fi), suffix ? suffix : "", NULL);
 }
 
-static int fsmLink(const char *opath, const char *path)
+static int fsmLink(int odirfd, const char *opath, int dirfd, const char *path)
 {
-    int rc = link(opath, path);
+    int rc = linkat(odirfd, opath, dirfd, path, 0);
 
     if (_fsm_debug) {
-	rpmlog(RPMLOG_DEBUG, " %8s (%s, %s) %s\n", __func__,
-	       opath, path, (rc < 0 ? strerror(errno) : ""));
+	rpmlog(RPMLOG_DEBUG, " %8s (%d %s, %d %s) %s\n", __func__,
+	       odirfd, opath, dirfd, path, (rc < 0 ? strerror(errno) : ""));
     }
 
     if (rc < 0)
@@ -139,17 +139,18 @@ static int fsmClose(FD_t *wfdp)
     return rc;
 }
 
-static int fsmOpen(FD_t *wfdp, const char *dest)
+static int fsmOpen(FD_t *wfdp, int dirfd, const char *dest)
 {
     int rc = 0;
     /* Create the file with 0200 permissions (write by owner). */
-    {
-	mode_t old_umask = umask(0577);
-	*wfdp = Fopen(dest, "wx.ufdio");
-	umask(old_umask);
+    int fd = openat(dirfd, dest, O_WRONLY|O_EXCL|O_CREAT, 0200);
+
+    if (fd >= 0) {
+	*wfdp = fdDup(fd);
+	close(fd);
     }
 
-    if (Ferror(*wfdp))
+    if (fd < 0 || Ferror(*wfdp))
 	rc = RPMERR_OPEN_FAILED;
 
     if (_fsm_debug) {
@@ -174,7 +175,7 @@ static int fsmUnpack(rpmfi fi, FD_t fd, rpmpsm psm, int nodigest)
     return rc;
 }
 
-static int fsmMkfile(rpmfi fi, struct filedata_s *fp, rpmfiles files,
+static int fsmMkfile(int dirfd, rpmfi fi, struct filedata_s *fp, rpmfiles files,
 		     rpmpsm psm, int nodigest,
 		     struct filedata_s ** firstlink, FD_t *firstlinkfile)
 {
@@ -183,7 +184,7 @@ static int fsmMkfile(rpmfi fi, struct filedata_s *fp, rpmfiles files,
 
     if (*firstlink == NULL) {
 	/* First encounter, open file for writing */
-	rc = fsmOpen(&fd, fp->fpath);
+	rc = fsmOpen(&fd, dirfd, fp->fpath);
 	/* If it's a part of a hardlinked set, the content may come later */
 	if (fp->sb.st_nlink > 1) {
 	    *firstlink = fp;
@@ -192,7 +193,7 @@ static int fsmMkfile(rpmfi fi, struct filedata_s *fp, rpmfiles files,
     } else {
 	/* Create hard links for others and avoid redundant metadata setting */
 	if (*firstlink != fp) {
-	    rc = fsmLink((*firstlink)->fpath, fp->fpath);
+	    rc = fsmLink(dirfd, (*firstlink)->fpath, dirfd, fp->fpath);
 	}
 	fd = *firstlinkfile;
     }
@@ -382,13 +383,13 @@ static int ensureDir(rpmPlugins plugins, const char *p, int owned, int create)
     return dirfd;
 }
 
-static int fsmMkfifo(const char *path, mode_t mode)
+static int fsmMkfifo(int dirfd, const char *path, mode_t mode)
 {
-    int rc = mkfifo(path, (mode & 07777));
+    int rc = mkfifoat(dirfd, path, (mode & 07777));
 
     if (_fsm_debug) {
-	rpmlog(RPMLOG_DEBUG, " %8s (%s, 0%04o) %s\n",
-	       __func__, path, (unsigned)(mode & 07777),
+	rpmlog(RPMLOG_DEBUG, " %8s (%d %s, 0%04o) %s\n",
+	       __func__, dirfd, path, (unsigned)(mode & 07777),
 	       (rc < 0 ? strerror(errno) : ""));
     }
 
@@ -398,14 +399,14 @@ static int fsmMkfifo(const char *path, mode_t mode)
     return rc;
 }
 
-static int fsmMknod(const char *path, mode_t mode, dev_t dev)
+static int fsmMknod(int dirfd, const char *path, mode_t mode, dev_t dev)
 {
     /* FIX: check S_IFIFO or dev != 0 */
-    int rc = mknod(path, (mode & ~07777), dev);
+    int rc = mknodat(dirfd, path, (mode & ~07777), dev);
 
     if (_fsm_debug) {
-	rpmlog(RPMLOG_DEBUG, " %8s (%s, 0%o, 0x%x) %s\n",
-	       __func__, path, (unsigned)(mode & ~07777),
+	rpmlog(RPMLOG_DEBUG, " %8s (%d %s, 0%o, 0x%x) %s\n",
+	       __func__, dirfd, path, (unsigned)(mode & ~07777),
 	       (unsigned)dev, (rc < 0 ? strerror(errno) : ""));
     }
 
@@ -440,13 +441,13 @@ static void fsmDebug(const char *fpath, rpmFileAction action,
 	    (fpath ? fpath : ""));
 }
 
-static int fsmSymlink(const char *opath, const char *path)
+static int fsmSymlink(const char *opath, int dirfd, const char *path)
 {
-    int rc = symlink(opath, path);
+    int rc = symlinkat(opath, dirfd, path);
 
     if (_fsm_debug) {
-	rpmlog(RPMLOG_DEBUG, " %8s (%s, %s) %s\n", __func__,
-	       opath, path, (rc < 0 ? strerror(errno) : ""));
+	rpmlog(RPMLOG_DEBUG, " %8s (%s, %d %s) %s\n", __func__,
+	       opath, dirfd, path, (rc < 0 ? strerror(errno) : ""));
     }
 
     if (rc < 0)
@@ -884,7 +885,7 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
 
             if (S_ISREG(fp->sb.st_mode)) {
 		if (rc == RPMERR_ENOENT) {
-		    rc = fsmMkfile(fi, fp, files, psm, nodigest,
+		    rc = fsmMkfile(di.dirfd, fi, fp, files, psm, nodigest,
 				   &firstlink, &firstlinkfile);
 		}
             } else if (S_ISDIR(fp->sb.st_mode)) {
@@ -896,19 +897,19 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
                 }
             } else if (S_ISLNK(fp->sb.st_mode)) {
 		if (rc == RPMERR_ENOENT) {
-		    rc = fsmSymlink(rpmfiFLink(fi), fp->fpath);
+		    rc = fsmSymlink(rpmfiFLink(fi), di.dirfd, fp->fpath);
 		}
             } else if (S_ISFIFO(fp->sb.st_mode)) {
                 /* This mimics cpio S_ISSOCK() behavior but probably isn't right */
                 if (rc == RPMERR_ENOENT) {
-                    rc = fsmMkfifo(fp->fpath, 0000);
+                    rc = fsmMkfifo(di.dirfd, fp->fpath, 0000);
                 }
             } else if (S_ISCHR(fp->sb.st_mode) ||
                        S_ISBLK(fp->sb.st_mode) ||
                        S_ISSOCK(fp->sb.st_mode))
             {
                 if (rc == RPMERR_ENOENT) {
-                    rc = fsmMknod(fp->fpath, fp->sb.st_mode, fp->sb.st_rdev);
+                    rc = fsmMknod(di.dirfd, fp->fpath, fp->sb.st_mode, fp->sb.st_rdev);
                 }
             } else {
                 /* XXX Special case /dev/log, which shouldn't be packaged anyways */

From a2e4bcfee1459a8faedf4109ffa0b769a30b1ba1 Mon Sep 17 00:00:00 2001
From: Panu Matilainen <pmatilai@redhat.com>
Date: Mon, 14 Feb 2022 09:26:49 +0200
Subject: [PATCH 08/32] "Factorize" chdir-aware iterator creation

---
 lib/fsm.c | 20 +++++++++++++++-----
 1 file changed, 15 insertions(+), 5 deletions(-)

diff --git a/lib/fsm.c b/lib/fsm.c
index 8443954f2e..9d6d7e38d8 100644
--- a/lib/fsm.c
+++ b/lib/fsm.c
@@ -767,6 +767,18 @@ static int onChdir(rpmfi fi, void *data)
     return 0;
 }
 
+static rpmfi fsmIter(FD_t payload, rpmfiles files, rpmFileIter iter, void *data)
+{
+    rpmfi fi;
+    if (payload)
+	fi = rpmfiNewArchiveReader(payload, files, RPMFI_ITER_READ_ARCHIVE);
+    else
+	fi = rpmfilesIter(files, iter);
+    if (fi && data)
+	rpmfiSetOnChdir(fi, onChdir, data);
+    return fi;
+}
+
 int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
               rpmpsm psm, char ** failedFile)
 {
@@ -821,15 +833,13 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
     if (rc)
 	goto exit;
 
-    if (rpmteType(te) == TR_ADDED)
-	fi = rpmfiNewArchiveReader(payload, files, RPMFI_ITER_READ_ARCHIVE);
-    else
-	fi = rpmfilesIter(files, RPMFI_ITER_FWD);
+    fi = fsmIter(payload, files,
+		 payload ? RPMFI_ITER_READ_ARCHIVE : RPMFI_ITER_FWD, &di);
+
     if (fi == NULL) {
         rc = RPMERR_BAD_MAGIC;
         goto exit;
     }
-    rpmfiSetOnChdir(fi, onChdir, &di);
 
     /* Process the payload */
     while (!rc && (fx = rpmfiNext(fi)) >= 0) {

From 93542b39ed87530eb2cc6ba2c74433bc52340de4 Mon Sep 17 00:00:00 2001
From: Panu Matilainen <pmatilai@redhat.com>
Date: Mon, 14 Feb 2022 09:53:22 +0200
Subject: [PATCH 09/32] Add new rpm error codes for invalid symlinks and
 not-a-directory

---
 lib/rpmarchive.h | 2 ++
 lib/rpmfi.c      | 2 ++
 2 files changed, 4 insertions(+)

diff --git a/lib/rpmarchive.h b/lib/rpmarchive.h
index ec6366c86e..46724e57e3 100644
--- a/lib/rpmarchive.h
+++ b/lib/rpmarchive.h
@@ -26,6 +26,8 @@ enum rpmfilesErrorCodes {
 	RPMERR_FILE_SIZE	= -12,
 	RPMERR_ITER_SKIP	= -13,
 	RPMERR_EXIST_AS_DIR	= -14,
+	RPMERR_INVALID_SYMLINK	= -15,
+	RPMERR_ENOTDIR		= -16,
 
 	RPMERR_OPEN_FAILED	= -32768,
 	RPMERR_CHMOD_FAILED	= -32769,
diff --git a/lib/rpmfi.c b/lib/rpmfi.c
index e8e7d08bf1..d3f2c27f2b 100644
--- a/lib/rpmfi.c
+++ b/lib/rpmfi.c
@@ -2505,6 +2505,8 @@ char * rpmfileStrerror(int rc)
     case RPMERR_DIGEST_MISMATCH: s = _("Digest mismatch");	break;
     case RPMERR_INTERNAL:	s = _("Internal error");	break;
     case RPMERR_UNMAPPED_FILE:	s = _("Archive file not in header"); break;
+    case RPMERR_INVALID_SYMLINK: s = _("Invalid symlink");	break;
+    case RPMERR_ENOTDIR:	s = strerror(ENOTDIR);	break;
     case RPMERR_ENOENT:	s = strerror(ENOENT); break;
     case RPMERR_ENOTEMPTY:	s = strerror(ENOTEMPTY); break;
     case RPMERR_EXIST_AS_DIR:

From 63ef815f3a5440ede1b838e4da48619bb24f914f Mon Sep 17 00:00:00 2001
From: Panu Matilainen <pmatilai@redhat.com>
Date: Mon, 14 Feb 2022 10:14:04 +0200
Subject: [PATCH 10/32] Refactor ensureDir() to return an error code separately
 from the fd

---
 lib/fsm.c | 42 +++++++++++++++++++++++++++---------------
 1 file changed, 27 insertions(+), 15 deletions(-)

diff --git a/lib/fsm.c b/lib/fsm.c
index 9d6d7e38d8..acedd231a1 100644
--- a/lib/fsm.c
+++ b/lib/fsm.c
@@ -339,12 +339,17 @@ static int fsmDoMkDir(rpmPlugins plugins, int dirfd, const char *dn,
     return rc;
 }
 
-static int ensureDir(rpmPlugins plugins, const char *p, int owned, int create)
+static int ensureDir(rpmPlugins plugins, const char *p, int owned, int create,
+		    int *dirfdp)
 {
     char *path = xstrdup(p);
     char *dp = path;
     char *sp = NULL, *bn;
     int oflags = O_RDONLY;
+    int rc = 0;
+
+    if (*dirfdp >= 0)
+	return rc;
 
     int dirfd = fsmOpenat(-1, "/", oflags);
     int fd = dirfd; /* special case of "/" */
@@ -355,32 +360,40 @@ static int ensureDir(rpmPlugins plugins, const char *p, int owned, int create)
 
 	if (fd < 0 && errno == ENOENT && create) {
 	    mode_t mode = S_IFDIR | (_dirPerms & 07777);
-	    if (fsmDoMkDir(plugins, dirfd, bn, owned, mode) == 0) {
+	    rc = fsmDoMkDir(plugins, dirfd, bn, owned, mode);
+	    if (!rc)
 		fd = fsmOpenat(dirfd, bn, oflags|O_NOFOLLOW);
-	    }
 	}
 
 	if (fd >= 0 && fstat(fd, &sb) == 0 && !S_ISDIR(sb.st_mode)) {
-	    close(fd);
-	    errno = ENOTDIR;
-	    fd = -1;
+	    rc = RPMERR_ENOTDIR;
+	    break;
 	}
 
 	close(dirfd);
 	if (fd >= 0) {
 	    dirfd = fd;
 	} else {
-	    dirfd = -1;
 	    rpmlog(RPMLOG_ERR, _("failed to open dir %s of %s: %s\n"),
 				bn, p, strerror(errno));
+	    rc = RPMERR_OPEN_FAILED;
 	    break;
 	}
 
 	dp = NULL;
     }
 
+    if (rc) {
+	close(fd);
+	close(dirfd);
+	dirfd = -1;
+    } else {
+	rc = 0;
+    }
+    *dirfdp = dirfd;
+
     free(path);
-    return dirfd;
+    return rc;
 }
 
 static int fsmMkfifo(int dirfd, const char *path, mode_t mode)
@@ -860,15 +873,14 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
 		rc = fsmBackup(fi, fp->action);
 	    }
 
-	    if (di.dirfd == -1) {
-		di.dirfd = ensureDir(plugins, rpmfiDN(fi), 0,
-				    (fp->action == FA_CREATE));
-		if (di.dirfd == -1) {
-		    rc = RPMERR_OPEN_FAILED;
-		    break;
-		}
+	    if (!rc) {
+		rc = ensureDir(plugins, rpmfiDN(fi), 0,
+				(fp->action == FA_CREATE), &di.dirfd);
 	    }
 
+	    if (rc)
+		goto setmeta; /* for error notification */
+
 	    /* Assume file does't exist when tmp suffix is in use */
 	    if (!fp->suffix) {
 		if (fp->action == FA_TOUCH) {

From e389e39ff26ec578e83e7ac80a405c01b0ca0d69 Mon Sep 17 00:00:00 2001
From: Panu Matilainen <pmatilai@redhat.com>
Date: Mon, 14 Feb 2022 10:41:19 +0200
Subject: [PATCH 11/32] Move file-post plugin hook back to commit stage

This isn't ideal from the sense that some files may get a success post
call while something later can still fail, but things get even weirder
with doing it in a separate round where things could fail because of
a vanished directory and then we'd still need to call the plugin hook
with some result. Also, this lets us skip the backwards walk on the
normal case of success, which is nice.
---
 lib/fsm.c | 24 ++++++++++++------------
 1 file changed, 12 insertions(+), 12 deletions(-)

diff --git a/lib/fsm.c b/lib/fsm.c
index acedd231a1..038e935238 100644
--- a/lib/fsm.c
+++ b/lib/fsm.c
@@ -977,23 +977,23 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
 		fp->stage = FILE_COMMIT;
 	    else
 		*failedFile = xstrdup(fp->fpath);
-	}
-    }
-    fi = rpmfiFree(fi);
 
-    /* Walk backwards in case we need to erase */
-    fi = rpmfilesIter(files, RPMFI_ITER_BACK);
-    while ((fx = rpmfiNext(fi)) >= 0) {
-	struct filedata_s *fp = &fdata[fx];
-	/* Run fsm file post hook for all plugins for all processed files */
-	if (fp->stage) {
+	    /* Run fsm file post hook for all plugins for all processed files */
 	    rpmpluginsCallFsmFilePost(plugins, fi, fp->fpath,
 				      fp->sb.st_mode, fp->action, rc);
 	}
+    }
+    fi = rpmfiFree(fi);
+
+    /* On failure, walk backwards and erase non-committed files */
+    if (rc) {
+	fi = rpmfilesIter(files, RPMFI_ITER_BACK);
+	while ((fx = rpmfiNext(fi)) >= 0) {
+	    struct filedata_s *fp = &fdata[fx];
 
-	/* On failure, erase non-committed files */
-	if (rc && fp->stage > FILE_NONE && !fp->skip) {
-	    (void) fsmRemove(fp->fpath, fp->sb.st_mode);
+	    if (fp->stage > FILE_NONE && !fp->skip) {
+		(void) fsmRemove(fp->fpath, fp->sb.st_mode);
+	    }
 	}
     }
 

From 7348fc8ea7982570ffd4e4fa52ce46629b9646a2 Mon Sep 17 00:00:00 2001
From: Panu Matilainen <pmatilai@redhat.com>
Date: Mon, 14 Feb 2022 11:01:49 +0200
Subject: [PATCH 12/32] Move file-pre plugin hook (back) to unpack stage

It doesn't make much sense to call plugins for files that wont be
unpacked at all, and in particular it wont make much sense to do the
entire directory dance just to be able to pass meaningful path values
to plugins. So from now we'll only be calling file-pre for things that
we're about to lay down, which it how it used to be before splitting
the stages anyhow.
---
 lib/fsm.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/lib/fsm.c b/lib/fsm.c
index 038e935238..2ffc941941 100644
--- a/lib/fsm.c
+++ b/lib/fsm.c
@@ -836,9 +836,6 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
 	setFileState(fs, fx);
 	fsmDebug(fp->fpath, fp->action, &fp->sb);
 
-	/* Run fsm file pre hook for all plugins */
-	rc = rpmpluginsCallFsmFilePre(plugins, fi, fp->fpath,
-				      fp->sb.st_mode, fp->action);
 	fp->stage = FILE_PRE;
     }
     fi = rpmfiFree(fi);
@@ -878,6 +875,9 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
 				(fp->action == FA_CREATE), &di.dirfd);
 	    }
 
+	    /* Run fsm file pre hook for all plugins */
+	    rc = rpmpluginsCallFsmFilePre(plugins, fi, fp->fpath,
+					  fp->sb.st_mode, fp->action);
 	    if (rc)
 		goto setmeta; /* for error notification */
 

From afb5215fdd3e1aa979fa6c973f974c1b11532f96 Mon Sep 17 00:00:00 2001
From: Panu Matilainen <pmatilai@redhat.com>
Date: Mon, 14 Feb 2022 10:57:12 +0200
Subject: [PATCH 13/32] Add a helper for finishing the dir tracking iteration

---
 lib/fsm.c | 11 ++++++++---
 1 file changed, 8 insertions(+), 3 deletions(-)

diff --git a/lib/fsm.c b/lib/fsm.c
index 2ffc941941..7a91cb39a9 100644
--- a/lib/fsm.c
+++ b/lib/fsm.c
@@ -792,6 +792,13 @@ static rpmfi fsmIter(FD_t payload, rpmfiles files, rpmFileIter iter, void *data)
     return fi;
 }
 
+static rpmfi fsmIterFini(rpmfi fi, struct diriter_s *di)
+{
+    close(di->dirfd);
+    di->dirfd = -1;
+    return rpmfiFree(fi);
+}
+
 int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
               rpmpsm psm, char ** failedFile)
 {
@@ -953,9 +960,7 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
 	    rpmpsmNotify(psm, RPMCALLBACK_INST_PROGRESS, rpmfiArchiveTell(fi));
 	fp->stage = FILE_UNPACK;
     }
-    fi = rpmfiFree(fi);
-    close(di.dirfd);
-    di.dirfd = -1;
+    fi = fsmIterFini(fi, &di);
 
     if (!rc && fx < 0 && fx != RPMERR_ITER_END)
 	rc = fx;

From 54b569670e539c291022f58f1ae4ed6b5dc9a70b Mon Sep 17 00:00:00 2001
From: Panu Matilainen <pmatilai@redhat.com>
Date: Mon, 14 Feb 2022 11:00:04 +0200
Subject: [PATCH 14/32] Extend directory tracking to our entire operation

---
 lib/fsm.c | 41 +++++++++++++++++++++++++++++------------
 1 file changed, 29 insertions(+), 12 deletions(-)

diff --git a/lib/fsm.c b/lib/fsm.c
index 7a91cb39a9..723287693d 100644
--- a/lib/fsm.c
+++ b/lib/fsm.c
@@ -340,7 +340,7 @@ static int fsmDoMkDir(rpmPlugins plugins, int dirfd, const char *dn,
 }
 
 static int ensureDir(rpmPlugins plugins, const char *p, int owned, int create,
-		    int *dirfdp)
+		    int quiet, int *dirfdp)
 {
     char *path = xstrdup(p);
     char *dp = path;
@@ -374,8 +374,10 @@ static int ensureDir(rpmPlugins plugins, const char *p, int owned, int create,
 	if (fd >= 0) {
 	    dirfd = fd;
 	} else {
-	    rpmlog(RPMLOG_ERR, _("failed to open dir %s of %s: %s\n"),
-				bn, p, strerror(errno));
+	    if (!quiet) {
+		rpmlog(RPMLOG_ERR, _("failed to open dir %s of %s: %s\n"),
+			bn, p, strerror(errno));
+	    }
 	    rc = RPMERR_OPEN_FAILED;
 	    break;
 	}
@@ -879,7 +881,7 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
 
 	    if (!rc) {
 		rc = ensureDir(plugins, rpmfiDN(fi), 0,
-				(fp->action == FA_CREATE), &di.dirfd);
+				(fp->action == FA_CREATE), 0, &di.dirfd);
 	    }
 
 	    /* Run fsm file pre hook for all plugins */
@@ -966,11 +968,14 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
 	rc = fx;
 
     /* If all went well, commit files to final destination */
-    fi = rpmfilesIter(files, RPMFI_ITER_FWD);
+    fi = fsmIter(NULL, files, RPMFI_ITER_FWD, &di);
     while (!rc && (fx = rpmfiNext(fi)) >= 0) {
 	struct filedata_s *fp = &fdata[fx];
 
 	if (!fp->skip) {
+	    if (!rc)
+		rc = ensureDir(NULL, rpmfiDN(fi), 0, 0, 0, &di.dirfd);
+
 	    /* Backup file if needed. Directories are handled earlier */
 	    if (!rc && fp->suffix)
 		rc = fsmBackup(fi, fp->action);
@@ -988,14 +993,18 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
 				      fp->sb.st_mode, fp->action, rc);
 	}
     }
-    fi = rpmfiFree(fi);
+    fi = fsmIterFini(fi, &di);
 
     /* On failure, walk backwards and erase non-committed files */
     if (rc) {
-	fi = rpmfilesIter(files, RPMFI_ITER_BACK);
+	fi = fsmIter(NULL, files, RPMFI_ITER_BACK, &di);
 	while ((fx = rpmfiNext(fi)) >= 0) {
 	    struct filedata_s *fp = &fdata[fx];
 
+	    /* If the directory doesn't exist there's nothing to clean up */
+	    if (ensureDir(NULL, rpmfiDN(fi), 0, 0, 1, &di.dirfd))
+		continue;
+
 	    if (fp->stage > FILE_NONE && !fp->skip) {
 		(void) fsmRemove(fp->fpath, fp->sb.st_mode);
 	    }
@@ -1006,7 +1015,7 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
     rpmswAdd(rpmtsOp(ts, RPMTS_OP_DIGEST), fdOp(payload, FDSTAT_DIGEST));
 
 exit:
-    fi = rpmfiFree(fi);
+    fi = fsmIterFini(fi, &di);
     Fclose(payload);
     free(tid);
     for (int i = 0; i < fc; i++)
@@ -1020,7 +1029,8 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
 int rpmPackageFilesRemove(rpmts ts, rpmte te, rpmfiles files,
               rpmpsm psm, char ** failedFile)
 {
-    rpmfi fi = rpmfilesIter(files, RPMFI_ITER_BACK);
+    struct diriter_s di = { -1 };
+    rpmfi fi = fsmIter(NULL, files, RPMFI_ITER_BACK, &di);
     rpmfs fs = rpmteGetFileStates(te);
     rpmPlugins plugins = rpmtsPlugins(ts);
     int fc = rpmfilesFC(files);
@@ -1031,7 +1041,15 @@ int rpmPackageFilesRemove(rpmts ts, rpmte te, rpmfiles files,
     while (!rc && (fx = rpmfiNext(fi)) >= 0) {
 	struct filedata_s *fp = &fdata[fx];
 	fp->action = rpmfsGetAction(fs, rpmfiFX(fi));
+
+	if (XFA_SKIPPING(fp->action))
+	    continue;
+
 	fp->fpath = fsmFsPath(fi, NULL);
+	/* If the directory doesn't exist there's nothing to clean up */
+	if (ensureDir(NULL, rpmfiDN(fi), 0, 0, 1, &di.dirfd))
+	    continue;
+
 	rc = fsmStat(fp->fpath, 1, &fp->sb);
 
 	fsmDebug(fp->fpath, fp->action, &fp->sb);
@@ -1040,8 +1058,7 @@ int rpmPackageFilesRemove(rpmts ts, rpmte te, rpmfiles files,
 	rc = rpmpluginsCallFsmFilePre(plugins, fi, fp->fpath,
 				      fp->sb.st_mode, fp->action);
 
-	if (!XFA_SKIPPING(fp->action))
-	    rc = fsmBackup(fi, fp->action);
+	rc = fsmBackup(fi, fp->action);
 
         /* Remove erased files. */
         if (fp->action == FA_ERASE) {
@@ -1098,7 +1115,7 @@ int rpmPackageFilesRemove(rpmts ts, rpmte te, rpmfiles files,
     for (int i = 0; i < fc; i++)
 	free(fdata[i].fpath);
     free(fdata);
-    rpmfiFree(fi);
+    fsmIterFini(fi, &di);
 
     return rc;
 }

From a4e0f7af46712de098265050838ae19bb3cc1fa5 Mon Sep 17 00:00:00 2001
From: Panu Matilainen <pmatilai@redhat.com>
Date: Mon, 14 Feb 2022 11:43:09 +0200
Subject: [PATCH 15/32] Convert fsmStat() to fstatat() based operation

---
 lib/fsm.c | 27 ++++++++++++---------------
 1 file changed, 12 insertions(+), 15 deletions(-)

diff --git a/lib/fsm.c b/lib/fsm.c
index 723287693d..66f3311712 100644
--- a/lib/fsm.c
+++ b/lib/fsm.c
@@ -236,18 +236,15 @@ static int fsmReadLink(const char *path,
     return rc;
 }
 
-static int fsmStat(const char *path, int dolstat, struct stat *sb)
+static int fsmStat(int dirfd, const char *path, int dolstat, struct stat *sb)
 {
-    int rc;
-    if (dolstat){
-	rc = lstat(path, sb);
-    } else {
-        rc = stat(path, sb);
-    }
+    int flags = dolstat ? AT_SYMLINK_NOFOLLOW : 0;
+    int rc = fstatat(dirfd, path, sb, flags);
+
     if (_fsm_debug && rc && errno != ENOENT)
-        rpmlog(RPMLOG_DEBUG, " %8s (%s, ost) %s\n",
+        rpmlog(RPMLOG_DEBUG, " %8s (%d %s, ost) %s\n",
                __func__,
-               path, (rc < 0 ? strerror(errno) : ""));
+               dirfd, path, (rc < 0 ? strerror(errno) : ""));
     if (rc < 0) {
         rc = (errno == ENOENT ? RPMERR_ENOENT : RPMERR_LSTAT_FAILED);
 	/* Ensure consistent struct content on failure */
@@ -567,14 +564,14 @@ static int fsmUtime(const char *path, mode_t mode, time_t mtime)
     return rc;
 }
 
-static int fsmVerify(const char *path, rpmfi fi)
+static int fsmVerify(int dirfd, const char *path, rpmfi fi)
 {
     int rc;
     int saveerrno = errno;
     struct stat dsb;
     mode_t mode = rpmfiFMode(fi);
 
-    rc = fsmStat(path, 1, &dsb);
+    rc = fsmStat(dirfd, path, 1, &dsb);
     if (rc)
 	return rc;
 
@@ -593,7 +590,7 @@ static int fsmVerify(const char *path, rpmfi fi)
         if (S_ISDIR(dsb.st_mode)) return 0;
         if (S_ISLNK(dsb.st_mode)) {
 	    uid_t luid = dsb.st_uid;
-            rc = fsmStat(path, 0, &dsb);
+            rc = fsmStat(dirfd, path, 0, &dsb);
             if (rc == RPMERR_ENOENT) rc = 0;
             if (rc) return rc;
             errno = saveerrno;
@@ -894,9 +891,9 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
 	    if (!fp->suffix) {
 		if (fp->action == FA_TOUCH) {
 		    struct stat sb;
-		    rc = fsmStat(fp->fpath, 1, &sb);
+		    rc = fsmStat(di.dirfd, fp->fpath, 1, &sb);
 		} else {
-		    rc = fsmVerify(fp->fpath, fi);
+		    rc = fsmVerify(di.dirfd, fp->fpath, fi);
 		}
 	    } else {
 		rc = RPMERR_ENOENT;
@@ -1050,7 +1047,7 @@ int rpmPackageFilesRemove(rpmts ts, rpmte te, rpmfiles files,
 	if (ensureDir(NULL, rpmfiDN(fi), 0, 0, 1, &di.dirfd))
 	    continue;
 
-	rc = fsmStat(fp->fpath, 1, &fp->sb);
+	rc = fsmStat(di.dirfd, fp->fpath, 1, &fp->sb);
 
 	fsmDebug(fp->fpath, fp->action, &fp->sb);
 

From d27a6102e13e7a41c56f1e4a192d2c9a414f10f0 Mon Sep 17 00:00:00 2001
From: Panu Matilainen <pmatilai@redhat.com>
Date: Mon, 14 Feb 2022 11:43:53 +0200
Subject: [PATCH 16/32] Convert fsmRemove() and helpers to unlinkat() based
 operation

---
 configure.ac |  2 +-
 lib/fsm.c    | 28 ++++++++++++++--------------
 2 files changed, 15 insertions(+), 15 deletions(-)

diff --git a/configure.ac b/configure.ac
index ac9003768a..506b798aed 100644
--- a/configure.ac
+++ b/configure.ac
@@ -581,7 +581,7 @@ AC_CHECK_FUNCS([secure_getenv __secure_getenv])
 AC_CHECK_FUNCS(
    [mkstemp getcwd basename dirname realpath setenv unsetenv regcomp lchown \
     utimes getline localtime_r statvfs getaddrinfo \
-    openat mkdirat fstatat linkat symlinkat mkfifoat mknodat ],
+    openat mkdirat fstatat linkat symlinkat mkfifoat mknodat unlinkat ],
    [], [AC_MSG_ERROR([function required by rpm])])
 
 AC_LIBOBJ(fnmatch)
diff --git a/lib/fsm.c b/lib/fsm.c
index 66f3311712..a432fc5d28 100644
--- a/lib/fsm.c
+++ b/lib/fsm.c
@@ -253,12 +253,12 @@ static int fsmStat(int dirfd, const char *path, int dolstat, struct stat *sb)
     return rc;
 }
 
-static int fsmRmdir(const char *path)
+static int fsmRmdir(int dirfd, const char *path)
 {
-    int rc = rmdir(path);
+    int rc = unlinkat(dirfd, path, AT_REMOVEDIR);
     if (_fsm_debug)
-	rpmlog(RPMLOG_DEBUG, " %8s (%s) %s\n", __func__,
-	       path, (rc < 0 ? strerror(errno) : ""));
+	rpmlog(RPMLOG_DEBUG, " %8s (%d %s) %s\n", __func__,
+	       dirfd, path, (rc < 0 ? strerror(errno) : ""));
     if (rc < 0)
 	switch (errno) {
 	case ENOENT:        rc = RPMERR_ENOENT;    break;
@@ -467,14 +467,14 @@ static int fsmSymlink(const char *opath, int dirfd, const char *path)
     return rc;
 }
 
-static int fsmUnlink(const char *path)
+static int fsmUnlink(int dirfd, const char *path)
 {
     int rc = 0;
     removeSBITS(path);
-    rc = unlink(path);
+    rc = unlinkat(dirfd, path, 0);
     if (_fsm_debug)
-	rpmlog(RPMLOG_DEBUG, " %8s (%s) %s\n", __func__,
-	       path, (rc < 0 ? strerror(errno) : ""));
+	rpmlog(RPMLOG_DEBUG, " %8s (%d %s) %s\n", __func__,
+	       dirfd, path, (rc < 0 ? strerror(errno) : ""));
     if (rc < 0)
 	rc = (errno == ENOENT ? RPMERR_ENOENT : RPMERR_UNLINK_FAILED);
     return rc;
@@ -502,9 +502,9 @@ static int fsmRename(const char *opath, const char *path)
     return rc;
 }
 
-static int fsmRemove(const char *path, mode_t mode)
+static int fsmRemove(int dirfd, const char *path, mode_t mode)
 {
-    return S_ISDIR(mode) ? fsmRmdir(path) : fsmUnlink(path);
+    return S_ISDIR(mode) ? fsmRmdir(dirfd, path) : fsmUnlink(dirfd, path);
 }
 
 static int fsmChown(const char *path, mode_t mode, uid_t uid, gid_t gid)
@@ -581,7 +581,7 @@ static int fsmVerify(int dirfd, const char *path, rpmfi fi)
 	rc = fsmRename(path, rmpath);
 	/* XXX shouldn't we take unlink return code here? */
 	if (!rc)
-	    (void) fsmUnlink(rmpath);
+	    (void) fsmUnlink(dirfd, rmpath);
 	else
 	    rc = RPMERR_UNLINK_FAILED;
 	free(rmpath);
@@ -616,7 +616,7 @@ static int fsmVerify(int dirfd, const char *path, rpmfi fi)
         if (S_ISSOCK(dsb.st_mode)) return 0;
     }
     /* XXX shouldn't do this with commit/undo. */
-    rc = fsmUnlink(path);
+    rc = fsmUnlink(dirfd, path);
     if (rc == 0)	rc = RPMERR_ENOENT;
     return (rc ? rc : RPMERR_ENOENT);	/* XXX HACK */
 }
@@ -1003,7 +1003,7 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
 		continue;
 
 	    if (fp->stage > FILE_NONE && !fp->skip) {
-		(void) fsmRemove(fp->fpath, fp->sb.st_mode);
+		(void) fsmRemove(di.dirfd, fp->fpath, fp->sb.st_mode);
 	    }
 	}
     }
@@ -1061,7 +1061,7 @@ int rpmPackageFilesRemove(rpmts ts, rpmte te, rpmfiles files,
         if (fp->action == FA_ERASE) {
 	    int missingok = (rpmfiFFlags(fi) & (RPMFILE_MISSINGOK | RPMFILE_GHOST));
 
-	    rc = fsmRemove(fp->fpath, fp->sb.st_mode);
+	    rc = fsmRemove(di.dirfd, fp->fpath, fp->sb.st_mode);
 
 	    /*
 	     * Missing %ghost or %missingok entries are not errors.

From 4364a400bcaf9aee0437d06eb73cde3fd1a5a962 Mon Sep 17 00:00:00 2001
From: Panu Matilainen <pmatilai@redhat.com>
Date: Mon, 14 Feb 2022 11:56:47 +0200
Subject: [PATCH 17/32] Convert fsmRename() to renameat() based operation

All our renames are (for now at least) within a single directory so
the second dirfd is kinda redundant, but shrug...
---
 configure.ac |  3 ++-
 lib/fsm.c    | 31 ++++++++++++++++---------------
 2 files changed, 18 insertions(+), 16 deletions(-)

diff --git a/configure.ac b/configure.ac
index 506b798aed..491094cf60 100644
--- a/configure.ac
+++ b/configure.ac
@@ -581,7 +581,8 @@ AC_CHECK_FUNCS([secure_getenv __secure_getenv])
 AC_CHECK_FUNCS(
    [mkstemp getcwd basename dirname realpath setenv unsetenv regcomp lchown \
     utimes getline localtime_r statvfs getaddrinfo \
-    openat mkdirat fstatat linkat symlinkat mkfifoat mknodat unlinkat ],
+    openat mkdirat fstatat linkat symlinkat mkfifoat mknodat unlinkat \
+    renameat ],
    [], [AC_MSG_ERROR([function required by rpm])])
 
 AC_LIBOBJ(fnmatch)
diff --git a/lib/fsm.c b/lib/fsm.c
index a432fc5d28..13b114220d 100644
--- a/lib/fsm.c
+++ b/lib/fsm.c
@@ -480,23 +480,24 @@ static int fsmUnlink(int dirfd, const char *path)
     return rc;
 }
 
-static int fsmRename(const char *opath, const char *path)
+static int fsmRename(int odirfd, const char *opath, int dirfd, const char *path)
 {
     removeSBITS(path);
-    int rc = rename(opath, path);
+    int rc = renameat(odirfd, opath, dirfd, path);
 #if defined(ETXTBSY) && defined(__HPUX__)
     /* XXX HP-UX (and other os'es) don't permit rename to busy files. */
     if (rc && errno == ETXTBSY) {
 	char *rmpath = NULL;
 	rstrscat(&rmpath, path, "-RPMDELETE", NULL);
-	rc = rename(path, rmpath);
-	if (!rc) rc = rename(opath, path);
+	/* Rename within the original directory */
+	rc = renameat(odirfd, path, odirfd, rmpath);
+	if (!rc) rc = renameat(odirfd, opath, dirfd, path);
 	free(rmpath);
     }
 #endif
     if (_fsm_debug)
-	rpmlog(RPMLOG_DEBUG, " %8s (%s, %s) %s\n", __func__,
-	       opath, path, (rc < 0 ? strerror(errno) : ""));
+	rpmlog(RPMLOG_DEBUG, " %8s (%d %s, %d %s) %s\n", __func__,
+	       odirfd, opath, dirfd, path, (rc < 0 ? strerror(errno) : ""));
     if (rc < 0)
 	rc = (errno == EISDIR ? RPMERR_EXIST_AS_DIR : RPMERR_RENAME_FAILED);
     return rc;
@@ -578,7 +579,7 @@ static int fsmVerify(int dirfd, const char *path, rpmfi fi)
     if (S_ISREG(mode)) {
 	/* HP-UX (and other os'es) don't permit unlink on busy files. */
 	char *rmpath = rstrscat(NULL, path, "-RPMDELETE", NULL);
-	rc = fsmRename(path, rmpath);
+	rc = fsmRename(dirfd, path, dirfd, rmpath);
 	/* XXX shouldn't we take unlink return code here? */
 	if (!rc)
 	    (void) fsmUnlink(dirfd, rmpath);
@@ -630,7 +631,7 @@ static int fsmVerify(int dirfd, const char *path, rpmfi fi)
 
 
 /* Rename pre-existing modified or unmanaged file. */
-static int fsmBackup(rpmfi fi, rpmFileAction action)
+static int fsmBackup(int dirfd, rpmfi fi, rpmFileAction action)
 {
     int rc = 0;
     const char *suffix = NULL;
@@ -651,7 +652,7 @@ static int fsmBackup(rpmfi fi, rpmFileAction action)
     if (suffix) {
 	char * opath = fsmFsPath(fi, NULL);
 	char * path = fsmFsPath(fi, suffix);
-	rc = fsmRename(opath, path);
+	rc = fsmRename(dirfd, opath, dirfd, path);
 	if (!rc) {
 	    rpmlog(RPMLOG_WARNING, _("%s saved as %s\n"), opath, path);
 	}
@@ -689,7 +690,7 @@ static int fsmSetmeta(const char *path, rpmfi fi, rpmPlugins plugins,
     return rc;
 }
 
-static int fsmCommit(char **path, rpmfi fi, rpmFileAction action, const char *suffix)
+static int fsmCommit(int dirfd, char **path, rpmfi fi, rpmFileAction action, const char *suffix)
 {
     int rc = 0;
 
@@ -703,7 +704,7 @@ static int fsmCommit(char **path, rpmfi fi, rpmFileAction action, const char *su
 
 	/* Rename temporary to final file name if needed. */
 	if (dest != *path) {
-	    rc = fsmRename(*path, dest);
+	    rc = fsmRename(dirfd, *path, dirfd, dest);
 	    if (!rc) {
 		if (nsuffix) {
 		    char * opath = fsmFsPath(fi, NULL);
@@ -873,7 +874,7 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
         if (!fp->skip) {
 	    /* Directories replacing something need early backup */
 	    if (!fp->suffix && fp != firstlink) {
-		rc = fsmBackup(fi, fp->action);
+		rc = fsmBackup(di.dirfd, fi, fp->action);
 	    }
 
 	    if (!rc) {
@@ -975,10 +976,10 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
 
 	    /* Backup file if needed. Directories are handled earlier */
 	    if (!rc && fp->suffix)
-		rc = fsmBackup(fi, fp->action);
+		rc = fsmBackup(di.dirfd, fi, fp->action);
 
 	    if (!rc)
-		rc = fsmCommit(&fp->fpath, fi, fp->action, fp->suffix);
+		rc = fsmCommit(di.dirfd, &fp->fpath, fi, fp->action, fp->suffix);
 
 	    if (!rc)
 		fp->stage = FILE_COMMIT;
@@ -1055,7 +1056,7 @@ int rpmPackageFilesRemove(rpmts ts, rpmte te, rpmfiles files,
 	rc = rpmpluginsCallFsmFilePre(plugins, fi, fp->fpath,
 				      fp->sb.st_mode, fp->action);
 
-	rc = fsmBackup(fi, fp->action);
+	rc = fsmBackup(di.dirfd, fi, fp->action);
 
         /* Remove erased files. */
         if (fp->action == FA_ERASE) {

From 6a75a4ad029c6232fcf9e7408b97af9ddb4a3095 Mon Sep 17 00:00:00 2001
From: Panu Matilainen <pmatilai@redhat.com>
Date: Mon, 14 Feb 2022 12:35:58 +0200
Subject: [PATCH 18/32] Bury rpmio FD use to fsmUnpack()

fsmUnpack() is the only place in FSM that needs to deal with rpmio FD
types, everywhere else they are nothing but a hindrance that need to
be converted to OS level descriptors for use. Better deal with OS
level descriptors to begin with.
---
 lib/fsm.c | 37 ++++++++++++++++---------------------
 1 file changed, 16 insertions(+), 21 deletions(-)

diff --git a/lib/fsm.c b/lib/fsm.c
index 13b114220d..b019f5711c 100644
--- a/lib/fsm.c
+++ b/lib/fsm.c
@@ -110,14 +110,14 @@ static int fsmSetFCaps(const char *path, const char *captxt)
     return rc;
 }
 
-static int fsmClose(FD_t *wfdp)
+static int fsmClose(int *wfdp)
 {
     int rc = 0;
-    if (wfdp && *wfdp) {
+    if (wfdp && *wfdp >= 0) {
 	int myerrno = errno;
 	static int oneshot = 0;
 	static int flush_io = 0;
-	int fdno = Fileno(*wfdp);
+	int fdno = *wfdp;
 
 	if (!oneshot) {
 	    flush_io = (rpmExpandNumeric("%{?_flush_io}") > 0);
@@ -126,61 +126,56 @@ static int fsmClose(FD_t *wfdp)
 	if (flush_io) {
 	    fsync(fdno);
 	}
-	if (Fclose(*wfdp))
+	if (close(fdno))
 	    rc = RPMERR_CLOSE_FAILED;
 
 	if (_fsm_debug) {
 	    rpmlog(RPMLOG_DEBUG, " %8s ([%d]) %s\n", __func__,
 		   fdno, (rc < 0 ? strerror(errno) : ""));
 	}
-	*wfdp = NULL;
+	*wfdp = -1;
 	errno = myerrno;
     }
     return rc;
 }
 
-static int fsmOpen(FD_t *wfdp, int dirfd, const char *dest)
+static int fsmOpen(int *wfdp, int dirfd, const char *dest)
 {
     int rc = 0;
     /* Create the file with 0200 permissions (write by owner). */
     int fd = openat(dirfd, dest, O_WRONLY|O_EXCL|O_CREAT, 0200);
 
-    if (fd >= 0) {
-	*wfdp = fdDup(fd);
-	close(fd);
-    }
-
-    if (fd < 0 || Ferror(*wfdp))
+    if (fd < 0)
 	rc = RPMERR_OPEN_FAILED;
 
     if (_fsm_debug) {
 	rpmlog(RPMLOG_DEBUG, " %8s (%s [%d]) %s\n", __func__,
-	       dest, Fileno(*wfdp), (rc < 0 ? strerror(errno) : ""));
+	       dest, fd, (rc < 0 ? strerror(errno) : ""));
     }
-
-    if (rc)
-	fsmClose(wfdp);
+    *wfdp = fd;
 
     return rc;
 }
 
-static int fsmUnpack(rpmfi fi, FD_t fd, rpmpsm psm, int nodigest)
+static int fsmUnpack(rpmfi fi, int fdno, rpmpsm psm, int nodigest)
 {
+    FD_t fd = fdDup(fdno);
     int rc = rpmfiArchiveReadToFilePsm(fi, fd, nodigest, psm);
     if (_fsm_debug) {
 	rpmlog(RPMLOG_DEBUG, " %8s (%s %" PRIu64 " bytes [%d]) %s\n", __func__,
 	       rpmfiFN(fi), rpmfiFSize(fi), Fileno(fd),
 	       (rc < 0 ? strerror(errno) : ""));
     }
+    Fclose(fd);
     return rc;
 }
 
 static int fsmMkfile(int dirfd, rpmfi fi, struct filedata_s *fp, rpmfiles files,
 		     rpmpsm psm, int nodigest,
-		     struct filedata_s ** firstlink, FD_t *firstlinkfile)
+		     struct filedata_s ** firstlink, int *firstlinkfile)
 {
     int rc = 0;
-    FD_t fd = NULL;
+    int fd = -1;
 
     if (*firstlink == NULL) {
 	/* First encounter, open file for writing */
@@ -206,7 +201,7 @@ static int fsmMkfile(int dirfd, rpmfi fi, struct filedata_s *fp, rpmfiles files,
 	if (*firstlink) {
 	    fp->setmeta = 1;
 	    *firstlink = NULL;
-	    *firstlinkfile = NULL;
+	    *firstlinkfile = -1;
 	}
     }
 
@@ -811,7 +806,7 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
     int fc = rpmfilesFC(files);
     int nodigest = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOFILEDIGEST) ? 1 : 0;
     int nofcaps = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOCAPS) ? 1 : 0;
-    FD_t firstlinkfile = NULL;
+    int firstlinkfile = -1;
     char *tid = NULL;
     struct filedata_s *fdata = xcalloc(fc, sizeof(*fdata));
     struct filedata_s *firstlink = NULL;

From 77ea371dc628861302e731e57c7048861f2efd55 Mon Sep 17 00:00:00 2001
From: Panu Matilainen <pmatilai@redhat.com>
Date: Mon, 14 Feb 2022 12:44:42 +0200
Subject: [PATCH 19/32] Return descriptor of created file from fsmMkfile()

This will be needed for using fd-based metadata operations.
---
 lib/fsm.c | 13 ++++++++-----
 1 file changed, 8 insertions(+), 5 deletions(-)

diff --git a/lib/fsm.c b/lib/fsm.c
index b019f5711c..7c4796f744 100644
--- a/lib/fsm.c
+++ b/lib/fsm.c
@@ -172,7 +172,8 @@ static int fsmUnpack(rpmfi fi, int fdno, rpmpsm psm, int nodigest)
 
 static int fsmMkfile(int dirfd, rpmfi fi, struct filedata_s *fp, rpmfiles files,
 		     rpmpsm psm, int nodigest,
-		     struct filedata_s ** firstlink, int *firstlinkfile)
+		     struct filedata_s ** firstlink, int *firstlinkfile,
+		     int *fdp)
 {
     int rc = 0;
     int fd = -1;
@@ -204,9 +205,7 @@ static int fsmMkfile(int dirfd, rpmfi fi, struct filedata_s *fp, rpmfiles files,
 	    *firstlinkfile = -1;
 	}
     }
-
-    if (fd != *firstlinkfile)
-	fsmClose(&fd);
+    *fdp = fd;
 
     return rc;
 }
@@ -867,6 +866,7 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
 	    fp = firstlink;
 
         if (!fp->skip) {
+	    int fd = -1;
 	    /* Directories replacing something need early backup */
 	    if (!fp->suffix && fp != firstlink) {
 		rc = fsmBackup(di.dirfd, fi, fp->action);
@@ -910,7 +910,7 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
             if (S_ISREG(fp->sb.st_mode)) {
 		if (rc == RPMERR_ENOENT) {
 		    rc = fsmMkfile(di.dirfd, fi, fp, files, psm, nodigest,
-				   &firstlink, &firstlinkfile);
+				   &firstlink, &firstlinkfile, &fd);
 		}
             } else if (S_ISDIR(fp->sb.st_mode)) {
                 if (rc == RPMERR_ENOENT) {
@@ -946,6 +946,9 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
 		rc = fsmSetmeta(fp->fpath, fi, plugins, fp->action,
 				&fp->sb, nofcaps);
 	    }
+
+	    if (fd != firstlinkfile)
+		fsmClose(&fd);
 	}
 
 	/* Notify on success. */

From 3ff74b4e5518040a3caa8898855473754a8d8af8 Mon Sep 17 00:00:00 2001
From: Panu Matilainen <pmatilai@redhat.com>
Date: Mon, 14 Feb 2022 13:41:38 +0200
Subject: [PATCH 20/32] Convert fsmSetmeta() to dirfd based operation where
 possible

Notably cap_set_file() doesn't have a dirfd-based mode, to handle that
safely we'll need to use fd-based operation. Which would be nicer anyhow
but symlinks can't be opened so we'll have to carry the dirfd/path based
mode forever more anyhow (yes Linux has extensions but that's another
story).
---
 configure.ac |  2 +-
 lib/fsm.c    | 74 ++++++++++++++++++++++++++++------------------------
 2 files changed, 41 insertions(+), 35 deletions(-)

diff --git a/configure.ac b/configure.ac
index 491094cf60..d1e7482b7a 100644
--- a/configure.ac
+++ b/configure.ac
@@ -582,7 +582,7 @@ AC_CHECK_FUNCS(
    [mkstemp getcwd basename dirname realpath setenv unsetenv regcomp lchown \
     utimes getline localtime_r statvfs getaddrinfo \
     openat mkdirat fstatat linkat symlinkat mkfifoat mknodat unlinkat \
-    renameat ],
+    renameat utimensat fchmodat fchownat ],
    [], [AC_MSG_ERROR([function required by rpm])])
 
 AC_LIBOBJ(fnmatch)
diff --git a/lib/fsm.c b/lib/fsm.c
index 7c4796f744..af83bdcd6c 100644
--- a/lib/fsm.c
+++ b/lib/fsm.c
@@ -91,18 +91,23 @@ static int fsmLink(int odirfd, const char *opath, int dirfd, const char *path)
     return rc;
 }
 
-static int fsmSetFCaps(const char *path, const char *captxt)
+static int fsmSetFCaps(int dirfd, const char *path, const char *captxt)
 {
     int rc = 0;
+
 #if WITH_CAP
     if (captxt && *captxt != '\0') {
 	cap_t fcaps = cap_from_text(captxt);
-	if (fcaps == NULL || cap_set_file(path, fcaps) != 0) {
+	/* cap_set_file() doesn't support dirfd based operation */
+	if ((dirfd >= 0 && *path != '/') || fcaps == NULL)
 	    rc = RPMERR_SETCAP_FAILED;
-	}
+
+	if (!rc && cap_set_file(path, fcaps) != 0)
+	    rc = RPMERR_SETCAP_FAILED;
+
 	if (_fsm_debug) {
-	    rpmlog(RPMLOG_DEBUG, " %8s (%s, %s) %s\n", __func__,
-		   path, captxt, (rc < 0 ? strerror(errno) : ""));
+	    rpmlog(RPMLOG_DEBUG, " %8s (%d %s, %s) %s\n", __func__,
+		   dirfd, path, captxt, (rc < 0 ? strerror(errno) : ""));
 	}
 	cap_free(fcaps);
     } 
@@ -502,56 +507,56 @@ static int fsmRemove(int dirfd, const char *path, mode_t mode)
     return S_ISDIR(mode) ? fsmRmdir(dirfd, path) : fsmUnlink(dirfd, path);
 }
 
-static int fsmChown(const char *path, mode_t mode, uid_t uid, gid_t gid)
+static int fsmChown(int dirfd, const char *path, mode_t mode, uid_t uid, gid_t gid)
 {
-    int rc = S_ISLNK(mode) ? lchown(path, uid, gid) : chown(path, uid, gid);
+    int flags = S_ISLNK(mode) ? AT_SYMLINK_NOFOLLOW : 0;
+    int rc = fchownat(dirfd, path, uid, gid, flags);
     if (rc < 0) {
 	struct stat st;
-	if (lstat(path, &st) == 0 && st.st_uid == uid && st.st_gid == gid)
+	if (fstatat(dirfd, path, &st, flags) == 0 &&
+		(st.st_uid == uid && st.st_gid == gid)) {
 	    rc = 0;
+	}
     }
     if (_fsm_debug)
-	rpmlog(RPMLOG_DEBUG, " %8s (%s, %d, %d) %s\n", __func__,
-	       path, (int)uid, (int)gid,
+	rpmlog(RPMLOG_DEBUG, " %8s (%d %s, %d, %d) %s\n", __func__,
+	       dirfd, path, (int)uid, (int)gid,
 	       (rc < 0 ? strerror(errno) : ""));
     if (rc < 0)	rc = RPMERR_CHOWN_FAILED;
     return rc;
 }
 
-static int fsmChmod(const char *path, mode_t mode)
+static int fsmChmod(int dirfd, const char *path, mode_t mode)
 {
-    int rc = chmod(path, (mode & 07777));
+    int rc = fchmodat(dirfd, path, (mode & 07777), 0);
     if (rc < 0) {
 	struct stat st;
-	if (lstat(path, &st) == 0 && (st.st_mode & 07777) == (mode & 07777))
+	if (fstatat(dirfd, path, &st, AT_SYMLINK_NOFOLLOW) == 0 &&
+		(st.st_mode & 07777) == (mode & 07777)) {
 	    rc = 0;
+	}
     }
     if (_fsm_debug)
-	rpmlog(RPMLOG_DEBUG, " %8s (%s, 0%04o) %s\n", __func__,
-	       path, (unsigned)(mode & 07777),
+	rpmlog(RPMLOG_DEBUG, " %8s (%d %s, 0%04o) %s\n", __func__,
+	       dirfd, path, (unsigned)(mode & 07777),
 	       (rc < 0 ? strerror(errno) : ""));
     if (rc < 0)	rc = RPMERR_CHMOD_FAILED;
     return rc;
 }
 
-static int fsmUtime(const char *path, mode_t mode, time_t mtime)
+static int fsmUtime(int dirfd, const char *path, mode_t mode, time_t mtime)
 {
     int rc = 0;
-    struct timeval stamps[2] = {
-	{ .tv_sec = mtime, .tv_usec = 0 },
-	{ .tv_sec = mtime, .tv_usec = 0 },
+    struct timespec stamps[2] = {
+	{ .tv_sec = mtime, .tv_nsec = 0 },
+	{ .tv_sec = mtime, .tv_nsec = 0 },
     };
 
-#if HAVE_LUTIMES
-    rc = lutimes(path, stamps);
-#else
-    if (!S_ISLNK(mode))
-	rc = utimes(path, stamps);
-#endif
+    rc = utimensat(dirfd, path, stamps, AT_SYMLINK_NOFOLLOW);
     
     if (_fsm_debug)
-	rpmlog(RPMLOG_DEBUG, " %8s (%s, 0x%x) %s\n", __func__,
-	       path, (unsigned)mtime, (rc < 0 ? strerror(errno) : ""));
+	rpmlog(RPMLOG_DEBUG, " %8s (%d %s, 0x%x) %s\n", __func__,
+	       dirfd, path, (unsigned)mtime, (rc < 0 ? strerror(errno) : ""));
     if (rc < 0)	rc = RPMERR_UTIME_FAILED;
     /* ...but utime error is not critical for directories */
     if (rc && S_ISDIR(mode))
@@ -656,7 +661,7 @@ static int fsmBackup(int dirfd, rpmfi fi, rpmFileAction action)
     return rc;
 }
 
-static int fsmSetmeta(const char *path, rpmfi fi, rpmPlugins plugins,
+static int fsmSetmeta(int dirfd, const char *path, rpmfi fi, rpmPlugins plugins,
 		      rpmFileAction action, const struct stat * st,
 		      int nofcaps)
 {
@@ -664,21 +669,22 @@ static int fsmSetmeta(const char *path, rpmfi fi, rpmPlugins plugins,
     const char *dest = rpmfiFN(fi);
 
     if (!rc && !getuid()) {
-	rc = fsmChown(path, st->st_mode, st->st_uid, st->st_gid);
+	rc = fsmChown(dirfd, path, st->st_mode, st->st_uid, st->st_gid);
     }
     if (!rc && !S_ISLNK(st->st_mode)) {
-	rc = fsmChmod(path, st->st_mode);
+	rc = fsmChmod(dirfd, path, st->st_mode);
     }
     /* Set file capabilities (if enabled) */
     if (!rc && !nofcaps && S_ISREG(st->st_mode) && !getuid()) {
-	rc = fsmSetFCaps(path, rpmfiFCaps(fi));
+	rc = fsmSetFCaps(dirfd, path, rpmfiFCaps(fi));
     }
     if (!rc) {
-	rc = fsmUtime(path, st->st_mode, rpmfiFMtime(fi));
+	rc = fsmUtime(dirfd, path, st->st_mode, rpmfiFMtime(fi));
     }
     if (!rc) {
 	rc = rpmpluginsCallFsmFilePrepare(plugins, fi,
-					  path, dest, st->st_mode, action);
+					  path, dest,
+					  st->st_mode, action);
     }
 
     return rc;
@@ -943,7 +949,7 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
 
 setmeta:
 	    if (!rc && fp->setmeta) {
-		rc = fsmSetmeta(fp->fpath, fi, plugins, fp->action,
+		rc = fsmSetmeta(di.dirfd, fp->fpath, fi, plugins, fp->action,
 				&fp->sb, nofcaps);
 	    }
 

From 4682bcffd8af58cd47385508d9432e313c5cdfd7 Mon Sep 17 00:00:00 2001
From: Panu Matilainen <pmatilai@redhat.com>
Date: Mon, 14 Feb 2022 14:23:51 +0200
Subject: [PATCH 21/32] Add support for fd-based file metadata setting

We need to support both fd-based and (dirfd+) path based operations
due to all the lovely mismatches in POSIX, so lotsa half-duplicated
tedious stuff here.

As of this commit, we only use fd based ops for regular files.
---
 lib/fsm.c | 120 +++++++++++++++++++++++++++++++++++++-----------------
 1 file changed, 82 insertions(+), 38 deletions(-)

diff --git a/lib/fsm.c b/lib/fsm.c
index af83bdcd6c..913e9de2d7 100644
--- a/lib/fsm.c
+++ b/lib/fsm.c
@@ -65,6 +65,7 @@ struct filedata_s {
  * things around needlessly 
  */ 
 static const char * fileActionString(rpmFileAction a);
+static int fsmOpenat(int dirfd, const char *path, int flags);
 
 /** \ingroup payload
  * Build path to file from file info, optionally ornamented with suffix.
@@ -91,23 +92,36 @@ static int fsmLink(int odirfd, const char *opath, int dirfd, const char *path)
     return rc;
 }
 
-static int fsmSetFCaps(int dirfd, const char *path, const char *captxt)
+static int cap_set_fileat(int dirfd, const char *path, cap_t fcaps)
+{
+    int rc = -1;
+    int fd = fsmOpenat(dirfd, path, O_RDONLY|O_NOFOLLOW);
+    if (fd >= 0) {
+	rc = cap_set_fd(fd, fcaps);
+	close(fd);
+    }
+    return rc;
+}
+
+static int fsmSetFCaps(int fd, int dirfd, const char *path, const char *captxt)
 {
     int rc = 0;
 
 #if WITH_CAP
     if (captxt && *captxt != '\0') {
 	cap_t fcaps = cap_from_text(captxt);
-	/* cap_set_file() doesn't support dirfd based operation */
-	if ((dirfd >= 0 && *path != '/') || fcaps == NULL)
-	    rc = RPMERR_SETCAP_FAILED;
 
-	if (!rc && cap_set_file(path, fcaps) != 0)
-	    rc = RPMERR_SETCAP_FAILED;
+	if (fd >= 0) {
+	    if (fcaps == NULL || cap_set_fd(fd, fcaps))
+		rc = RPMERR_SETCAP_FAILED;
+	} else {
+	    if (fcaps == NULL || cap_set_fileat(dirfd, path, fcaps))
+		rc = RPMERR_SETCAP_FAILED;
+	}
 
 	if (_fsm_debug) {
-	    rpmlog(RPMLOG_DEBUG, " %8s (%d %s, %s) %s\n", __func__,
-		   dirfd, path, captxt, (rc < 0 ? strerror(errno) : ""));
+	    rpmlog(RPMLOG_DEBUG, " %8s (%d - %d %s, %s) %s\n", __func__,
+		   fd, dirfd, path, captxt, (rc < 0 ? strerror(errno) : ""));
 	}
 	cap_free(fcaps);
     } 
@@ -507,44 +521,69 @@ static int fsmRemove(int dirfd, const char *path, mode_t mode)
     return S_ISDIR(mode) ? fsmRmdir(dirfd, path) : fsmUnlink(dirfd, path);
 }
 
-static int fsmChown(int dirfd, const char *path, mode_t mode, uid_t uid, gid_t gid)
+static int fsmChown(int fd, int dirfd, const char *path, mode_t mode, uid_t uid, gid_t gid)
 {
-    int flags = S_ISLNK(mode) ? AT_SYMLINK_NOFOLLOW : 0;
-    int rc = fchownat(dirfd, path, uid, gid, flags);
-    if (rc < 0) {
-	struct stat st;
-	if (fstatat(dirfd, path, &st, flags) == 0 &&
-		(st.st_uid == uid && st.st_gid == gid)) {
-	    rc = 0;
+    int rc;
+    struct stat st;
+
+    if (fd >= 0) {
+	rc = fchown(fd, uid, gid);
+	if (rc < 0) {
+	    if (fstat(fd, &st) == 0 && (st.st_uid == uid && st.st_gid == gid)) {
+		rc = 0;
+	    }
+	}
+    } else {
+	int flags = S_ISLNK(mode) ? AT_SYMLINK_NOFOLLOW : 0;
+	rc = fchownat(dirfd, path, uid, gid, flags);
+	if (rc < 0) {
+	    struct stat st;
+	    if (fstatat(dirfd, path, &st, flags) == 0 &&
+		    (st.st_uid == uid && st.st_gid == gid)) {
+		rc = 0;
+	    }
 	}
     }
-    if (_fsm_debug)
-	rpmlog(RPMLOG_DEBUG, " %8s (%d %s, %d, %d) %s\n", __func__,
-	       dirfd, path, (int)uid, (int)gid,
+    if (_fsm_debug) {
+	rpmlog(RPMLOG_DEBUG, " %8s (%d - %d %s, %d, %d) %s\n", __func__,
+	       fd, dirfd, path, (int)uid, (int)gid,
 	       (rc < 0 ? strerror(errno) : ""));
+    }
     if (rc < 0)	rc = RPMERR_CHOWN_FAILED;
     return rc;
 }
 
-static int fsmChmod(int dirfd, const char *path, mode_t mode)
+static int fsmChmod(int fd, int dirfd, const char *path, mode_t mode)
 {
-    int rc = fchmodat(dirfd, path, (mode & 07777), 0);
-    if (rc < 0) {
-	struct stat st;
-	if (fstatat(dirfd, path, &st, AT_SYMLINK_NOFOLLOW) == 0 &&
-		(st.st_mode & 07777) == (mode & 07777)) {
-	    rc = 0;
+    mode_t fmode = (mode & 07777);
+    int rc;
+    if (fd >= 0) {
+	rc = fchmod(fd, fmode);
+	if (rc < 0) {
+	    struct stat st;
+	    if (fstat(fd, &st) == 0 && (st.st_mode & 07777) == fmode) {
+		rc = 0;
+	    }
+	}
+    } else {
+	rc = fchmodat(dirfd, path, fmode, 0);
+	if (rc < 0) {
+	    struct stat st;
+	    if (fstatat(dirfd, path, &st, AT_SYMLINK_NOFOLLOW) == 0 &&
+		    (st.st_mode & 07777) == fmode) {
+		rc = 0;
+	    }
 	}
     }
     if (_fsm_debug)
-	rpmlog(RPMLOG_DEBUG, " %8s (%d %s, 0%04o) %s\n", __func__,
-	       dirfd, path, (unsigned)(mode & 07777),
+	rpmlog(RPMLOG_DEBUG, " %8s (%d - %d %s, 0%04o) %s\n", __func__,
+	       fd, dirfd, path, (unsigned)(mode & 07777),
 	       (rc < 0 ? strerror(errno) : ""));
     if (rc < 0)	rc = RPMERR_CHMOD_FAILED;
     return rc;
 }
 
-static int fsmUtime(int dirfd, const char *path, mode_t mode, time_t mtime)
+static int fsmUtime(int fd, int dirfd, const char *path, mode_t mode, time_t mtime)
 {
     int rc = 0;
     struct timespec stamps[2] = {
@@ -552,11 +591,14 @@ static int fsmUtime(int dirfd, const char *path, mode_t mode, time_t mtime)
 	{ .tv_sec = mtime, .tv_nsec = 0 },
     };
 
-    rc = utimensat(dirfd, path, stamps, AT_SYMLINK_NOFOLLOW);
+    if (fd >= 0)
+	rc = futimens(fd, stamps);
+    else
+	rc = utimensat(dirfd, path, stamps, AT_SYMLINK_NOFOLLOW);
     
     if (_fsm_debug)
-	rpmlog(RPMLOG_DEBUG, " %8s (%d %s, 0x%x) %s\n", __func__,
-	       dirfd, path, (unsigned)mtime, (rc < 0 ? strerror(errno) : ""));
+	rpmlog(RPMLOG_DEBUG, " %8s (%d - %d %s, 0x%x) %s\n", __func__,
+	       fd, dirfd, path, (unsigned)mtime, (rc < 0 ? strerror(errno) : ""));
     if (rc < 0)	rc = RPMERR_UTIME_FAILED;
     /* ...but utime error is not critical for directories */
     if (rc && S_ISDIR(mode))
@@ -661,7 +703,8 @@ static int fsmBackup(int dirfd, rpmfi fi, rpmFileAction action)
     return rc;
 }
 
-static int fsmSetmeta(int dirfd, const char *path, rpmfi fi, rpmPlugins plugins,
+static int fsmSetmeta(int fd, int dirfd, const char *path,
+		      rpmfi fi, rpmPlugins plugins,
 		      rpmFileAction action, const struct stat * st,
 		      int nofcaps)
 {
@@ -669,17 +712,17 @@ static int fsmSetmeta(int dirfd, const char *path, rpmfi fi, rpmPlugins plugins,
     const char *dest = rpmfiFN(fi);
 
     if (!rc && !getuid()) {
-	rc = fsmChown(dirfd, path, st->st_mode, st->st_uid, st->st_gid);
+	rc = fsmChown(fd, dirfd, path, st->st_mode, st->st_uid, st->st_gid);
     }
     if (!rc && !S_ISLNK(st->st_mode)) {
-	rc = fsmChmod(dirfd, path, st->st_mode);
+	rc = fsmChmod(fd, dirfd, path, st->st_mode);
     }
     /* Set file capabilities (if enabled) */
     if (!rc && !nofcaps && S_ISREG(st->st_mode) && !getuid()) {
-	rc = fsmSetFCaps(dirfd, path, rpmfiFCaps(fi));
+	rc = fsmSetFCaps(fd, dirfd, path, rpmfiFCaps(fi));
     }
     if (!rc) {
-	rc = fsmUtime(dirfd, path, st->st_mode, rpmfiFMtime(fi));
+	rc = fsmUtime(fd, dirfd, path, st->st_mode, rpmfiFMtime(fi));
     }
     if (!rc) {
 	rc = rpmpluginsCallFsmFilePrepare(plugins, fi,
@@ -949,7 +992,8 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
 
 setmeta:
 	    if (!rc && fp->setmeta) {
-		rc = fsmSetmeta(di.dirfd, fp->fpath, fi, plugins, fp->action,
+		rc = fsmSetmeta(fd, di.dirfd, fp->fpath,
+				fi, plugins, fp->action,
 				&fp->sb, nofcaps);
 	    }
 

From 9fe4dec03b80c50daeecfb43f02befb9a176e902 Mon Sep 17 00:00:00 2001
From: Panu Matilainen <pmatilai@redhat.com>
Date: Mon, 14 Feb 2022 14:29:33 +0200
Subject: [PATCH 22/32] Set file metadata via fd-based ops for everything but
 symlinks

Regular file ops are fd-based already, for the rest we need to open them
manually. Files with temporary suffix must never be followed, for
directories (and pre-existing FA_TOUCHed files) use the rpm symlink
"root or target owner allowed" rule wrt following.

This mostly fixes CVE-2021-35938, but as we're not yet using dirfd-based
operatiosn for everything there are corner cases left undone. And then
there's the plugin API which needs updating for all this.
---
 lib/fsm.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/lib/fsm.c b/lib/fsm.c
index 913e9de2d7..6f781c64d6 100644
--- a/lib/fsm.c
+++ b/lib/fsm.c
@@ -990,6 +990,14 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
                     rc = RPMERR_UNKNOWN_FILETYPE;
             }
 
+	    if (!rc && fd == -1 && !S_ISLNK(fp->sb.st_mode)) {
+		/* Only follow safe symlinks, and never on temporary files */
+		fd = fsmOpenat(di.dirfd, fp->fpath,
+				fp->suffix ? AT_SYMLINK_NOFOLLOW : 0);
+		if (fd < 0)
+		    rc = RPMERR_OPEN_FAILED;
+	    }
+
 setmeta:
 	    if (!rc && fp->setmeta) {
 		rc = fsmSetmeta(fd, di.dirfd, fp->fpath,

From b79c44bfdb684d4d63daf5f04b82b13c1b7898d8 Mon Sep 17 00:00:00 2001
From: Panu Matilainen <pmatilai@redhat.com>
Date: Mon, 14 Feb 2022 16:52:12 +0200
Subject: [PATCH 23/32] Convert removeSBITS() to dirfd-based operation

---
 lib/fsm.c | 13 +++++++------
 1 file changed, 7 insertions(+), 6 deletions(-)

diff --git a/lib/fsm.c b/lib/fsm.c
index 6f781c64d6..d395a805b1 100644
--- a/lib/fsm.c
+++ b/lib/fsm.c
@@ -441,16 +441,17 @@ static int fsmMknod(int dirfd, const char *path, mode_t mode, dev_t dev)
     return rc;
 }
 
-static void removeSBITS(const char *path)
+static void removeSBITS(int dirfd, const char *path)
 {
     struct stat stb;
-    if (lstat(path, &stb) == 0 && S_ISREG(stb.st_mode)) {
+    int flags = AT_SYMLINK_NOFOLLOW;
+    if (fstatat(dirfd, path, &stb, flags) == 0 && S_ISREG(stb.st_mode)) {
 	if ((stb.st_mode & 06000) != 0) {
-	    (void) chmod(path, stb.st_mode & 0777);
+	    (void) fchmodat(dirfd, path, stb.st_mode & 0777, flags);
 	}
 #if WITH_CAP
 	if (stb.st_mode & (S_IXUSR|S_IXGRP|S_IXOTH)) {
-	    (void) cap_set_file(path, NULL);
+	    (void) cap_set_fileat(dirfd, path, NULL);
 	}
 #endif
     }
@@ -483,7 +484,7 @@ static int fsmSymlink(const char *opath, int dirfd, const char *path)
 static int fsmUnlink(int dirfd, const char *path)
 {
     int rc = 0;
-    removeSBITS(path);
+    removeSBITS(dirfd, path);
     rc = unlinkat(dirfd, path, 0);
     if (_fsm_debug)
 	rpmlog(RPMLOG_DEBUG, " %8s (%d %s) %s\n", __func__,
@@ -495,7 +496,7 @@ static int fsmUnlink(int dirfd, const char *path)
 
 static int fsmRename(int odirfd, const char *opath, int dirfd, const char *path)
 {
-    removeSBITS(path);
+    removeSBITS(dirfd, path);
     int rc = renameat(odirfd, opath, dirfd, path);
 #if defined(ETXTBSY) && defined(__HPUX__)
     /* XXX HP-UX (and other os'es) don't permit rename to busy files. */

From 3c0619e5d8eb866bad65901855a250b8957b6425 Mon Sep 17 00:00:00 2001
From: Panu Matilainen <pmatilai@redhat.com>
Date: Tue, 15 Feb 2022 09:12:53 +0200
Subject: [PATCH 24/32] Parent directory needs to be open before we can back up
 stuff

A thinko originating from commit c9b2686a4748c227b0abdc0752d844e35296474e
which doesn't matter greatly as long as we're still using absolute
paths but will fail as soon as dirfd+basename is used.

Also pay more attention to the rc's: we must not backup, or run file
pre plugin hook if we know it'll fail.
---
 lib/fsm.c | 15 +++++++--------
 1 file changed, 7 insertions(+), 8 deletions(-)

diff --git a/lib/fsm.c b/lib/fsm.c
index d395a805b1..e2ede523ba 100644
--- a/lib/fsm.c
+++ b/lib/fsm.c
@@ -917,19 +917,18 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
 
         if (!fp->skip) {
 	    int fd = -1;
+	    rc = ensureDir(plugins, rpmfiDN(fi), 0,
+			    (fp->action == FA_CREATE), 0, &di.dirfd);
+
 	    /* Directories replacing something need early backup */
-	    if (!fp->suffix && fp != firstlink) {
+	    if (!rc && !fp->suffix && fp != firstlink) {
 		rc = fsmBackup(di.dirfd, fi, fp->action);
 	    }
 
-	    if (!rc) {
-		rc = ensureDir(plugins, rpmfiDN(fi), 0,
-				(fp->action == FA_CREATE), 0, &di.dirfd);
-	    }
-
 	    /* Run fsm file pre hook for all plugins */
-	    rc = rpmpluginsCallFsmFilePre(plugins, fi, fp->fpath,
-					  fp->sb.st_mode, fp->action);
+	    if (!rc)
+		rc = rpmpluginsCallFsmFilePre(plugins, fi, fp->fpath,
+					      fp->sb.st_mode, fp->action);
 	    if (rc)
 		goto setmeta; /* for error notification */
 

From bd08748f10f613d08b9ab2ab59e46654f36c0c55 Mon Sep 17 00:00:00 2001
From: Panu Matilainen <pmatilai@redhat.com>
Date: Tue, 15 Feb 2022 09:28:55 +0200
Subject: [PATCH 25/32] Add fsm debug logging to ensureDir()

This being one of the more central functions in fsm now, there better
be some diagnostics from it too. Especially when we move to
dirfd+basename operation.
---
 lib/fsm.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/lib/fsm.c b/lib/fsm.c
index e2ede523ba..63595e2e8d 100644
--- a/lib/fsm.c
+++ b/lib/fsm.c
@@ -404,6 +404,11 @@ static int ensureDir(rpmPlugins plugins, const char *p, int owned, int create,
     }
     *dirfdp = dirfd;
 
+    if (_fsm_debug) {
+	rpmlog(RPMLOG_DEBUG, " %8s (%s: %d) %s\n", __func__,
+		p, dirfd, (rc < 0 ? strerror(errno) : ""));
+    }
+
     free(path);
     return rc;
 }

From ce051d7b95a61b98e6881976e7ac7e36139f25cf Mon Sep 17 00:00:00 2001
From: Panu Matilainen <pmatilai@redhat.com>
Date: Tue, 15 Feb 2022 10:02:45 +0200
Subject: [PATCH 26/32] Add O_DIRECTORY equivalent parameter to fsmOpenat(),
 use as relevant

---
 lib/fsm.c | 27 ++++++++++++++-------------
 1 file changed, 14 insertions(+), 13 deletions(-)

diff --git a/lib/fsm.c b/lib/fsm.c
index 63595e2e8d..28a970ad1c 100644
--- a/lib/fsm.c
+++ b/lib/fsm.c
@@ -65,7 +65,7 @@ struct filedata_s {
  * things around needlessly 
  */ 
 static const char * fileActionString(rpmFileAction a);
-static int fsmOpenat(int dirfd, const char *path, int flags);
+static int fsmOpenat(int dirfd, const char *path, int flags, int dir);
 
 /** \ingroup payload
  * Build path to file from file info, optionally ornamented with suffix.
@@ -95,7 +95,7 @@ static int fsmLink(int odirfd, const char *opath, int dirfd, const char *path)
 static int cap_set_fileat(int dirfd, const char *path, cap_t fcaps)
 {
     int rc = -1;
-    int fd = fsmOpenat(dirfd, path, O_RDONLY|O_NOFOLLOW);
+    int fd = fsmOpenat(dirfd, path, O_RDONLY|O_NOFOLLOW, 0);
     if (fd >= 0) {
 	rc = cap_set_fd(fd, fcaps);
 	close(fd);
@@ -292,7 +292,7 @@ static int fsmMkdir(int dirfd, const char *path, mode_t mode)
     return rc;
 }
 
-static int fsmOpenat(int dirfd, const char *path, int flags)
+static int fsmOpenat(int dirfd, const char *path, int flags, int dir)
 {
     struct stat lsb, sb;
     int sflags = flags | O_NOFOLLOW;
@@ -316,6 +316,13 @@ static int fsmOpenat(int dirfd, const char *path, int flags)
 	    }
 	}
     }
+
+    /* O_DIRECTORY equivalent */
+    if (dir && fd >= 0 && fstat(fd, &sb) == 0 && !S_ISDIR(sb.st_mode)) {
+	errno = ENOTDIR;
+	close(fd);
+	fd = -1;
+    }
     return fd;
 }
 
@@ -361,23 +368,17 @@ static int ensureDir(rpmPlugins plugins, const char *p, int owned, int create,
     if (*dirfdp >= 0)
 	return rc;
 
-    int dirfd = fsmOpenat(-1, "/", oflags);
+    int dirfd = fsmOpenat(-1, "/", oflags, 1);
     int fd = dirfd; /* special case of "/" */
 
     while ((bn = strtok_r(dp, "/", &sp)) != NULL) {
-	struct stat sb;
-	fd = fsmOpenat(dirfd, bn, oflags);
+	fd = fsmOpenat(dirfd, bn, oflags, 1);
 
 	if (fd < 0 && errno == ENOENT && create) {
 	    mode_t mode = S_IFDIR | (_dirPerms & 07777);
 	    rc = fsmDoMkDir(plugins, dirfd, bn, owned, mode);
 	    if (!rc)
-		fd = fsmOpenat(dirfd, bn, oflags|O_NOFOLLOW);
-	}
-
-	if (fd >= 0 && fstat(fd, &sb) == 0 && !S_ISDIR(sb.st_mode)) {
-	    rc = RPMERR_ENOTDIR;
-	    break;
+		fd = fsmOpenat(dirfd, bn, oflags|O_NOFOLLOW, 1);
 	}
 
 	close(dirfd);
@@ -998,7 +999,7 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
 	    if (!rc && fd == -1 && !S_ISLNK(fp->sb.st_mode)) {
 		/* Only follow safe symlinks, and never on temporary files */
 		fd = fsmOpenat(di.dirfd, fp->fpath,
-				fp->suffix ? AT_SYMLINK_NOFOLLOW : 0);
+				fp->suffix ? AT_SYMLINK_NOFOLLOW : 0, 0);
 		if (fd < 0)
 		    rc = RPMERR_OPEN_FAILED;
 	    }

From 2944f5957e786170f8efe2f6fe3706fc7cad18bc Mon Sep 17 00:00:00 2001
From: Panu Matilainen <pmatilai@redhat.com>
Date: Tue, 15 Feb 2022 10:08:53 +0200
Subject: [PATCH 27/32] Return a validated open directory fd from fsmDoMkDir()

---
 lib/fsm.c | 12 ++++++++----
 1 file changed, 8 insertions(+), 4 deletions(-)

diff --git a/lib/fsm.c b/lib/fsm.c
index 28a970ad1c..a26ee3e6a5 100644
--- a/lib/fsm.c
+++ b/lib/fsm.c
@@ -327,7 +327,7 @@ static int fsmOpenat(int dirfd, const char *path, int flags, int dir)
 }
 
 static int fsmDoMkDir(rpmPlugins plugins, int dirfd, const char *dn,
-			int owned, mode_t mode)
+			int owned, mode_t mode, int *fdp)
 {
     int rc;
     rpmFsmOp op = (FA_CREATE);
@@ -340,6 +340,12 @@ static int fsmDoMkDir(rpmPlugins plugins, int dirfd, const char *dn,
     if (!rc)
 	rc = fsmMkdir(dirfd, dn, mode);
 
+    if (!rc) {
+	*fdp = fsmOpenat(dirfd, dn, O_RDONLY|O_NOFOLLOW, 1);
+	if (*fdp == -1)
+	    rc = RPMERR_ENOTDIR;
+    }
+
     if (!rc) {
 	rc = rpmpluginsCallFsmFilePrepare(plugins, NULL, dn, dn, mode, op);
     }
@@ -376,9 +382,7 @@ static int ensureDir(rpmPlugins plugins, const char *p, int owned, int create,
 
 	if (fd < 0 && errno == ENOENT && create) {
 	    mode_t mode = S_IFDIR | (_dirPerms & 07777);
-	    rc = fsmDoMkDir(plugins, dirfd, bn, owned, mode);
-	    if (!rc)
-		fd = fsmOpenat(dirfd, bn, oflags|O_NOFOLLOW, 1);
+	    rc = fsmDoMkDir(plugins, dirfd, bn, owned, mode, &fd);
 	}
 
 	close(dirfd);

From 8eb60d6e739749b574eb922662e30e6572e72e58 Mon Sep 17 00:00:00 2001
From: Panu Matilainen <pmatilai@redhat.com>
Date: Tue, 15 Feb 2022 10:43:13 +0200
Subject: [PATCH 28/32] Pass file descriptor to file prepare plugin hook, use
 when possible

Sadly the thing that allegedly makes things better mostly just makes
things more complicated as symlinks can't be opened, so we'll now have
to deal with both cases in plugins too. To make matters worse, most
APIs out there support either an fd or a path, but very few support
the *at() style dirfd + basename approach so plugins are stuck with
absolute paths for now.

This is of course a plugin API/ABI change too.
---
 lib/fsm.c           |  4 ++--
 lib/rpmplugin.h     |  2 +-
 lib/rpmplugins.c    |  4 ++--
 lib/rpmplugins.h    |  3 ++-
 plugins/fapolicyd.c |  3 ++-
 plugins/fsverity.c  | 10 +---------
 plugins/ima.c       |  9 +++++++--
 plugins/selinux.c   | 12 ++++++++----
 8 files changed, 25 insertions(+), 22 deletions(-)

diff --git a/lib/fsm.c b/lib/fsm.c
index a26ee3e6a5..c9f842f1eb 100644
--- a/lib/fsm.c
+++ b/lib/fsm.c
@@ -347,7 +347,7 @@ static int fsmDoMkDir(rpmPlugins plugins, int dirfd, const char *dn,
     }
 
     if (!rc) {
-	rc = rpmpluginsCallFsmFilePrepare(plugins, NULL, dn, dn, mode, op);
+	rc = rpmpluginsCallFsmFilePrepare(plugins, NULL, *fdp, dn, dn, mode, op);
     }
 
     /* Run fsm file post hook for all plugins */
@@ -737,7 +737,7 @@ static int fsmSetmeta(int fd, int dirfd, const char *path,
     }
     if (!rc) {
 	rc = rpmpluginsCallFsmFilePrepare(plugins, fi,
-					  path, dest,
+					  fd, path, dest,
 					  st->st_mode, action);
     }
 
diff --git a/lib/rpmplugin.h b/lib/rpmplugin.h
index fd81aec8d8..fab4b3e83c 100644
--- a/lib/rpmplugin.h
+++ b/lib/rpmplugin.h
@@ -57,7 +57,7 @@ typedef rpmRC (*plugin_fsm_file_post_func)(rpmPlugin plugin, rpmfi fi,
 					   const char* path, mode_t file_mode,
 					   rpmFsmOp op, int res);
 typedef rpmRC (*plugin_fsm_file_prepare_func)(rpmPlugin plugin, rpmfi fi,
-					      const char* path,
+					      int fd, const char* path,
 					      const char *dest,
 					      mode_t file_mode, rpmFsmOp op);
 
diff --git a/lib/rpmplugins.c b/lib/rpmplugins.c
index 62d75c4cf0..703368c0d7 100644
--- a/lib/rpmplugins.c
+++ b/lib/rpmplugins.c
@@ -388,7 +388,7 @@ rpmRC rpmpluginsCallFsmFilePost(rpmPlugins plugins, rpmfi fi, const char *path,
 }
 
 rpmRC rpmpluginsCallFsmFilePrepare(rpmPlugins plugins, rpmfi fi,
-				   const char *path, const char *dest,
+				   int fd, const char *path, const char *dest,
 				   mode_t file_mode, rpmFsmOp op)
 {
     plugin_fsm_file_prepare_func hookFunc;
@@ -398,7 +398,7 @@ rpmRC rpmpluginsCallFsmFilePrepare(rpmPlugins plugins, rpmfi fi,
     for (i = 0; i < plugins->count; i++) {
 	rpmPlugin plugin = plugins->plugins[i];
 	RPMPLUGINS_SET_HOOK_FUNC(fsm_file_prepare);
-	if (hookFunc && hookFunc(plugin, fi, path, dest, file_mode, op) == RPMRC_FAIL) {
+	if (hookFunc && hookFunc(plugin, fi, fd, path, dest, file_mode, op) == RPMRC_FAIL) {
 	    rpmlog(RPMLOG_ERR, "Plugin %s: hook fsm_file_prepare failed\n", plugin->name);
 	    rc = RPMRC_FAIL;
 	}
diff --git a/lib/rpmplugins.h b/lib/rpmplugins.h
index 39762c3768..ddf5d70488 100644
--- a/lib/rpmplugins.h
+++ b/lib/rpmplugins.h
@@ -156,6 +156,7 @@ rpmRC rpmpluginsCallFsmFilePost(rpmPlugins plugins, rpmfi fi, const char* path,
  * permissions etc, but before committing file to destination path.
  * @param plugins	plugins structure
  * @param fi		file info iterator (or NULL)
+ * @param fd		file descriptor (or -1 if not available)
  * @param path		file object current path
  * @param dest		file object destination path
  * @param mode		file object mode
@@ -164,7 +165,7 @@ rpmRC rpmpluginsCallFsmFilePost(rpmPlugins plugins, rpmfi fi, const char* path,
  */
 RPM_GNUC_INTERNAL
 rpmRC rpmpluginsCallFsmFilePrepare(rpmPlugins plugins, rpmfi fi,
-                                   const char *path, const char *dest,
+                                   int fd, const char *path, const char *dest,
                                    mode_t mode, rpmFsmOp op);
 
 #ifdef __cplusplus
diff --git a/plugins/fapolicyd.c b/plugins/fapolicyd.c
index 7ac44f0d0e..1ff50c30f6 100644
--- a/plugins/fapolicyd.c
+++ b/plugins/fapolicyd.c
@@ -145,7 +145,8 @@ static rpmRC fapolicyd_scriptlet_pre(rpmPlugin plugin, const char *s_name,
 }
 
 static rpmRC fapolicyd_fsm_file_prepare(rpmPlugin plugin, rpmfi fi,
-                                        const char *path, const char *dest,
+                                        int fd, const char *path,
+					const char *dest,
                                         mode_t file_mode, rpmFsmOp op)
 {
     /* not ready  */
diff --git a/plugins/fsverity.c b/plugins/fsverity.c
index 40b66919e3..b13a7db063 100644
--- a/plugins/fsverity.c
+++ b/plugins/fsverity.c
@@ -33,7 +33,7 @@ static int sign_config_files = 0;
  * but fails gracefully if the file system doesn't support it or the
  * verity feature flag isn't enabled in the file system (ext4).
  */
-static rpmRC fsverity_fsm_file_prepare(rpmPlugin plugin, rpmfi fi,
+static rpmRC fsverity_fsm_file_prepare(rpmPlugin plugin, rpmfi fi, int fd,
 				       const char *path, const char *dest,
 				       mode_t file_mode, rpmFsmOp op)
 {
@@ -42,7 +42,6 @@ static rpmRC fsverity_fsm_file_prepare(rpmPlugin plugin, rpmfi fi,
     size_t len;
     uint16_t algo = 0;
     int rc = RPMRC_OK;
-    int fd;
     rpmFileAction action = XFO_ACTION(op);
     char *buffer;
 
@@ -98,12 +97,6 @@ static rpmRC fsverity_fsm_file_prepare(rpmPlugin plugin, rpmfi fi,
     rpmlog(RPMLOG_DEBUG, "applying signature: %s\n", buffer);
     free(buffer);
 
-    fd = open(path, O_RDONLY);
-    if (fd < 0) {
-	rpmlog(RPMLOG_ERR, "failed to open path %s\n", path);
-	goto exit;
-    }
-
     /*
      * Enable fsverity on the file.
      * fsverity not supported by file system (ENOTTY) and fsverity not
@@ -162,7 +155,6 @@ static rpmRC fsverity_fsm_file_prepare(rpmPlugin plugin, rpmfi fi,
 
     rpmlog(RPMLOG_DEBUG, "fsverity enabled signature for: path %s dest %s\n",
 	   path, dest);
-    close(fd);
 exit:
     return rc;
 }
diff --git a/plugins/ima.c b/plugins/ima.c
index a30ccb4a6a..0432528d0e 100644
--- a/plugins/ima.c
+++ b/plugins/ima.c
@@ -42,7 +42,7 @@ static int check_zero_hdr(const unsigned char *fsig, size_t siglen)
 	return (memcmp(fsig, &zero_hdr, sizeof(zero_hdr)) == 0);
 }
 
-static rpmRC ima_fsm_file_prepare(rpmPlugin plugin, rpmfi fi,
+static rpmRC ima_fsm_file_prepare(rpmPlugin plugin, rpmfi fi, int fd,
                                   const char *path,
                                   const char *dest,
                                   mode_t file_mode, rpmFsmOp op)
@@ -68,7 +68,12 @@ static rpmRC ima_fsm_file_prepare(rpmPlugin plugin, rpmfi fi,
 
 	fsig = rpmfiFSignature(fi, &len);
 	if (fsig && (check_zero_hdr(fsig, len) == 0)) {
-	    if (lsetxattr(path, XATTR_NAME_IMA, fsig, len, 0) < 0) {
+	    int xx;
+	    if (fd >= 0)
+		xx = fsetxattr(fd, XATTR_NAME_IMA, fsig, len, 0);
+	    else
+		xx = lsetxattr(path, XATTR_NAME_IMA, fsig, len, 0);
+	    if (xx < 0) {
 	        rpmlog(RPMLOG_ERR,
 			"ima: could not apply signature on '%s': %s\n",
 			path, strerror(errno));
diff --git a/plugins/selinux.c b/plugins/selinux.c
index d10f98ffda..316ff88ea8 100644
--- a/plugins/selinux.c
+++ b/plugins/selinux.c
@@ -155,7 +155,7 @@ static rpmRC selinux_scriptlet_fork_post(rpmPlugin plugin,
     return rc;
 }
 
-static rpmRC selinux_fsm_file_prepare(rpmPlugin plugin, rpmfi fi,
+static rpmRC selinux_fsm_file_prepare(rpmPlugin plugin, rpmfi fi, int fd,
 					const char *path, const char *dest,
 				        mode_t file_mode, rpmFsmOp op)
 {
@@ -165,13 +165,17 @@ static rpmRC selinux_fsm_file_prepare(rpmPlugin plugin, rpmfi fi,
     if (sehandle && !XFA_SKIPPING(action)) {
 	char *scon = NULL;
 	if (selabel_lookup_raw(sehandle, &scon, dest, file_mode) == 0) {
-	    int conrc = lsetfilecon(path, scon);
+	    int conrc;
+	    if (fd >= 0)
+		conrc = fsetfilecon(fd, scon);
+	    else
+		conrc = lsetfilecon(path, scon);
 
 	    if (conrc == 0 || (conrc < 0 && errno == EOPNOTSUPP))
 		rc = RPMRC_OK;
 
-	    rpmlog(loglvl(rc != RPMRC_OK), "lsetfilecon: (%s, %s) %s\n",
-		       path, scon, (conrc < 0 ? strerror(errno) : ""));
+	    rpmlog(loglvl(rc != RPMRC_OK), "lsetfilecon: (%d %s, %s) %s\n",
+		       fd, path, scon, (conrc < 0 ? strerror(errno) : ""));
 
 	    freecon(scon);
 	} else {

From f277edabd3b8b3dbb007e5b250d871c4fa999cb4 Mon Sep 17 00:00:00 2001
From: Panu Matilainen <pmatilai@redhat.com>
Date: Tue, 15 Feb 2022 11:57:20 +0200
Subject: [PATCH 29/32] Track first hardlink directory descriptor as well

Cross-directory hardlinks shouldn't be used as there's no guarantee
two directories are on the same filesystem, but these exist in the
wild so we need to care.
---
 lib/fsm.c | 27 +++++++++++++++++++--------
 1 file changed, 19 insertions(+), 8 deletions(-)

diff --git a/lib/fsm.c b/lib/fsm.c
index c9f842f1eb..4b9ec8b0b0 100644
--- a/lib/fsm.c
+++ b/lib/fsm.c
@@ -192,7 +192,7 @@ static int fsmUnpack(rpmfi fi, int fdno, rpmpsm psm, int nodigest)
 static int fsmMkfile(int dirfd, rpmfi fi, struct filedata_s *fp, rpmfiles files,
 		     rpmpsm psm, int nodigest,
 		     struct filedata_s ** firstlink, int *firstlinkfile,
-		     int *fdp)
+		     int *firstdir, int *fdp)
 {
     int rc = 0;
     int fd = -1;
@@ -204,11 +204,12 @@ static int fsmMkfile(int dirfd, rpmfi fi, struct filedata_s *fp, rpmfiles files,
 	if (fp->sb.st_nlink > 1) {
 	    *firstlink = fp;
 	    *firstlinkfile = fd;
+	    *firstdir = dirfd;
 	}
     } else {
 	/* Create hard links for others and avoid redundant metadata setting */
 	if (*firstlink != fp) {
-	    rc = fsmLink(dirfd, (*firstlink)->fpath, dirfd, fp->fpath);
+	    rc = fsmLink(*firstdir, (*firstlink)->fpath, dirfd, fp->fpath);
 	}
 	fd = *firstlinkfile;
     }
@@ -222,6 +223,7 @@ static int fsmMkfile(int dirfd, rpmfi fi, struct filedata_s *fp, rpmfiles files,
 	    fp->setmeta = 1;
 	    *firstlink = NULL;
 	    *firstlinkfile = -1;
+	    *firstdir = -1;
 	}
     }
     *fdp = fd;
@@ -821,6 +823,7 @@ static void setFileState(rpmfs fs, int i)
 
 struct diriter_s {
     int dirfd;
+    int firstdir;
 };
 
 static int onChdir(rpmfi fi, void *data)
@@ -828,7 +831,8 @@ static int onChdir(rpmfi fi, void *data)
     struct diriter_s *di = data;
 
     if (di->dirfd >= 0) {
-	close(di->dirfd);
+	if (di->dirfd != di->firstdir)
+	    close(di->dirfd);
 	di->dirfd = -1;
     }
     return 0;
@@ -848,8 +852,14 @@ static rpmfi fsmIter(FD_t payload, rpmfiles files, rpmFileIter iter, void *data)
 
 static rpmfi fsmIterFini(rpmfi fi, struct diriter_s *di)
 {
-    close(di->dirfd);
-    di->dirfd = -1;
+    if (di->dirfd >= 0) {
+	close(di->dirfd);
+	di->dirfd = -1;
+    }
+    if (di->firstdir >= 0) {
+	close(di->firstdir);
+	di->firstdir = -1;
+    }
     return rpmfiFree(fi);
 }
 
@@ -869,7 +879,7 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
     char *tid = NULL;
     struct filedata_s *fdata = xcalloc(fc, sizeof(*fdata));
     struct filedata_s *firstlink = NULL;
-    struct diriter_s di = { -1 };
+    struct diriter_s di = { -1, -1 };
 
     /* transaction id used for temporary path suffix while installing */
     rasprintf(&tid, ";%08x", (unsigned)rpmtsGetTid(ts));
@@ -969,7 +979,8 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
             if (S_ISREG(fp->sb.st_mode)) {
 		if (rc == RPMERR_ENOENT) {
 		    rc = fsmMkfile(di.dirfd, fi, fp, files, psm, nodigest,
-				   &firstlink, &firstlinkfile, &fd);
+				   &firstlink, &firstlinkfile, &di.firstdir,
+				   &fd);
 		}
             } else if (S_ISDIR(fp->sb.st_mode)) {
                 if (rc == RPMERR_ENOENT) {
@@ -1093,7 +1104,7 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
 int rpmPackageFilesRemove(rpmts ts, rpmte te, rpmfiles files,
               rpmpsm psm, char ** failedFile)
 {
-    struct diriter_s di = { -1 };
+    struct diriter_s di = { -1, -1 };
     rpmfi fi = fsmIter(NULL, files, RPMFI_ITER_BACK, &di);
     rpmfs fs = rpmteGetFileStates(te);
     rpmPlugins plugins = rpmtsPlugins(ts);

From ea87a93685dfbe682dcc6c9d44f2150e238787a0 Mon Sep 17 00:00:00 2001
From: Panu Matilainen <pmatilai@redhat.com>
Date: Tue, 15 Feb 2022 13:15:03 +0200
Subject: [PATCH 30/32] Add a test-case for "filesystem" like package owning /

This is a special case in various places around rpm, worth having a test
for.
---
 tests/Makefile.am        |  1 +
 tests/data/SPECS/fs.spec | 15 +++++++++++++++
 tests/rpmi.at            | 16 ++++++++++++++++
 3 files changed, 32 insertions(+)
 create mode 100644 tests/data/SPECS/fs.spec

diff --git a/tests/Makefile.am b/tests/Makefile.am
index b97d959037..ec04abf443 100644
--- a/tests/Makefile.am
+++ b/tests/Makefile.am
@@ -43,6 +43,7 @@ EXTRA_DIST += data/SPECS/attrtest.spec
 EXTRA_DIST += data/SPECS/bcondtest.spec
 EXTRA_DIST += data/SPECS/buildrequires.spec
 EXTRA_DIST += data/SPECS/docmiss.spec
+EXTRA_DIST += data/SPECS/fs.spec
 EXTRA_DIST += data/SPECS/hello.spec
 EXTRA_DIST += data/SPECS/hello-auto.spec
 EXTRA_DIST += data/SPECS/hello-autopatch.spec
diff --git a/tests/data/SPECS/fs.spec b/tests/data/SPECS/fs.spec
new file mode 100644
index 0000000000..6d202e34f8
--- /dev/null
+++ b/tests/data/SPECS/fs.spec
@@ -0,0 +1,15 @@
+Name: fs
+Version: 1.0
+Release: 1
+Summary: filesystem
+License: GPL
+BuildArch: noarch
+
+%description
+%{summary}
+
+%install
+mkdir -p %{buildroot}/{bin,lib,opt,etc,tmp,var}
+
+%files
+/
diff --git a/tests/rpmi.at b/tests/rpmi.at
index 7fc88d4287..016559e551 100644
--- a/tests/rpmi.at
+++ b/tests/rpmi.at
@@ -1004,3 +1004,19 @@ runroot rpm -e hlinktest
 ],
 [])
 AT_CLEANUP
+
+AT_SETUP([rpm -U filesystem])
+AT_KEYWORDS([install])
+AT_CHECK([
+RPMDB_INIT
+
+runroot rpmbuild -bb --quiet /data/SPECS/fs.spec
+runroot rpm -U --ignoreos /build/RPMS/noarch/fs-1.0-1.noarch.rpm
+runroot rpm -Va --nouser --nogroup
+runroot rpm -q --whatprovides /
+],
+[0],
+[fs-1.0-1.noarch
+],
+[])
+AT_CLEANUP

From a3118df1da902507a5e662ac64119cd22c0be065 Mon Sep 17 00:00:00 2001
From: Panu Matilainen <pmatilai@redhat.com>
Date: Tue, 15 Feb 2022 13:29:00 +0200
Subject: [PATCH 31/32] Add a test-case for cross-directory hardlinks

---
 tests/data/SPECS/hlinktest.spec | 10 ++++++++++
 tests/rpmi.at                   | 20 ++++++++++++++++++++
 2 files changed, 30 insertions(+)

diff --git a/tests/data/SPECS/hlinktest.spec b/tests/data/SPECS/hlinktest.spec
index 1f453524e8..c6bcc84a8d 100644
--- a/tests/data/SPECS/hlinktest.spec
+++ b/tests/data/SPECS/hlinktest.spec
@@ -1,6 +1,7 @@
 %bcond_with unpackaged_dirs
 %bcond_with unpackaged_files
 %bcond_with owned_dir
+%bcond_with crossdir_links
 
 Summary:          Testing hard link behavior
 Name:             hlinktest
@@ -29,6 +30,12 @@ for f in foo bar world; do
     ln hello hello-${f}
 done
 
+%if %{with crossdir_links}
+mkdir -p $RPM_BUILD_ROOT/xmark
+ln $RPM_BUILD_ROOT/foo/aaaa $RPM_BUILD_ROOT/xmark/
+ln $RPM_BUILD_ROOT/foo/hello $RPM_BUILD_ROOT/xmark/
+%endif
+
 %if %{with unpackaged_dirs}
 mkdir -p $RPM_BUILD_ROOT/zoo/
 %endif
@@ -42,4 +49,7 @@ touch $RPM_BUILD_ROOT/toot
 %if %{with owned_dir}
 %dir /foo
 %endif
+%if %{with crossdir_links}
+/xmark
+%endif
 /foo/*
diff --git a/tests/rpmi.at b/tests/rpmi.at
index 016559e551..13a387afba 100644
--- a/tests/rpmi.at
+++ b/tests/rpmi.at
@@ -1003,6 +1003,26 @@ runroot rpm -e hlinktest
 .........    /foo/zzzz
 ],
 [])
+
+AT_CHECK([
+RPMDB_INIT
+runroot rpmbuild -bb --quiet --with crossdir_links /data/SPECS/hlinktest.spec
+runroot rpm -U /build/RPMS/noarch/hlinktest-1.0-1.noarch.rpm
+runroot rpm -Vav --nouser --nogroup
+],
+[0],
+[.........    /foo/aaaa
+.........    /foo/copyllo
+.........    /foo/hello
+.........    /foo/hello-bar
+.........    /foo/hello-foo
+.........    /foo/hello-world
+.........    /foo/zzzz
+.........    /xmark
+.........    /xmark/aaaa
+.........    /xmark/hello
+],
+[])
 AT_CLEANUP
 
 AT_SETUP([rpm -U filesystem])

From 228b6f17bf8a9d06ca9c72eabb7e537ad64d05f3 Mon Sep 17 00:00:00 2001
From: Panu Matilainen <pmatilai@redhat.com>
Date: Tue, 15 Feb 2022 11:34:37 +0200
Subject: [PATCH 32/32] Swap over to dirfd+basename based operation within the
 fsm

Within fsm this is just a matter of adjusting error messages to include
the directory... if it only wasn't for the plugins requiring absolute
paths for outside users. For the plugins, we need to assemble absolute
paths as needed, both in ensureDir() and plugin file slots.
---
 lib/fsm.c        | 30 +++++++++++++++++++-----------
 lib/rpmplugins.c | 20 +++++++++++++++++---
 2 files changed, 36 insertions(+), 14 deletions(-)

diff --git a/lib/fsm.c b/lib/fsm.c
index 4b9ec8b0b0..07c3a36d84 100644
--- a/lib/fsm.c
+++ b/lib/fsm.c
@@ -69,13 +69,15 @@ static int fsmOpenat(int dirfd, const char *path, int flags, int dir);
 
 /** \ingroup payload
  * Build path to file from file info, optionally ornamented with suffix.
+ * "/" needs special handling to avoid appearing as empty path.
  * @param fi		file info iterator
  * @param suffix	suffix to use (NULL disables)
  * @param[out]		path to file (malloced)
  */
 static char * fsmFsPath(rpmfi fi, const char * suffix)
 {
-    return rstrscat(NULL, rpmfiDN(fi), rpmfiBN(fi), suffix ? suffix : "", NULL);
+    const char *bn = rpmfiBN(fi);
+    return rstrscat(NULL, *bn ? bn : "/", suffix ? suffix : "", NULL);
 }
 
 static int fsmLink(int odirfd, const char *opath, int dirfd, const char *path)
@@ -329,6 +331,7 @@ static int fsmOpenat(int dirfd, const char *path, int flags, int dir)
 }
 
 static int fsmDoMkDir(rpmPlugins plugins, int dirfd, const char *dn,
+			const char *apath,
 			int owned, mode_t mode, int *fdp)
 {
     int rc;
@@ -337,7 +340,7 @@ static int fsmDoMkDir(rpmPlugins plugins, int dirfd, const char *dn,
 	op |= FAF_UNOWNED;
 
     /* Run fsm file pre hook for all plugins */
-    rc = rpmpluginsCallFsmFilePre(plugins, NULL, dn, mode, op);
+    rc = rpmpluginsCallFsmFilePre(plugins, NULL, apath, mode, op);
 
     if (!rc)
 	rc = fsmMkdir(dirfd, dn, mode);
@@ -349,7 +352,7 @@ static int fsmDoMkDir(rpmPlugins plugins, int dirfd, const char *dn,
     }
 
     if (!rc) {
-	rc = rpmpluginsCallFsmFilePrepare(plugins, NULL, *fdp, dn, dn, mode, op);
+	rc = rpmpluginsCallFsmFilePrepare(plugins, NULL, *fdp, apath, apath, mode, op);
     }
 
     /* Run fsm file post hook for all plugins */
@@ -358,7 +361,7 @@ static int fsmDoMkDir(rpmPlugins plugins, int dirfd, const char *dn,
     if (!rc) {
 	rpmlog(RPMLOG_DEBUG,
 		"%s directory created with perms %04o\n",
-		dn, (unsigned)(mode & 07777));
+		apath, (unsigned)(mode & 07777));
     }
 
     return rc;
@@ -370,6 +373,7 @@ static int ensureDir(rpmPlugins plugins, const char *p, int owned, int create,
     char *path = xstrdup(p);
     char *dp = path;
     char *sp = NULL, *bn;
+    char *apath = NULL;
     int oflags = O_RDONLY;
     int rc = 0;
 
@@ -381,10 +385,12 @@ static int ensureDir(rpmPlugins plugins, const char *p, int owned, int create,
 
     while ((bn = strtok_r(dp, "/", &sp)) != NULL) {
 	fd = fsmOpenat(dirfd, bn, oflags, 1);
+	/* assemble absolute path for plugins benefit, sigh */
+	apath = rstrscat(&apath, "/", bn, NULL);
 
 	if (fd < 0 && errno == ENOENT && create) {
 	    mode_t mode = S_IFDIR | (_dirPerms & 07777);
-	    rc = fsmDoMkDir(plugins, dirfd, bn, owned, mode, &fd);
+	    rc = fsmDoMkDir(plugins, dirfd, bn, apath, owned, mode, &fd);
 	}
 
 	close(dirfd);
@@ -417,6 +423,7 @@ static int ensureDir(rpmPlugins plugins, const char *p, int owned, int create,
     }
 
     free(path);
+    free(apath);
     return rc;
 }
 
@@ -708,7 +715,8 @@ static int fsmBackup(int dirfd, rpmfi fi, rpmFileAction action)
 	char * path = fsmFsPath(fi, suffix);
 	rc = fsmRename(dirfd, opath, dirfd, path);
 	if (!rc) {
-	    rpmlog(RPMLOG_WARNING, _("%s saved as %s\n"), opath, path);
+	    rpmlog(RPMLOG_WARNING, _("%s%s saved as %s%s\n"),
+		   rpmfiDN(fi), opath, rpmfiDN(fi), path);
 	}
 	free(path);
 	free(opath);
@@ -764,8 +772,8 @@ static int fsmCommit(int dirfd, char **path, rpmfi fi, rpmFileAction action, con
 	    if (!rc) {
 		if (nsuffix) {
 		    char * opath = fsmFsPath(fi, NULL);
-		    rpmlog(RPMLOG_WARNING, _("%s created as %s\n"),
-			   opath, dest);
+		    rpmlog(RPMLOG_WARNING, _("%s%s created as %s%s\n"),
+			   rpmfiDN(fi), opath, rpmfiDN(fi), dest);
 		    free(opath);
 		}
 		free(*path);
@@ -1032,7 +1040,7 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
 
 	/* Notify on success. */
 	if (rc)
-	    *failedFile = xstrdup(fp->fpath);
+	    *failedFile = rstrscat(NULL, rpmfiDN(fi), fp->fpath, NULL);
 	else
 	    rpmpsmNotify(psm, RPMCALLBACK_INST_PROGRESS, rpmfiArchiveTell(fi));
 	fp->stage = FILE_UNPACK;
@@ -1061,7 +1069,7 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
 	    if (!rc)
 		fp->stage = FILE_COMMIT;
 	    else
-		*failedFile = xstrdup(fp->fpath);
+		*failedFile = rstrscat(NULL, rpmfiDN(fi), fp->fpath, NULL);
 
 	    /* Run fsm file post hook for all plugins for all processed files */
 	    rpmpluginsCallFsmFilePost(plugins, fi, fp->fpath,
@@ -1177,7 +1185,7 @@ int rpmPackageFilesRemove(rpmts ts, rpmte te, rpmfiles files,
         if (!strict_erasures) rc = 0;
 
 	if (rc)
-	    *failedFile = xstrdup(fp->fpath);
+	    *failedFile = rstrscat(NULL, rpmfiDN(fi), fp->fpath, NULL);
 
 	if (rc == 0) {
 	    /* Notify on success. */
diff --git a/lib/rpmplugins.c b/lib/rpmplugins.c
index 703368c0d7..f06fd7895c 100644
--- a/lib/rpmplugins.c
+++ b/lib/rpmplugins.c
@@ -350,21 +350,31 @@ rpmRC rpmpluginsCallScriptletPost(rpmPlugins plugins, const char *s_name, int ty
     return rc;
 }
 
+static char *abspath(rpmfi fi, const char *path)
+{
+    if (*path == '/')
+	return xstrdup(path);
+    else
+	return rstrscat(NULL, rpmfiDN(fi), path, NULL);
+}
+
 rpmRC rpmpluginsCallFsmFilePre(rpmPlugins plugins, rpmfi fi, const char *path,
 			       mode_t file_mode, rpmFsmOp op)
 {
     plugin_fsm_file_pre_func hookFunc;
     int i;
     rpmRC rc = RPMRC_OK;
+    char *apath = abspath(fi, path);
 
     for (i = 0; i < plugins->count; i++) {
 	rpmPlugin plugin = plugins->plugins[i];
 	RPMPLUGINS_SET_HOOK_FUNC(fsm_file_pre);
-	if (hookFunc && hookFunc(plugin, fi, path, file_mode, op) == RPMRC_FAIL) {
+	if (hookFunc && hookFunc(plugin, fi, apath, file_mode, op) == RPMRC_FAIL) {
 	    rpmlog(RPMLOG_ERR, "Plugin %s: hook fsm_file_pre failed\n", plugin->name);
 	    rc = RPMRC_FAIL;
 	}
     }
+    free(apath);
 
     return rc;
 }
@@ -375,14 +385,16 @@ rpmRC rpmpluginsCallFsmFilePost(rpmPlugins plugins, rpmfi fi, const char *path,
     plugin_fsm_file_post_func hookFunc;
     int i;
     rpmRC rc = RPMRC_OK;
+    char *apath = abspath(fi, path);
 
     for (i = 0; i < plugins->count; i++) {
 	rpmPlugin plugin = plugins->plugins[i];
 	RPMPLUGINS_SET_HOOK_FUNC(fsm_file_post);
-	if (hookFunc && hookFunc(plugin, fi, path, file_mode, op, res) == RPMRC_FAIL) {
+	if (hookFunc && hookFunc(plugin, fi, apath, file_mode, op, res) == RPMRC_FAIL) {
 	    rpmlog(RPMLOG_WARNING, "Plugin %s: hook fsm_file_post failed\n", plugin->name);
 	}
     }
+    free(apath);
 
     return rc;
 }
@@ -394,15 +406,17 @@ rpmRC rpmpluginsCallFsmFilePrepare(rpmPlugins plugins, rpmfi fi,
     plugin_fsm_file_prepare_func hookFunc;
     int i;
     rpmRC rc = RPMRC_OK;
+    char *apath = abspath(fi, path);
 
     for (i = 0; i < plugins->count; i++) {
 	rpmPlugin plugin = plugins->plugins[i];
 	RPMPLUGINS_SET_HOOK_FUNC(fsm_file_prepare);
-	if (hookFunc && hookFunc(plugin, fi, fd, path, dest, file_mode, op) == RPMRC_FAIL) {
+	if (hookFunc && hookFunc(plugin, fi, fd, apath, dest, file_mode, op) == RPMRC_FAIL) {
 	    rpmlog(RPMLOG_ERR, "Plugin %s: hook fsm_file_prepare failed\n", plugin->name);
 	    rc = RPMRC_FAIL;
 	}
     }
+    free(apath);
 
     return rc;
 }
