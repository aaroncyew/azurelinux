From 19d73f67883c011cc74326a5dc34f7009efa60e1 Mon Sep 17 00:00:00 2001
From: Panu Matilainen <pmatilai@redhat.com>
Date: Tue, 6 Sep 2022 13:15:44 +0300
Subject: [PATCH 1/2] Fix buffer overrun from commit
 4420c78beb86cc67392274bf351478a3375626a2

The newly handled ^ needs to be accounted for when allocating memory.
Found when testing #1936, goes to show what a useful thing that is.
---
 lib/rpmdb.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/lib/rpmdb.c b/lib/rpmdb.c
index fd2b0671a..b3c5da62d 100644
--- a/lib/rpmdb.c
+++ b/lib/rpmdb.c
@@ -1107,6 +1107,7 @@ static char * mireDup(rpmTagVal tag, rpmMireMode *modep,
 	    case '.':
 	    case '+':
 	    case '*':
+	    case '^':
 		if (!brackets) nb++;
 		break;
 	    case '\\':
-- 
2.17.1


From dc9e8169790eba18130fb96c13f56ecba6c9b346 Mon Sep 17 00:00:00 2001
From: Panu Matilainen <pmatilai@redhat.com>
Date: Tue, 6 Sep 2022 09:28:10 +0300
Subject: [PATCH 2/2] Make pgpPubkeyFingerprint() do something meaningful again

Commit 4bbeec134aab33e24f960be28a7b2198359c1f67 "fixed" an old
terminology confusion about keyid vs fingerprint, but in the process
broke pgpPubkeyFingerprint() for any external callers, as it now only
feeds on decoded packets whereas before it did the decoding by itself.
Add the decoding step back to the public function to make it usable outside
rpmpgp_internal.c again, retrieving a fingerprint seems like an useful
(public) API to have.

This is kind of a regression fix in that prior to commit
4bbeec134aab33e24f960be28a7b2198359c1f67 pgpPubkeyFingerprint() returned
meaningful data to the outside caller and afterwards it didn't, however
that commit broke the API anyhow so it's kinda complicated.
Maybe we should just call it a bugfix and be done with it.

Related to #1549
---
 rpmio/rpmpgp_internal.c | 15 +++++++++++++--
 1 file changed, 13 insertions(+), 2 deletions(-)

diff --git a/rpmio/rpmpgp_internal.c b/rpmio/rpmpgp_internal.c
index d4dd4b89d..8d0d76869 100644
--- a/rpmio/rpmpgp_internal.c
+++ b/rpmio/rpmpgp_internal.c
@@ -650,7 +650,7 @@ static int pgpPrtUserID(pgpTag tag, const uint8_t *h, size_t hlen,
     return 0;
 }
 
-int pgpPubkeyFingerprint(const uint8_t *h, size_t hlen,
+static int getPubkeyFingerprint(const uint8_t *h, size_t hlen,
 			  uint8_t **fp, size_t *fplen)
 {
     int rc = -1; /* assume failure */
@@ -717,11 +717,22 @@ int pgpPubkeyFingerprint(const uint8_t *h, size_t hlen,
     return rc;
 }
 
+int pgpPubkeyFingerprint(const uint8_t * pkt, size_t pktlen,
+                         uint8_t **fp, size_t *fplen)
+{
+    struct pgpPkt p;
+
+    if (decodePkt(pkt, pktlen, &p))
+	return -1;
+
+    return getPubkeyFingerprint(p.body, p.blen, fp, fplen);
+}
+
 static int getKeyID(const uint8_t *h, size_t hlen, pgpKeyID_t keyid)
 {
     uint8_t *fp = NULL;
     size_t fplen = 0;
-    int rc = pgpPubkeyFingerprint(h, hlen, &fp, &fplen);
+    int rc = getPubkeyFingerprint(h, hlen, &fp, &fplen);
     if (fp && fplen > 8) {
 	memcpy(keyid, (fp + (fplen-8)), 8);
 	free(fp);
-- 
2.17.1

From f78be76a00878183da86d5e37ddbe421c5fe028c Mon Sep 17 00:00:00 2001
From: Panu Matilainen <pmatilai@redhat.com>
Date: Wed, 14 Sep 2022 13:13:24 +0300
Subject: [PATCH] Fix a memory leak in the new directory dance in ensureDir()

This would leak the path whenever we already had the directory open.
Which happens a lot. Oops.
---
 lib/fsm.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/lib/fsm.c b/lib/fsm.c
index 129054067..7987abbc9 100644
--- a/lib/fsm.c
+++ b/lib/fsm.c
@@ -374,8 +374,6 @@ static int fsmDoMkDir(rpmPlugins plugins, int dirfd, const char *dn,
 static int ensureDir(rpmPlugins plugins, const char *p, int owned, int create,
 		    int quiet, int *dirfdp)
 {
-    char *path = xstrdup(p);
-    char *dp = path;
     char *sp = NULL, *bn;
     char *apath = NULL;
     int oflags = O_RDONLY;
@@ -387,6 +385,9 @@ static int ensureDir(rpmPlugins plugins, const char *p, int owned, int create,
     int dirfd = fsmOpenat(-1, "/", oflags, 1);
     int fd = dirfd; /* special case of "/" */
 
+    char *path = xstrdup(p);
+    char *dp = path;
+
     while ((bn = strtok_r(dp, "/", &sp)) != NULL) {
 	fd = fsmOpenat(dirfd, bn, oflags, 1);
 	/* assemble absolute path for plugins benefit, sigh */
-- 
2.17.1

From af08077fb4c60dee516948ce7bf9bed91de62119 Mon Sep 17 00:00:00 2001
From: Panu Matilainen <pmatilai@redhat.com>
Date: Tue, 13 Sep 2022 10:26:05 +0300
Subject: [PATCH] Fix possible descriptor leak in fsmOpenat()

For the very unlikely case when openat() succeeded but fstatat()
doesn't, the directory descriptor may be leaved opened. Rearrange
the code a bit to ensure it'll always get closed when appropriate.

Suggested-by: Pavel Kopylov <pkopylov@cloudlinux.com>
Suggested-by: Dmitry Antipov <dantipov@cloudlinux.com>
---
 lib/fsm.c | 14 ++++++++------
 1 file changed, 8 insertions(+), 6 deletions(-)

diff --git a/lib/fsm.c b/lib/fsm.c
index 18fe0c04c..129054067 100644
--- a/lib/fsm.c
+++ b/lib/fsm.c
@@ -313,14 +313,16 @@ static int fsmOpenat(int dirfd, const char *path, int flags, int dir)
      */
     if (fd < 0 && errno == ELOOP && flags != sflags) {
 	int ffd = openat(dirfd, path, flags);
-	if (ffd >= 0 && fstatat(dirfd, path, &lsb, AT_SYMLINK_NOFOLLOW) == 0) {
-	    if (fstat(ffd, &sb) == 0) {
-		if (lsb.st_uid == 0 || lsb.st_uid == sb.st_uid) {
-		    fd = ffd;
-		} else {
-		    close(ffd);
+	if (ffd >= 0) {
+	    if (fstatat(dirfd, path, &lsb, AT_SYMLINK_NOFOLLOW) == 0) {
+		if (fstat(ffd, &sb) == 0) {
+		    if (lsb.st_uid == 0 || lsb.st_uid == sb.st_uid) {
+			fd = ffd;
+		    }
 		}
 	    }
+	    if (ffd != fd)
+		close(ffd);
 	}
     }
 
-- 
2.17.1

