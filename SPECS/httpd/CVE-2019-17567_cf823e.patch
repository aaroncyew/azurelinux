From cf823ed377953f9d6a4ff08f5c0c59e1c2b8e8a4 Mon Sep 17 00:00:00 2001
From: Yann Ylavic <ylavic@apache.org>
Date: Sun, 10 May 2020 20:52:30 +0000
Subject: [PATCH] mod_proxy_http: single point of failure in
 ap_proxy_http_process_response().

No functional change (intended).

git-svn-id: https://svn.apache.org/repos/asf/httpd/httpd/trunk@1877557 13f79535-47bb-0310-9956-ffa450edef68
---
 modules/proxy/mod_proxy_http.c | 50 ++++++++++++++++++++++------------
 1 file changed, 33 insertions(+), 17 deletions(-)

diff --git a/modules/proxy/mod_proxy_http.c b/modules/proxy/mod_proxy_http.c
index 2e7270d578b..62bd44421b8 100644
--- a/modules/proxy/mod_proxy_http.c
+++ b/modules/proxy/mod_proxy_http.c
@@ -1245,7 +1245,9 @@ int ap_proxy_http_process_response(proxy_http_req_t *req)
                 apr_table_setn(r->notes, "proxy_timedout", "1");
                 ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01103) "read timeout");
                 if (do_100_continue) {
-                    return ap_proxyerror(r, HTTP_SERVICE_UNAVAILABLE, "Timeout on 100-Continue");
+                    proxy_status = ap_proxyerror(r, HTTP_SERVICE_UNAVAILABLE,
+                                                 "Timeout on 100-Continue");
+                    goto cleanup;
                 }
             }
             /*
@@ -1295,17 +1297,19 @@ int ap_proxy_http_process_response(proxy_http_req_t *req)
                 /* Mark the backend connection for closing */
                 backend->close = 1;
                 /* Need to return OK to avoid sending an error message */
-                return OK;
+                proxy_status = OK;
+                goto cleanup;
             }
-            else if (!c->keepalives) {
-                     ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01105)
-                                   "NOT Closing connection to client"
-                                   " although reading from backend server %s:%d"
-                                   " failed.",
-                                   backend->hostname, backend->port);
+            if (!c->keepalives) {
+                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01105)
+                              "NOT Closing connection to client"
+                              " although reading from backend server %s:%d"
+                              " failed.",
+                              backend->hostname, backend->port);
             }
-            return ap_proxyerror(r, HTTP_BAD_GATEWAY,
-                                 "Error reading from remote server");
+            proxy_status = ap_proxyerror(r, HTTP_BAD_GATEWAY,
+                                         "Error reading from remote server");
+            goto cleanup;
         }
         /* XXX: Is this a real headers length send from remote? */
         backend->worker->s->read += len;
@@ -1321,9 +1325,11 @@ int ap_proxy_http_process_response(proxy_http_req_t *req)
              * if the status line was > 8192 bytes
              */
             if ((major != 1) || (len >= response_field_size - 1)) {
-                return ap_proxyerror(r, HTTP_BAD_GATEWAY,
-                apr_pstrcat(p, "Corrupt status line returned by remote "
-                            "server: ", buffer, NULL));
+                proxy_status = ap_proxyerror(r, HTTP_BAD_GATEWAY,
+                                   apr_pstrcat(p, "Corrupt status line "
+                                               "returned by remote server: ",
+                                               buffer, NULL));
+                goto cleanup;
             }
             backasswards = 0;
 
@@ -1379,7 +1385,8 @@ int ap_proxy_http_process_response(proxy_http_req_t *req)
                 r->headers_out = apr_table_make(r->pool,1);
                 r->status = HTTP_BAD_GATEWAY;
                 r->status_line = "bad gateway";
-                return r->status;
+                proxy_status = r->status;
+                goto cleanup;
             }
 
             /* Now, add in the just read cookies */
@@ -1424,6 +1431,11 @@ int ap_proxy_http_process_response(proxy_http_req_t *req)
             toclose = ap_proxy_clear_connection_fn(r, r->headers_out);
             if (toclose) {
                 backend->close = 1;
+                if (toclose < 0) {
+                    proxy_status = ap_proxyerror(r, HTTP_BAD_GATEWAY,
+                                                 "Malformed connection header");
+                    goto cleanup;
+                }
             }
 
             if ((buf = apr_table_get(r->headers_out, "Content-Type"))) {
@@ -1584,7 +1596,8 @@ int ap_proxy_http_process_response(proxy_http_req_t *req)
                             c->remote_host ? c->remote_host : "",
                             status);
                     backend->close = 1;
-                    return status;
+                    proxy_status = status;
+                    goto cleanup;
                 }
             }
             else {
@@ -1633,7 +1646,7 @@ int ap_proxy_http_process_response(proxy_http_req_t *req)
              */
             r->status = HTTP_OK;
             /* Discard body, if one is expected */
-        if (!r->header_only && !AP_STATUS_IS_HEADER_ONLY(proxy_status)) {
+            if (!r->header_only && !AP_STATUS_IS_HEADER_ONLY(proxy_status)) {
                 const char *tmp;
                 /* Add minimal headers needed to allow http_in filter
                  * detecting end of body without waiting for a timeout. */
@@ -1653,7 +1666,7 @@ int ap_proxy_http_process_response(proxy_http_req_t *req)
              * internal error.
              */
             apr_table_setn(r->notes, "proxy-error-override", "1");
-            return proxy_status;
+            goto cleanup;
         }
 
         r->sent_bodyct = 1;
@@ -1887,6 +1900,9 @@ int ap_proxy_http_process_response(proxy_http_req_t *req)
     }
 
     return OK;
+
+cleanup:
+    return proxy_status;
 }
 
 static
