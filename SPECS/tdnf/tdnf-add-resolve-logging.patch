From 856bafaa8f868b2f202f59d4c38eff201109b746 Mon Sep 17 00:00:00 2001
From: Sam Meluch <sammeluch@microsoft.com>
Date: Thu, 25 May 2023 11:17:43 -0700
Subject: [PATCH] add logging to resolve.c, tdnfpackage.c, tdnfquery.c. Add
 SELECTION_DOTARCH flag to libsolv call

---
 client/api.c          |  8 ++++++--
 client/packageutils.c |  5 ++++-
 client/resolve.c      | 28 +++++++++++++++++++++++++++-
 solv/tdnfpackage.c    | 10 +++++++++-
 solv/tdnfquery.c      | 10 +++++++++-
 5 files changed, 55 insertions(+), 6 deletions(-)

diff --git a/client/api.c b/client/api.c
index 8b134e8..ab2b23c 100644
--- a/client/api.c
+++ b/client/api.c
@@ -1647,12 +1647,14 @@ TDNFResolve(
     BAIL_ON_TDNF_ERROR(dwError);
 
     if (!pTdnf->pArgs->nBuildDeps) {
+        printf("Calling TDNFPrepareAllPackages\n");
         dwError = TDNFPrepareAllPackages(
                       pTdnf,
                       &nAlterType,
                       ppszPkgsNotResolved,
                       &queueGoal);
     } else {
+        printf("Calling TDNFResolveBuildDependencies\n");
         dwError = TDNFResolveBuildDependencies(
                         pTdnf,
                         ppszPkgNames,
@@ -1662,12 +1664,14 @@ TDNFResolve(
     BAIL_ON_TDNF_ERROR(dwError);
 
     if (!pTdnf->pArgs->nSource && !pTdnf->pArgs->nNoDeps) {
+        printf("Calling TDNFGoal\n");
         dwError = TDNFGoal(
                       pTdnf,
                       &queueGoal,
                       &pSolvedPkgInfo,
                       nAlterType);
     } else {
+        printf("Calling TDNFGoalNoDeps\n");
         dwError = TDNFGoalNoDeps(
                       pTdnf,
                       &queueGoal,
@@ -1689,7 +1693,7 @@ TDNFResolve(
         pSolvedPkgInfo->pPkgsToUpgrade ||
         pSolvedPkgInfo->pPkgsToDowngrade ||
         pSolvedPkgInfo->pPkgsToReinstall;
-
+    printf("Post Goals\n");
     dwError = TDNFGetAvailableCacheBytes(pTdnf->pConf, &qwAvailCacheBytes);
     BAIL_ON_TDNF_ERROR(dwError);
 
@@ -1701,7 +1705,7 @@ TDNFResolve(
 
     pSolvedPkgInfo->ppszPkgsNotResolved = ppszPkgsNotResolved;
     *ppSolvedPkgInfo = pSolvedPkgInfo;
-
+    printf("End Resolve\n");
 cleanup:
     /* only free the pointers */
     TDNF_SAFE_FREE_MEMORY(ppszPkgNames);
diff --git a/client/packageutils.c b/client/packageutils.c
index adc3870..6368f43 100644
--- a/client/packageutils.c
+++ b/client/packageutils.c
@@ -664,13 +664,14 @@ TDNFAddPackagesForInstall(
     uint32_t dwError = 0;
     Id dwHighestAvailable = 0;
     uint32_t  dwInstallPackage = 0;
-
+    printf("Starting TDNFAddPackagesForInstall\n");
     if(!pSack || !pQueueGoal || IsNullOrEmptyString(pszPkgName))
     {
         dwError = ERROR_TDNF_INVALID_PARAMETER;
         BAIL_ON_TDNF_ERROR(dwError);
     }
 
+    printf("Calling SolvFindHighestAvailable\n");
     dwError = SolvFindHighestAvailable(
                   pSack,
                   pszPkgName,
@@ -678,6 +679,7 @@ TDNFAddPackagesForInstall(
                   &dwHighestAvailable);
     BAIL_ON_TDNF_ERROR(dwError);
 
+    printf("Calling TDNFVerifyInstallPackage\n");
     dwError = TDNFVerifyInstallPackage(
                   pSack,
                   dwHighestAvailable,
@@ -693,6 +695,7 @@ TDNFAddPackagesForInstall(
         dwError = ERROR_TDNF_ALREADY_INSTALLED;
         BAIL_ON_TDNF_ERROR(dwError);
     }
+    printf("End TDNFAddPackagesForInstall\n");
 
 cleanup:
     return dwError;
diff --git a/client/resolve.c b/client/resolve.c
index cb7ca0f..e511b5e 100644
--- a/client/resolve.c
+++ b/client/resolve.c
@@ -71,9 +71,11 @@ TDNFPrepareAllPackages(
     uint32_t dwRebootRequired = 0;
     TDNF_ALTERTYPE nAlterType = 0;
 
+    printf("Starting TDNFPrepareAllPackages\n");
     if(!pTdnf || !pTdnf->pSack ||
        !pTdnf->pArgs || !ppszPkgsNotResolved || !queueGoal || !pAlterType)
     {
+        printf("Bailed from TDNFPrepareAllPackages\n");
         dwError = ERROR_TDNF_INVALID_PARAMETER;
         BAIL_ON_TDNF_ERROR(dwError);
     }
@@ -96,12 +98,14 @@ TDNFPrepareAllPackages(
         BAIL_ON_TDNF_ERROR(dwError);
     }
 
+    printf("Calling TDNFGetSecuritySeverityOption\n");
     dwError = TDNFGetSecuritySeverityOption(
                   pTdnf,
                   &dwSecurity,
                   &pszSeverity);
     BAIL_ON_TDNF_ERROR(dwError);
 
+    printf("Calling TDNFGetRebootRequiredOption\n");
     dwError = TDNFGetRebootRequiredOption(
                   pTdnf,
                   &dwRebootRequired);
@@ -111,11 +115,14 @@ TDNFPrepareAllPackages(
          nAlterType == ALTER_UPGRADE) &&
         (dwSecurity || pszSeverity || dwRebootRequired))
     {
+        printf("In Upgrade section\n");
         //pAlterType is changed to ALTER_UPGRADE and later used in TDNFGoal() to add exclude the
         // list of packages that are added in --exclude option.
         *pAlterType = ALTER_UPGRADE;
+        printf("Calling TDNFGetUpdatePkgs\n");
         dwError = TDNFGetUpdatePkgs(pTdnf, &ppszPkgArray, &dwCount);
         BAIL_ON_TDNF_ERROR(dwError);
+        printf("Looping TDNFPrepareSinglePkg\n");
         for(nPkgIndex = 0; (uint32_t)nPkgIndex < dwCount; ++nPkgIndex)
         {
             dwError = TDNFPrepareSinglePkg(
@@ -126,6 +133,7 @@ TDNFPrepareAllPackages(
                           queueGoal);
             BAIL_ON_TDNF_ERROR(dwError);
         }
+        printf("Done Upgrade section\n");
     }
     else
     {
@@ -135,7 +143,9 @@ TDNFPrepareAllPackages(
 
            if(TDNFIsGlob(pszPkgName))
            {
+               printf("In TDNF Glob section\n");
                queue_empty(&queueLocal);
+               printf("Calling TDNFGetGlobPackages\n");
                dwError = TDNFGetGlobPackages(
                              pTdnf->pSack,
                              pszPkgName,
@@ -143,6 +153,7 @@ TDNFPrepareAllPackages(
                BAIL_ON_TDNF_ERROR(dwError);
                if(queueLocal.count == 0)
                {
+                   printf("Calling TDNFAddNotResolved\n");
                    dwError = TDNFAddNotResolved(ppszPkgsNotResolved, pszPkgName);
                    BAIL_ON_TDNF_ERROR(dwError);
                }
@@ -151,12 +162,14 @@ TDNFPrepareAllPackages(
                    nPkgIndex = 0;
                    for(nPkgIndex = 0; nPkgIndex < queueLocal.count; nPkgIndex++)
                    {
+                       printf("Calling SolvGetPkgNameFromId\n");
                        dwError = SolvGetPkgNameFromId(
                                      pTdnf->pSack,
                                      queueLocal.elements[nPkgIndex],
                                      &pszName);
                        BAIL_ON_TDNF_ERROR(dwError);
 
+                       printf("Calling TDNFPrepareSinglePkg\n");
                        dwError = TDNFPrepareSinglePkg(
                                      pTdnf,
                                      pszName,
@@ -168,6 +181,7 @@ TDNFPrepareAllPackages(
                        pszName = NULL;
                    }
                }
+               printf("Done Glob section\n");
            }
            else
            {
@@ -176,6 +190,7 @@ TDNFPrepareAllPackages(
                    continue;
                }
 
+               printf("Calling TDNFPrepareSinglePkg\n");
                dwError = TDNFPrepareSinglePkg(
                              pTdnf,
                              pszPkgName,
@@ -186,6 +201,7 @@ TDNFPrepareAllPackages(
            }
        }
     }
+    printf("Done TDNFPrepareAllPackages\n");
 
 cleanup:
     TDNF_SAFE_FREE_MEMORY(pszSeverity);
@@ -310,7 +326,7 @@ TDNFPrepareSinglePkg(
     PSolvPackageList pInstalledPkgList = NULL;
     uint32_t dwCount = 0;
     PSolvSack pSack = NULL;
-
+    printf("Starting TDNFPrepareSinglePackage\n");
     if(!pTdnf ||
        !pTdnf->pSack ||
        !ppszPkgsNotResolved ||
@@ -323,6 +339,7 @@ TDNFPrepareSinglePkg(
 
     pSack = pTdnf->pSack;
 
+    printf("Calling SolvCountPkgByName\n");
     //Check if this is a known package. If not add to unresolved
     dwError = SolvCountPkgByName(pSack, pszPkgName, pTdnf->pArgs->nSource, &dwCount);
     if (dwError == ERROR_TDNF_NO_MATCH)
@@ -334,6 +351,7 @@ TDNFPrepareSinglePkg(
         }
     }
     BAIL_ON_TDNF_ERROR(dwError);
+    printf("After SolvCountPkgByName\n");
 
     if (dwCount == 0)
     {
@@ -343,11 +361,14 @@ TDNFPrepareSinglePkg(
 
     if(nAlterType == ALTER_REINSTALL)
     {
+        printf("Start ALTER_REINSTALL\n");
+        printf("Calling TDNFMatchForReinstall\n");
         dwError = TDNFMatchForReinstall(
                       pSack,
                       pszPkgName,
                       queueGoal);
         BAIL_ON_TDNF_ERROR(dwError);
+        printf("End ALTER_REINSTALL\n");
     }
 
     if(nAlterType == ALTER_ERASE ||
@@ -371,8 +392,10 @@ TDNFPrepareSinglePkg(
     }
     else if (nAlterType == ALTER_INSTALL)
     {
+        printf("Starting ALTER_INSTALL section\n");
         int nSource = pTdnf->pArgs->nSource;
 
+        printf("Calling TDNFAddPackagesForInstall\n");
         dwError = TDNFAddPackagesForInstall(
                       pSack,
                       queueGoal,
@@ -382,6 +405,7 @@ TDNFPrepareSinglePkg(
         {
             /* the package may have been already installed as a dependency,
                but now the user wants it on its own */
+            printf("Calling TDNFMarkAutoInstalledSinglePkg\n");
             dwError = TDNFMarkAutoInstalledSinglePkg(pTdnf, pszPkgName);
             BAIL_ON_TDNF_ERROR(dwError);
             /* if TDNFMarkAutoInstalledSinglePkg() was successful, restore
@@ -389,6 +413,7 @@ TDNFPrepareSinglePkg(
             dwError = ERROR_TDNF_ALREADY_INSTALLED;
         }
         BAIL_ON_TDNF_ERROR(dwError);
+        printf("End ALTER_INSTALL section\n");
     }
     else if (nAlterType == ALTER_UPGRADE)
     {
@@ -407,6 +432,7 @@ TDNFPrepareSinglePkg(
                       pszPkgName);
         BAIL_ON_TDNF_ERROR(dwError);
     }
+    printf("End TDNFPrepareSinglePackage\n");
 
 cleanup:
     if(pInstalledPkgList)
diff --git a/solv/tdnfpackage.c b/solv/tdnfpackage.c
index cfa66e1..c6e2661 100644
--- a/solv/tdnfpackage.c
+++ b/solv/tdnfpackage.c
@@ -125,6 +125,7 @@ SolvGetQueryResult(
         BAIL_ON_TDNF_ERROR(dwError);
     }
 
+    printf("Calling SolvQueueToPackageList\n");
     dwError = SolvQueueToPackageList(&pQuery->queueResult, &pPkgList);
     BAIL_ON_TDNF_ERROR(dwError);
     *ppPkgList = pPkgList;
@@ -988,7 +989,8 @@ SolvCountPkgByName(
     PSolvQuery pQuery = NULL;
     PSolvPackageList pPkgList = NULL;
     uint32_t dwCount = 0;
-
+    
+    printf("Starting SolvCountPkgByName\n");
     if(!pSack || IsNullOrEmptyString(pszName) ||
        !pdwCount)
     {
@@ -996,22 +998,28 @@ SolvCountPkgByName(
         BAIL_ON_TDNF_ERROR(dwError);
     }
 
+    printf("Calling SolvCreateQuery\n");
     dwError = SolvCreateQuery(pSack, &pQuery);
     BAIL_ON_TDNF_ERROR(dwError);
 
     if (nSource) {
+        printf("Setting nScope\n");
         pQuery->nScope = SCOPE_SOURCE;
     }
 
+    printf("Calling SolvApplySinglePackageFilter\n");
     dwError = SolvApplySinglePackageFilter(pQuery, pszName);
     BAIL_ON_TDNF_ERROR(dwError);
 
+    printf("Calling SolvApplyListQuery\n");
     dwError = SolvApplyListQuery(pQuery);
     BAIL_ON_TDNF_ERROR(dwError);
 
+    printf("Calling SolvGetQueryResult\n");
     dwError = SolvGetQueryResult(pQuery, &pPkgList);
     BAIL_ON_TDNF_ERROR(dwError);
 
+    printf("Calling SolvGetPackageListSize\n");
     dwError = SolvGetPackageListSize(pPkgList, &dwCount);
     BAIL_ON_TDNF_ERROR(dwError);
 
diff --git a/solv/tdnfquery.c b/solv/tdnfquery.c
index e5d9144..e56f069 100644
--- a/solv/tdnfquery.c
+++ b/solv/tdnfquery.c
@@ -427,7 +427,8 @@ SolvGenerateCommonJob(
     Queue queueJob = {0};
     uint32_t nFlags = 0;
     uint32_t nRetFlags = 0;
-
+    
+    printf("Starting SolvGenerateCommonJob\n");
     if(!pQuery || !pQuery->pSack)
     {
         dwError = ERROR_TDNF_INVALID_PARAMETER;
@@ -437,6 +438,7 @@ SolvGenerateCommonJob(
     ppszPkgNames = pQuery->ppszPackageNames;
     queue_init(&queueJob);
     pPool = pQuery->pSack->pPool;
+    printf("assigned pPool\n");
     if(ppszPkgNames)
     {
         while(*ppszPkgNames)
@@ -444,6 +446,7 @@ SolvGenerateCommonJob(
             nFlags  = dwSelectFlags;
             nRetFlags = 0;
 
+            printf("Looping over package names\n");
             queue_empty(&queueJob);
             if (!pPool || !pPool->solvables || !pPool->whatprovides)
             {
@@ -595,6 +598,7 @@ SolvApplyListQuery(
     Queue queueTmp = {0};
     uint32_t nFlags = 0;
 
+    printf("Starting SolvApplyListQuery\n");
     if(!pQuery)
     {
         dwError = ERROR_TDNF_INVALID_PARAMETER;
@@ -606,22 +610,26 @@ SolvApplyListQuery(
              SELECTION_PROVIDES |
              SELECTION_GLOB |     /* foo* */
              SELECTION_CANON |    /* foo-1.2-3.ph4.noarch */
+             SELECTION_DOTARCH |     /* allow .<arch> tags in packages */
              SELECTION_REL;       /* foo>=1.2-3 */
 
     if (pQuery->nScope == SCOPE_SOURCE) {
         nFlags |= SELECTION_SOURCE_ONLY;
     }
 
+    printf("Calling GenerateCommonJob\n");
     dwError = SolvGenerateCommonJob(pQuery, nFlags);
     BAIL_ON_TDNF_LIBSOLV_ERROR(dwError);
 
     if(pQuery->nScope == SCOPE_UPGRADES)
     {
+        printf("Calling SolvApplyUpDownScope (1)\n");
         dwError = SolvApplyUpDownScope(pQuery, 1);
         BAIL_ON_TDNF_ERROR(dwError);
     }
     else if(pQuery->nScope == SCOPE_DOWNGRADES)
     {
+        printf("Calling SolvApplyUpDownScope (0)\n");
         dwError = SolvApplyUpDownScope(pQuery, 0);
         BAIL_ON_TDNF_ERROR(dwError);
     }
-- 
2.25.1

