From 7680f621c3a93847d35765704862d8e1f1fb6818 Mon Sep 17 00:00:00 2001
From: Yan Avlasov <yavlasov@google.com>
Date: Thu, 1 Apr 2021 12:34:21 -0400
Subject: [PATCH] Implement handling of escaped slash characters in URL path

Fixes: CVE-2021-29492

Signed-off-by: Yan Avlasov <yavlasov@google.com>
---
 .../v3/http_connection_manager.proto          |  39 +++-
 .../v4alpha/http_connection_manager.proto     |  39 +++-
 .../configuration/best_practices/edge.rst     |  15 ++
 .../http/http_conn_man/runtime.rst            |  19 ++
 .../http/http_conn_man/stats.rst              |   2 +
 docs/root/version_history/current.rst         |   1 +
 .../v3/http_connection_manager.proto          |  39 +++-
 .../v4alpha/http_connection_manager.proto     |  39 +++-
 source/common/http/conn_manager_config.h      |  10 +
 source/common/http/conn_manager_impl.cc       |  22 ++-
 source/common/http/conn_manager_utility.cc    |  42 +++-
 source/common/http/conn_manager_utility.h     |  13 +-
 source/common/http/path_utility.cc            |  35 ++++
 source/common/http/path_utility.h             |  11 ++
 .../network/http_connection_manager/config.cc |  48 ++++-
 .../network/http_connection_manager/config.h  |   7 +
 source/server/admin/admin.h                   |   6 +
 .../http/conn_manager_impl_fuzz_test.cc       |   6 +
 test/common/http/conn_manager_impl_test.cc    | 128 +++++++++++++
 test/common/http/conn_manager_utility_test.cc | 180 +++++++++++++++++-
 test/common/http/path_utility_test.cc         |  55 ++++++
 .../http_connection_manager/config_test.cc    | 176 ++++++++++++++++-
 test/integration/header_integration_test.cc   | 165 +++++++++++++++-
 test/integration/protocol_integration_test.cc |  19 ++
 24 files changed, 1087 insertions(+), 29 deletions(-)

diff --git a/api/envoy/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto b/api/envoy/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto
index b200267..b09c16c 100644
--- a/api/envoy/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto
+++ b/api/envoy/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto
@@ -30,7 +30,7 @@ option (udpa.annotations.file_status).package_version_status = ACTIVE;
 // HTTP connection manager :ref:`configuration overview <config_http_conn_man>`.
 // [#extension: envoy.filters.network.http_connection_manager]
 
-// [#next-free-field: 37]
+// [#next-free-field: 46]
 message HttpConnectionManager {
   option (udpa.annotations.versioning).previous_message_type =
       "envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager";
@@ -93,6 +93,36 @@ message HttpConnectionManager {
     ALWAYS_FORWARD_ONLY = 4;
   }
 
+  // Determines the action for request that contain %2F, %2f, %5C or %5c sequences in the URI path.
+  // This operation occurs before URL normalization and the merge slashes transformations if they were enabled.
+  enum PathWithEscapedSlashesAction {
+    // Default behavior specific to implementation (i.e. Envoy) of this configuration option.
+    // Envoy, by default, takes the KEEP_UNCHANGED action.
+    // NOTE: the implementation may change the default behavior at-will.
+    IMPLEMENTATION_SPECIFIC_DEFAULT = 0;
+
+    // Keep escaped slashes.
+    KEEP_UNCHANGED = 1;
+
+    // Reject client request with the 400 status. gRPC requests will be rejected with the INTERNAL (13) error code.
+    // The "httpN.downstream_rq_failed_path_normalization" counter is incremented for each rejected request.
+    REJECT_REQUEST = 2;
+
+    // Unescape %2F and %5C sequences and redirect request to the new path if these sequences were present.
+    // Redirect occurs after path normalization and merge slashes transformations if they were configured.
+    // NOTE: gRPC requests will be rejected with the INTERNAL (13) error code.
+    // This option minimizes possibility of path confusion exploits by forcing request with unescaped slashes to
+    // traverse all parties: downstream client, intermediate proxies, Envoy and upstream server.
+    // The "httpN.downstream_rq_redirected_with_normalized_path" counter is incremented for each
+    // redirected request.
+    UNESCAPE_AND_REDIRECT = 3;
+
+    // Unescape %2F and %5C sequences.
+    // Note: this option should not be enabled if intermediaries perform path based access control as
+    // it may lead to path confusion vulnerabilities.
+    UNESCAPE_AND_FORWARD = 4;
+  }
+
   // [#next-free-field: 10]
   message Tracing {
     option (udpa.annotations.versioning).previous_message_type =
@@ -494,6 +524,13 @@ message HttpConnectionManager {
   // `HTTP spec <https://tools.ietf.org/html/rfc3986>` and is provided for convenience.
   bool merge_slashes = 33;
 
+  // Action to take when request URL path contains escaped slash sequences (%2F, %2f, %5C and %5c).
+  // The default value can be overridden by the :ref:`http_connection_manager.path_with_escaped_slashes_action<config_http_conn_man_runtime_path_with_escaped_slashes_action>`
+  // runtime variable.
+  // The :ref:`http_connection_manager.path_with_escaped_slashes_action_sampling<config_http_conn_man_runtime_path_with_escaped_slashes_action_enabled>` runtime
+  // variable can be used to apply the action to a portion of all requests.
+  PathWithEscapedSlashesAction path_with_escaped_slashes_action = 45;
+
   // The configuration of the request ID extension. This includes operations such as
   // generation, validation, and associated tracing operations.
   //
diff --git a/api/envoy/extensions/filters/network/http_connection_manager/v4alpha/http_connection_manager.proto b/api/envoy/extensions/filters/network/http_connection_manager/v4alpha/http_connection_manager.proto
index c558291..9c1d377 100644
--- a/api/envoy/extensions/filters/network/http_connection_manager/v4alpha/http_connection_manager.proto
+++ b/api/envoy/extensions/filters/network/http_connection_manager/v4alpha/http_connection_manager.proto
@@ -30,7 +30,7 @@ option (udpa.annotations.file_status).package_version_status = NEXT_MAJOR_VERSIO
 // HTTP connection manager :ref:`configuration overview <config_http_conn_man>`.
 // [#extension: envoy.filters.network.http_connection_manager]
 
-// [#next-free-field: 37]
+// [#next-free-field: 46]
 message HttpConnectionManager {
   option (udpa.annotations.versioning).previous_message_type =
       "envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager";
@@ -93,6 +93,36 @@ message HttpConnectionManager {
     ALWAYS_FORWARD_ONLY = 4;
   }
 
+  // Determines the action for request that contain %2F, %2f, %5C or %5c sequences in the URI path.
+  // This operation occurs before URL normalization and the merge slashes transformations if they were enabled.
+  enum PathWithEscapedSlashesAction {
+    // Default behavior specific to implementation (i.e. Envoy) of this configuration option.
+    // Envoy, by default, takes the KEEP_UNCHANGED action.
+    // NOTE: the implementation may change the default behavior at-will.
+    IMPLEMENTATION_SPECIFIC_DEFAULT = 0;
+
+    // Keep escaped slashes.
+    KEEP_UNCHANGED = 1;
+
+    // Reject client request with the 400 status. gRPC requests will be rejected with the INTERNAL (13) error code.
+    // The "httpN.downstream_rq_failed_path_normalization" counter is incremented for each rejected request.
+    REJECT_REQUEST = 2;
+
+    // Unescape %2F and %5C sequences and redirect request to the new path if these sequences were present.
+    // Redirect occurs after path normalization and merge slashes transformations if they were configured.
+    // NOTE: gRPC requests will be rejected with the INTERNAL (13) error code.
+    // This option minimizes possibility of path confusion exploits by forcing request with unescaped slashes to
+    // traverse all parties: downstream client, intermediate proxies, Envoy and upstream server.
+    // The "httpN.downstream_rq_redirected_with_normalized_path" counter is incremented for each
+    // redirected request.
+    UNESCAPE_AND_REDIRECT = 3;
+
+    // Unescape %2F and %5C sequences.
+    // Note: this option should not be enabled if intermediaries perform path based access control as
+    // it may lead to path confusion vulnerabilities.
+    UNESCAPE_AND_FORWARD = 4;
+  }
+
   // [#next-free-field: 10]
   message Tracing {
     option (udpa.annotations.versioning).previous_message_type =
@@ -494,6 +524,13 @@ message HttpConnectionManager {
   // `HTTP spec <https://tools.ietf.org/html/rfc3986>` and is provided for convenience.
   bool merge_slashes = 33;
 
+  // Action to take when request URL path contains escaped slash sequences (%2F, %2f, %5C and %5c).
+  // The default value can be overridden by the :ref:`http_connection_manager.path_with_escaped_slashes_action<config_http_conn_man_runtime_path_with_escaped_slashes_action>`
+  // runtime variable.
+  // The :ref:`http_connection_manager.path_with_escaped_slashes_action_sampling<config_http_conn_man_runtime_path_with_escaped_slashes_action_enabled>` runtime
+  // variable can be used to apply the action to a portion of all requests.
+  PathWithEscapedSlashesAction path_with_escaped_slashes_action = 45;
+
   // The configuration of the request ID extension. This includes operations such as
   // generation, validation, and associated tracing operations.
   //
diff --git a/docs/root/configuration/best_practices/edge.rst b/docs/root/configuration/best_practices/edge.rst
index 493193d..73f3db1 100644
--- a/docs/root/configuration/best_practices/edge.rst
+++ b/docs/root/configuration/best_practices/edge.rst
@@ -27,6 +27,18 @@ HTTP proxies should additionally configure:
 * :ref:`Listener connection limits. <config_listeners_runtime>`
 * :ref:`Global downstream connection limits <config_overload_manager>`.
 
+If Envoy is configured with RBAC filter or makes route selection based on URL path it is recommended to enable the following path normalization options to minimize probability of path confusion vulnerabilities. Path confusion vulnerabilities occur when parties participating in request use different path representations.
+
+* Enable :ref:`normalize_path setting <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.normalize_path>`.
+* Enable :ref:`merge_slashes setting <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.merge_slashes>`.
+
+Additionally the :ref:`path_with_escaped_slashes_action setting <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.path_with_escaped_slashes_action>` should be set according to following recommendations:
+
+* REJECT_REQUEST if dowstream clients are expected to use rfc3986 compliant normalized paths (i.e. gRPC clients).
+* UNESCAPE_AND_REDIRECT if downstream client supports HTTP redirect (i.e. a browser). This option minimizes possibility of path confusion by forcing request to be re-issued with the same path across all parties: downstream client, Envoy and upstream server. Note that gRPC requests will still be rejected with the INTERNAL (13) error code, as gRPC clients do not support redirect.
+* KEEP_UNCHANGED for servers that are not rfc3986 compliant and require encoded slashes.
+* UNESCAPE_AND_FORWARD for servers that are known to treat escaped and unescaped slashes equivalently. Choosing this option may increase probablity of path confusion vulnerabilities if intermediaries perform path based access control.
+
 The following is a YAML example of the above recommendation.
 
 .. code-block:: yaml
@@ -84,6 +96,9 @@ The following is a YAML example of the above recommendation.
             "@type": type.googleapis.com/envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager
             stat_prefix: ingress_http
             use_remote_address: true
+            normalize_path: true
+            merge_slashes: true
+            path_with_escaped_slashes_action: UNESCAPE_AND_REDIRECT
             common_http_protocol_options:
               idle_timeout: 3600s # 1 hour
               headers_with_underscores_action: REJECT_REQUEST
diff --git a/docs/root/configuration/http/http_conn_man/runtime.rst b/docs/root/configuration/http/http_conn_man/runtime.rst
index 2c104c806508..e19d3d89acf7 100644
--- a/docs/root/configuration/http/http_conn_man/runtime.rst
+++ b/docs/root/configuration/http/http_conn_man/runtime.rst
@@ -31,3 +31,22 @@ tracing.random_sampling
   % of requests that will be randomly traced. See :ref:`here <arch_overview_tracing>` for more
   information. This runtime control is specified in the range 0-10000 and defaults to 10000. Thus,
   trace sampling can be specified in 0.01% increments.
+
+.. _config_http_conn_man_runtime_path_with_escaped_slashes_action:
+
+http_connection_manager.path_with_escaped_slashes_action
+  Overrides Envoy's default action taken when the
+  :ref:`path_with_escaped_slashes_action <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.path_with_escaped_slashes_action>`.
+  was not specified or set to the IMPLEMENTATION_SPECIFIC_DEFAULT value. Possible values:
+
+  - 2 sets action to the REJECT_REQUEST.
+  - 3 sets action to the UNESCAPE_AND_REDIRECT.
+  - 4 sets action to the UNESCAPE_AND_FORWARD.
+  - all other values set the action to KEEP_UNCHANGED.
+
+.. _config_http_conn_man_runtime_path_with_escaped_slashes_action_enabled:
+
+http_connection_manager.path_with_escaped_slashes_action_enabled
+  % of requests that will be subject to the
+  :ref:`path_with_escaped_slashes_action <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.path_with_escaped_slashes_action>`.
+  action. For all other requests the KEEP_UNCHANGED action will be applied. Defaults to 100.
diff --git a/docs/root/configuration/http/http_conn_man/stats.rst b/docs/root/configuration/http/http_conn_man/stats.rst
index 1d5b5c348096..66fec76b31f7 100644
--- a/docs/root/configuration/http/http_conn_man/stats.rst
+++ b/docs/root/configuration/http/http_conn_man/stats.rst
@@ -48,6 +48,7 @@ statistics:
    downstream_rq_non_relative_path, Counter, Total requests with a non-relative HTTP path
    downstream_rq_too_large, Counter, Total requests resulting in a 413 due to buffering an overly large body
    downstream_rq_completed, Counter, Total requests that resulted in a response (e.g. does not include aborted requests)
+   downstream_rq_failed_path_normalization, Counter, Total requests redirected due to different original and normalized URL paths or when path normalization failed. This action is configured by setting the :ref:`path_with_escaped_slashes_action <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.path_with_escaped_slashes_action>` config option.
    downstream_rq_1xx, Counter, Total 1xx responses
    downstream_rq_2xx, Counter, Total 2xx responses
    downstream_rq_3xx, Counter, Total 3xx responses
@@ -59,6 +60,7 @@ statistics:
    downstream_rq_max_duration_reached, Counter, Total requests closed due to max duration reached
    downstream_rq_timeout, Counter, Total requests closed due to a timeout on the request path
    downstream_rq_overload_close, Counter, Total requests closed due to Envoy overload
+   downstream_rq_redirected_with_normalized_path, Counter, Total requests redirected due to different original and normalized URL paths. This action is configured by setting the :ref:`path_with_escaped_slashes_action <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.path_with_escaped_slashes_action>` config option.
    rs_too_large, Counter, Total response errors due to buffering an overly large body
 
 Per user agent statistics
diff --git a/source/common/http/conn_manager_config.h b/source/common/http/conn_manager_config.h
index 774b5e9..f35b5f2 100644
--- a/source/common/http/conn_manager_config.h
+++ b/source/common/http/conn_manager_config.h
@@ -48,12 +48,14 @@ namespace Http {
   COUNTER(downstream_rq_4xx)                                                                       \
   COUNTER(downstream_rq_5xx)                                                                       \
   COUNTER(downstream_rq_completed)                                                                 \
+  COUNTER(downstream_rq_failed_path_normalization)                                                 \
   COUNTER(downstream_rq_http1_total)                                                               \
   COUNTER(downstream_rq_http2_total)                                                               \
   COUNTER(downstream_rq_http3_total)                                                               \
   COUNTER(downstream_rq_idle_timeout)                                                              \
   COUNTER(downstream_rq_non_relative_path)                                                         \
   COUNTER(downstream_rq_overload_close)                                                            \
+  COUNTER(downstream_rq_redirected_with_normalized_path)                                           \               
   COUNTER(downstream_rq_response_before_rq_complete)                                               \
   COUNTER(downstream_rq_rx_reset)                                                                  \
   COUNTER(downstream_rq_timeout)                                                                   \
@@ -425,6 +427,14 @@ public:
    */
   virtual envoy::config::core::v3::HttpProtocolOptions::HeadersWithUnderscoresAction
   headersWithUnderscoresAction() const PURE;
+
+  /**
+   * @return the action HttpConnectionManager should take when receiving client request
+   * with URI path containing %2F, %2f, %5c or %5C sequences.
+   */
+  virtual envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager::
+      PathWithEscapedSlashesAction
+      pathWithEscapedSlashesAction() const PURE;
 };
 } // namespace Http
 } // namespace Envoy

diff --git a/source/common/http/conn_manager_impl.cc b/source/common/http/conn_manager_impl.cc
index 9691449..264c91a 100644
--- a/source/common/http/conn_manager_impl.cc
+++ b/source/common/http/conn_manager_impl.cc
@@ -876,14 +876,32 @@ void ConnectionManagerImpl::ActiveStream::decodeHeaders(RequestHeaderMapPtr&& he
   }
 
   // Path sanitization should happen before any path access other than the above sanity check.
-  if (!ConnectionManagerUtility::maybeNormalizePath(*request_headers_,
-                                                    connection_manager_.config_)) {
+  const auto action =
+      ConnectionManagerUtility::maybeNormalizePath(*request_headers_, connection_manager_.config_);
+  // gRPC requests are rejected if Envoy is configured to redirect post-normalization. This is
+  // because gRPC clients do not support redirect.
+  if (action == ConnectionManagerUtility::NormalizePathAction::Reject ||
+      (action == ConnectionManagerUtility::NormalizePathAction::Redirect &&
+       Grpc::Common::hasGrpcContentType(*request_headers_))) {
+    connection_manager_.stats_.named_.downstream_rq_failed_path_normalization_.inc();
     sendLocalReply(Grpc::Common::hasGrpcContentType(*request_headers_), Code::BadRequest, "",
                    nullptr, state_.is_head_request_, absl::nullopt,
                    StreamInfo::ResponseCodeDetails::get().PathNormalizationFailed);
     return;
+  } else if (action == ConnectionManagerUtility::NormalizePathAction::Redirect) {
+    connection_manager_.stats_.named_.downstream_rq_redirected_with_normalized_path_.inc();
+    sendLocalReply(
+        false, Code::TemporaryRedirect, "",
+        [new_path = request_headers_->Path()->value().getStringView()](
+            Http::ResponseHeaderMap& response_headers) -> void {
+          response_headers.addReferenceKey(Http::Headers::get().Location, new_path);
+        },
+        state_.is_head_request_, absl::nullopt,
+        StreamInfo::ResponseCodeDetails::get().PathNormalizationFailed);
+    return;
   }
 
+  ASSERT(action == ConnectionManagerUtility::NormalizePathAction::Continue);
   if (protocol == Protocol::Http11 && request_headers_->Connection() &&
       absl::EqualsIgnoreCase(request_headers_->Connection()->value().getStringView(),
                              Http::Headers::get().ConnectionValues.Close)) {

diff --git a/source/common/http/conn_manager_utility.cc b/source/common/http/conn_manager_utility.cc
index 615bcf0..de88d36 100644
--- a/source/common/http/conn_manager_utility.cc
+++ b/source/common/http/conn_manager_utility.cc
@@ -392,18 +392,45 @@ void ConnectionManagerUtility::mutateResponseHeaders(
   }
 }
 
-bool ConnectionManagerUtility::maybeNormalizePath(RequestHeaderMap& request_headers,
-                                                  const ConnectionManagerConfig& config) {
-  ASSERT(request_headers.Path());
-  bool is_valid_path = true;
-  if (config.shouldNormalizePath()) {
-    is_valid_path = PathUtil::canonicalPath(request_headers);
+ConnectionManagerUtility::NormalizePathAction
+ConnectionManagerUtility::maybeNormalizePath(RequestHeaderMap& request_headers,
+                                             const ConnectionManagerConfig& config) {
+  if (!request_headers.Path()) {
+    return NormalizePathAction::Continue; // It's as valid as it is going to get.
   }
+
+  NormalizePathAction final_action = NormalizePathAction::Continue;
+  const auto escaped_slashes_action = config.pathWithEscapedSlashesAction();
+  ASSERT(escaped_slashes_action != envoy::extensions::filters::network::http_connection_manager::
+                                       v3::HttpConnectionManager::IMPLEMENTATION_SPECIFIC_DEFAULT);
+  if (escaped_slashes_action != envoy::extensions::filters::network::http_connection_manager::v3::
+                                    HttpConnectionManager::KEEP_UNCHANGED) {
+    auto escaped_slashes_result = PathUtil::unescapeSlashes(request_headers);
+    if (escaped_slashes_result == PathUtil::UnescapeSlashesResult::FoundAndUnescaped) {
+      if (escaped_slashes_action == envoy::extensions::filters::network::http_connection_manager::
+                                        v3::HttpConnectionManager::REJECT_REQUEST) {
+        return NormalizePathAction::Reject;
+      } else if (escaped_slashes_action ==
+                 envoy::extensions::filters::network::http_connection_manager::v3::
+                     HttpConnectionManager::UNESCAPE_AND_REDIRECT) {
+        final_action = NormalizePathAction::Redirect;
+      } else {
+        ASSERT(escaped_slashes_action ==
+               envoy::extensions::filters::network::http_connection_manager::v3::
+                   HttpConnectionManager::UNESCAPE_AND_FORWARD);
+      }
+    }
+   }
+
+  if (config.shouldNormalizePath() && !PathUtil::canonicalPath(request_headers)) {
+    return NormalizePathAction::Reject;
+  }
+
   // Merge slashes after path normalization to catch potential edge cases with percent encoding.
-  if (is_valid_path && config.shouldMergeSlashes()) {
+  if (config.shouldMergeSlashes()) {
     PathUtil::mergeSlashes(request_headers);
   }
-  return is_valid_path;
+  return final_action;
 }
 
 } // namespace Http
diff --git a/source/common/http/conn_manager_utility.h b/source/common/http/conn_manager_utility.h
index 2038111..74d8255 100644
--- a/source/common/http/conn_manager_utility.h
+++ b/source/common/http/conn_manager_utility.h
@@ -62,12 +62,18 @@ public:
                                     const RequestHeaderMap* request_headers,
                                     const RequestIDExtensionSharedPtr& rid_extension,
                                     const std::string& via);
+  
+  enum class NormalizePathAction {
+    Continue = 0,
+    Reject = 1,
+    Redirect = 2,
+  };
 
   // Sanitize the path in the header map if forced by config.
   // Side affect: the string view of Path header is invalidated.
-  // Return false if error happens during the sanitization.
-  static bool maybeNormalizePath(RequestHeaderMap& request_headers,
-                                 const ConnectionManagerConfig& config);
+  // Returns the action that should taken based on the results of path normalization.
+  static NormalizePathAction maybeNormalizePath(RequestHeaderMap& request_headers,
+                                                const ConnectionManagerConfig& config);
 
   /**
    * Mutate request headers if request needs to be traced.
diff --git a/source/common/http/path_utility.cc b/source/common/http/path_utility.cc
index cb93092..210e7e3 100644
--- a/source/common/http/path_utility.cc
+++ b/source/common/http/path_utility.cc
@@ -25,6 +25,16 @@ absl::optional<std::string> canonicalizePath(absl::string_view original_path) {
     return absl::make_optional(std::move(canonical_path));
   }
 }
+
+void unescapeInPath(std::string& path, absl::string_view escape_sequence,
+                    absl::string_view substitution) {
+  std::vector<absl::string_view> split = absl::StrSplit(path, escape_sequence);
+  if (split.size() == 1) {
+    return;
+  }
+  path = absl::StrJoin(split, substitution);
+}
+
 } // namespace
 
 /* static */
@@ -68,6 +78,31 @@ void PathUtil::mergeSlashes(RequestHeaderMap& headers) {
       prefix, absl::StrJoin(absl::StrSplit(path, '/', absl::SkipEmpty()), "/"), query, suffix));
 }
 
+PathUtil::UnescapeSlashesResult PathUtil::unescapeSlashes(RequestHeaderMap& headers) {
+  ASSERT(headers.Path());
+  const auto original_path = headers.getPathValue();
+  const auto original_length = original_path.length();
+  // Only operate on path component in URL.
+  const absl::string_view::size_type query_start = original_path.find('?');
+  const absl::string_view path = original_path.substr(0, query_start);
+  if (path.find('%') == absl::string_view::npos) {
+    return UnescapeSlashesResult::NotFound;
+  }
+  const absl::string_view query = absl::ClippedSubstr(original_path, query_start);
+
+  // TODO(yanavlasov): optimize this by adding case insensitive matcher
+  std::string decoded_path{path};
+  unescapeInPath(decoded_path, "%2F", "/");
+  unescapeInPath(decoded_path, "%2f", "/");
+  unescapeInPath(decoded_path, "%5C", "\\");
+  unescapeInPath(decoded_path, "%5c", "\\");
+  headers.setPath(absl::StrCat(decoded_path, query));
+  // Path length will not match if there were unescaped %2f or %5c
+  return headers.getPathValue().length() != original_length
+             ? UnescapeSlashesResult::FoundAndUnescaped
+             : UnescapeSlashesResult::NotFound;
+}
+
 absl::string_view PathUtil::removeQueryAndFragment(const absl::string_view path) {
   absl::string_view ret = path;
   // Trim query parameters and/or fragment if present.
diff --git a/source/common/http/path_utility.h b/source/common/http/path_utility.h
index 8df1581..60d5edd 100644
--- a/source/common/http/path_utility.h
+++ b/source/common/http/path_utility.h
@@ -17,6 +17,17 @@ public:
   static bool canonicalPath(RequestHeaderMap& headers);
   // Merges two or more adjacent slashes in path part of URI into one.
   static void mergeSlashes(RequestHeaderMap& headers);
+
+  enum class UnescapeSlashesResult {
+    // No escaped slash sequences were found and URL path has not been modified.
+    NotFound = 0,
+    // Escaped slash sequences were found and URL path has been modified.
+    FoundAndUnescaped = 1,
+  };
+  // Unescape %2F, %2f, %5C and %5c sequences.
+  // Requires the Path header be present.
+  // Returns the result of unescaping slashes.
+  static UnescapeSlashesResult unescapeSlashes(RequestHeaderMap& headers);
   // Removes the query and/or fragment string (if present) from the input path.
   // For example, this function returns "/data" for the input path "/data#fragment?param=value".
   static absl::string_view removeQueryAndFragment(const absl::string_view path);
diff --git a/source/extensions/filters/network/http_connection_manager/config.cc b/source/extensions/filters/network/http_connection_manager/config.cc
index ed10756..fa15906 100644
--- a/source/extensions/filters/network/http_connection_manager/config.cc
+++ b/source/extensions/filters/network/http_connection_manager/config.cc
@@ -72,6 +72,51 @@ std::unique_ptr<Http::InternalAddressConfig> createInternalAddressConfig(
   return std::make_unique<Http::DefaultInternalAddressConfig>();
 }
 
+envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager::
+    PathWithEscapedSlashesAction
+    getPathWithEscapedSlashesActionRuntimeOverride(Server::Configuration::FactoryContext& context) {
+  // The default behavior is to leave escaped slashes unchanged.
+  uint64_t runtime_override = context.runtime().snapshot().getInteger(
+      "http_connection_manager.path_with_escaped_slashes_action", 0);
+  switch (runtime_override) {
+  default:
+    // Also includes runtime override values of 0 and 1
+    return envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager::
+        KEEP_UNCHANGED;
+  case 2:
+    return envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager::
+        REJECT_REQUEST;
+  case 3:
+    return envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager::
+        UNESCAPE_AND_REDIRECT;
+  case 4:
+    return envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager::
+        UNESCAPE_AND_FORWARD;
+  }
+}
+
+envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager::
+    PathWithEscapedSlashesAction
+    getPathWithEscapedSlashesAction(const envoy::extensions::filters::network::
+                                        http_connection_manager::v3::HttpConnectionManager& config,
+                                    Server::Configuration::FactoryContext& context) {
+  envoy::type::v3::FractionalPercent default_fraction;
+  default_fraction.set_numerator(100);
+  default_fraction.set_denominator(envoy::type::v3::FractionalPercent::HUNDRED);
+  if (context.runtime().snapshot().featureEnabled(
+          "http_connection_manager.path_with_escaped_slashes_action_enabled", default_fraction)) {
+    return config.path_with_escaped_slashes_action() ==
+                   envoy::extensions::filters::network::http_connection_manager::v3::
+                       HttpConnectionManager::IMPLEMENTATION_SPECIFIC_DEFAULT
+               ? getPathWithEscapedSlashesActionRuntimeOverride(context)
+               : config.path_with_escaped_slashes_action();
+  }
+
+  // When action is disabled through runtime the behavior is to keep escaped slashes unchanged.
+  return envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager::
+      KEEP_UNCHANGED;
+}
+
 } // namespace
 
 // Singleton registration via macro defined in envoy/singleton/manager.h
@@ -217,6 +262,8 @@ HttpConnectionManagerConfig::HttpConnectionManagerConfig(
       merge_slashes_(config.merge_slashes()),
       headers_with_underscores_action_(
           config.common_http_protocol_options().headers_with_underscores_action()) {
+      local_reply_(LocalReply::Factory::create(config.local_reply_config(), context)),
+      path_with_escaped_slashes_action_(getPathWithEscapedSlashesAction(config, context)) {
   // If idle_timeout_ was not configured in common_http_protocol_options, use value in deprecated
   // idle_timeout field.
   // TODO(asraa): Remove when idle_timeout is removed.
diff --git a/source/extensions/filters/network/http_connection_manager/config.h b/source/extensions/filters/network/http_connection_manager/config.h
index 59dee76..ab6468b 100644
--- a/source/extensions/filters/network/http_connection_manager/config.h
+++ b/source/extensions/filters/network/http_connection_manager/config.h
@@ -161,6 +161,11 @@ public:
     return headers_with_underscores_action_;
   }
   std::chrono::milliseconds delayedCloseTimeout() const override { return delayed_close_timeout_; }
+  envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager::
+      PathWithEscapedSlashesAction
+      pathWithEscapedSlashesAction() const override {
+    return path_with_escaped_slashes_action_;
+  }
 
 private:
   enum class CodecType { HTTP1, HTTP2, HTTP3, AUTO };
@@ -229,6 +234,8 @@ private:
   static const uint64_t StreamIdleTimeoutMs = 5 * 60 * 1000;
   // request timeout is disabled by default
   static const uint64_t RequestTimeoutMs = 0;
+  const envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager::
+      PathWithEscapedSlashesAction path_with_escaped_slashes_action_;
 };
 
 /**

diff --git a/source/server/http/admin.h b/source/server/http/admin.h
index 536bfb6..0535ab9 100644
--- a/source/server/http/admin.h
+++ b/source/server/http/admin.h
@@ -167,6 +167,12 @@ public:
   headersWithUnderscoresAction() const override {
     return envoy::config::core::v3::HttpProtocolOptions::ALLOW;
   }
+  envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager::
+      PathWithEscapedSlashesAction
+      pathWithEscapedSlashesAction() const override {
+    return envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager::
+        KEEP_UNCHANGED;
+  }
   Http::Code request(absl::string_view path_and_query, absl::string_view method,
                      Http::ResponseHeaderMap& response_headers, std::string& body) override;
   void closeSocket();
diff --git a/test/common/http/conn_manager_impl_fuzz_test.cc b/test/common/http/conn_manager_impl_fuzz_test.cc
index 38d471d..cdca572 100644
--- a/test/common/http/conn_manager_impl_fuzz_test.cc
+++ b/test/common/http/conn_manager_impl_fuzz_test.cc
@@ -159,6 +159,12 @@ public:
   headersWithUnderscoresAction() const override {
     return envoy::config::core::v3::HttpProtocolOptions::ALLOW;
   }
+  envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager::
+      PathWithEscapedSlashesAction
+      pathWithEscapedSlashesAction() const override {
+    return envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager::
+        KEEP_UNCHANGED;
+  }
 
   const envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager
       config_;
diff --git a/test/common/http/conn_manager_impl_test.cc b/test/common/http/conn_manager_impl_test.cc
index 3cd0c0c..b09b54f 100644
--- a/test/common/http/conn_manager_impl_test.cc
+++ b/test/common/http/conn_manager_impl_test.cc
@@ -283,6 +283,31 @@ public:
     EXPECT_CALL(filter_callbacks_.connection_.dispatcher_, deferredDelete_(_));
   }
 
+  void testPathNormalization(const RequestHeaderMap& request_headers,
+                             const ResponseHeaderMap& expected_response) {
+    InSequence s;
+    setup(false, "");
+
+    EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance& data) -> Http::Status {
+      RequestDecoder* decoder = &conn_manager_->newStream(response_encoder_);
+      RequestHeaderMapPtr headers{std::make_unique<TestRequestHeaderMapImpl>(request_headers)};
+      decoder->decodeHeaders(std::move(headers), true);
+      data.drain(4);
+      return Http::okStatus();
+    }));
+
+    EXPECT_CALL(response_encoder_, encodeHeaders(_, true))
+        .WillOnce(Invoke([&](const ResponseHeaderMap& headers, bool) -> void {
+          TestResponseHeaderMapImpl copy{headers};
+          copy.remove(Envoy::Http::LowerCaseString{"date"});
+          copy.remove(Envoy::Http::LowerCaseString{"server"});
+          EXPECT_THAT(&copy, HeaderMapEqualIgnoreOrder(&expected_response));
+        }));
+
+    Buffer::OwnedImpl fake_input("1234");
+    conn_manager_->onData(fake_input, false);
+  }
+
   // Http::ConnectionManagerConfig
   const std::list<AccessLog::InstanceSharedPtr>& accessLogs() override { return access_logs_; }
   ServerConnectionPtr createCodec(Network::Connection&, const Buffer::Instance&,
@@ -352,6 +377,11 @@ public:
   headersWithUnderscoresAction() const override {
     return headers_with_underscores_action_;
   }
+  envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager::
+     PathWithEscapedSlashesAction
+      pathWithEscapedSlashesAction() const override {
+    return path_with_escaped_slashes_action_;
+  }
 
   Envoy::Event::SimulatedTimeSystem test_time_;
   NiceMock<Router::MockRouteConfigProvider> route_config_provider_;
@@ -413,6 +443,10 @@ public:
   NiceMock<Network::MockClientConnection> upstream_conn_; // for websocket tests
   NiceMock<Tcp::ConnectionPool::MockInstance> conn_pool_; // for websocket tests
   RequestIDExtensionSharedPtr request_id_extension_;
+  envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager::
+      PathWithEscapedSlashesAction path_with_escaped_slashes_action_{
+          envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager::
+              KEEP_UNCHANGED};
 
   // TODO(mattklein123): Not all tests have been converted over to better setup. Convert the rest.
   MockResponseEncoder response_encoder_;
@@ -822,6 +856,100 @@ TEST_F(HttpConnectionManagerImplTest, RouteShouldUseSantizedPath) {
   conn_manager_->onData(fake_input, false);
 }
 
+// Paths with escaped slashes rejected with 400 when configured.
+TEST_F(HttpConnectionManagerImplTest, PathWithEscapedSlashesRejected) {
+  path_with_escaped_slashes_action_ = envoy::extensions::filters::network::http_connection_manager::
+      v3::HttpConnectionManager::REJECT_REQUEST;
+  testPathNormalization(
+      TestRequestHeaderMapImpl{{":authority", "host"}, {":path", "/abc%5c../"}, {":method", "GET"}},
+      TestResponseHeaderMapImpl{{":status", "400"}});
+  EXPECT_EQ(1U, stats_.named_.downstream_rq_failed_path_normalization_.value());
+}
+
+// Paths with escaped slashes redirected when configured.
+TEST_F(HttpConnectionManagerImplTest, PathWithEscapedSlashesRedirected) {
+  path_with_escaped_slashes_action_ = envoy::extensions::filters::network::http_connection_manager::
+      v3::HttpConnectionManager::UNESCAPE_AND_REDIRECT;
+  testPathNormalization(
+      TestRequestHeaderMapImpl{{":authority", "host"}, {":path", "/abc%2f../"}, {":method", "GET"}},
+      TestResponseHeaderMapImpl{{":status", "307"}, {"location", "/abc/../"}});
+  EXPECT_EQ(1U, stats_.named_.downstream_rq_redirected_with_normalized_path_.value());
+}
+
+// Paths with escaped slashes rejected with 400 instead of redirected for gRPC request.
+TEST_F(HttpConnectionManagerImplTest, PathWithEscapedSlashesRejectedIfGRPC) {
+  // This test is slightly weird as it sends gRPC "request" over H/1 client of the
+  // HttpConnectionManagerImplTest. However it is sufficient to test the behavior of path
+  // normalization as it is determined by the content type only.
+  path_with_escaped_slashes_action_ = envoy::extensions::filters::network::http_connection_manager::
+      v3::HttpConnectionManager::UNESCAPE_AND_REDIRECT;
+  testPathNormalization(TestRequestHeaderMapImpl{{":authority", "host"},
+                                                 {":path", "/abc%2fdef"},
+                                                 {":method", "GET"},
+                                                 {"content-type", "application/grpc"}},
+                        TestResponseHeaderMapImpl{{":status", "200"},
+                                                  {"grpc-status", "13"},
+                                                  {"content-type", "application/grpc"}});
+  EXPECT_EQ(1U, stats_.named_.downstream_rq_failed_path_normalization_.value());
+}
+
+// Test that requests with escaped slashes are redirected when configured. Redirection
+// occurs after Chromium URL normalization or merge slashes operations.
+TEST_F(HttpConnectionManagerImplTest, EscapedSlashesRedirectedAfterOtherNormalizations) {
+  normalize_path_ = true;
+  merge_slashes_ = true;
+  path_with_escaped_slashes_action_ = envoy::extensions::filters::network::http_connection_manager::
+      v3::HttpConnectionManager::UNESCAPE_AND_REDIRECT;
+  // Both Chromium URL normalization and merge slashes should happen if request is redirected
+  // due to escaped slash sequences.
+  testPathNormalization(TestRequestHeaderMapImpl{{":authority", "host"},
+                                                 {":path", "/abc%2f../%5cdef//"},
+                                                 {":method", "GET"}},
+                        TestResponseHeaderMapImpl{{":status", "307"}, {"location", "/def/"}});
+  EXPECT_EQ(1U, stats_.named_.downstream_rq_redirected_with_normalized_path_.value());
+}
+
+TEST_F(HttpConnectionManagerImplTest, AllNormalizationsWithEscapedSlashesForwarded) {
+  setup(false, "");
+  // Enable path sanitizer
+  normalize_path_ = true;
+  merge_slashes_ = true;
+  path_with_escaped_slashes_action_ = envoy::extensions::filters::network::http_connection_manager::
+      v3::HttpConnectionManager::UNESCAPE_AND_FORWARD;
+  const std::string original_path = "/x/%2E%2e/z%2f%2Fabc%5C../def";
+  const std::string normalized_path = "/z/def";
+
+  auto* filter = new MockStreamFilter();
+
+  EXPECT_CALL(filter_factory_, createFilterChain(_))
+      .WillOnce(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {
+        callbacks.addStreamDecoderFilter(StreamDecoderFilterSharedPtr{filter});
+      }));
+
+  EXPECT_CALL(*filter, decodeHeaders(_, true))
+      .WillRepeatedly(Invoke([&](RequestHeaderMap& header_map, bool) -> FilterHeadersStatus {
+        EXPECT_EQ(normalized_path, header_map.getPathValue());
+        return FilterHeadersStatus::StopIteration;
+      }));
+
+  EXPECT_CALL(*filter, setDecoderFilterCallbacks(_));
+
+  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> Http::Status {
+    RequestDecoder* decoder = &conn_manager_->newStream(response_encoder_);
+    RequestHeaderMapPtr headers{new TestRequestHeaderMapImpl{
+        {":authority", "host"}, {":path", original_path}, {":method", "GET"}}};
+    decoder->decodeHeaders(std::move(headers), true);
+    return Http::okStatus();
+  }));
+
+  // Kick off the incoming data.
+  Buffer::OwnedImpl fake_input("1234");
+  conn_manager_->onData(fake_input, false);
+
+  EXPECT_CALL(*filter, onDestroy());
+  filter_callbacks_.connection_.raiseEvent(Network::ConnectionEvent::RemoteClose);
+}
+
 TEST_F(HttpConnectionManagerImplTest, StartAndFinishSpanNormalFlow) {
   setup(false, "");

diff --git a/test/common/http/conn_manager_utility_test.cc b/test/common/http/conn_manager_utility_test.cc
index 60ece5b..0011256 100644
--- a/test/common/http/conn_manager_utility_test.cc
+++ b/test/common/http/conn_manager_utility_test.cc
@@ -136,6 +136,9 @@ public:
   MOCK_METHOD(bool, shouldMergeSlashes, (), (const));
   MOCK_METHOD(envoy::config::core::v3::HttpProtocolOptions::HeadersWithUnderscoresAction,
               headersWithUnderscoresAction, (), (const));
+  MOCK_METHOD(envoy::extensions::filters::network::http_connection_manager::v3::
+                  HttpConnectionManager::PathWithEscapedSlashesAction,
+              pathWithEscapedSlashesAction, (), (const));
 
   std::unique_ptr<Http::InternalAddressConfig> internal_address_config_ =
       std::make_unique<DefaultInternalAddressConfig>();
@@ -163,6 +166,9 @@ public:
 
     ON_CALL(config_, via()).WillByDefault(ReturnRef(via_));
     ON_CALL(config_, requestIDExtension()).WillByDefault(Return(request_id_extension_));
+    ON_CALL(config_, pathWithEscapedSlashesAction())
+        .WillByDefault(Return(envoy::extensions::filters::network::http_connection_manager::v3::
+                                  HttpConnectionManager::KEEP_UNCHANGED));
   }
 
   struct MutateRequestRet {
@@ -1425,6 +1431,177 @@ TEST_F(ConnectionManagerUtilityTest, MergeSlashesWithoutNormalization) {
   EXPECT_EQ(header_map.Path()->value().getStringView(), "/xyz/../abc");
 }
 
+// maybeNormalizePath() does not touch escaped slashes when configured to KEEP_UNCHANGED.
+TEST_F(ConnectionManagerUtilityTest, KeepEscapedSlashesWhenConfigured) {
+  ON_CALL(config_, pathWithEscapedSlashesAction())
+      .WillByDefault(Return(envoy::extensions::filters::network::http_connection_manager::v3::
+                                HttpConnectionManager::KEEP_UNCHANGED));
+  TestRequestHeaderMapImpl original_headers;
+  original_headers.setPath("/xyz%2fabc%5Cqrt");
+
+  TestRequestHeaderMapImpl header_map(original_headers);
+  EXPECT_EQ(ConnectionManagerUtility::NormalizePathAction::Continue,
+            ConnectionManagerUtility::maybeNormalizePath(header_map, config_));
+  EXPECT_EQ(header_map.getPathValue(), "/xyz%2fabc%5Cqrt");
+}
+
+// maybeNormalizePath() returns REJECT if %2F or %5C was detected and configured to REJECT.
+TEST_F(ConnectionManagerUtilityTest, RejectIfEscapedSlashesPresentAndConfiguredToReject) {
+  ON_CALL(config_, pathWithEscapedSlashesAction())
+      .WillByDefault(Return(envoy::extensions::filters::network::http_connection_manager::v3::
+                                HttpConnectionManager::REJECT_REQUEST));
+  TestRequestHeaderMapImpl original_headers;
+  original_headers.setPath("/xyz%2F..//abc");
+
+  TestRequestHeaderMapImpl header_map(original_headers);
+  EXPECT_EQ(ConnectionManagerUtility::NormalizePathAction::Reject,
+            ConnectionManagerUtility::maybeNormalizePath(header_map, config_));
+
+  original_headers.setPath("/xyz%5c..//abc");
+  header_map = original_headers;
+  EXPECT_EQ(ConnectionManagerUtility::NormalizePathAction::Reject,
+            ConnectionManagerUtility::maybeNormalizePath(header_map, config_));
+}
+
+// maybeNormalizePath() returns CONTINUE if escaped slashes were NOT present and configured to
+// REJECT.
+TEST_F(ConnectionManagerUtilityTest, RejectIfEscapedSlashesNotPresentAndConfiguredToReject) {
+  ON_CALL(config_, pathWithEscapedSlashesAction())
+      .WillByDefault(Return(envoy::extensions::filters::network::http_connection_manager::v3::
+                                HttpConnectionManager::REJECT_REQUEST));
+  TestRequestHeaderMapImpl original_headers;
+  original_headers.setPath("/xyz%EA/abc");
+
+  TestRequestHeaderMapImpl header_map(original_headers);
+  EXPECT_EQ(ConnectionManagerUtility::NormalizePathAction::Continue,
+            ConnectionManagerUtility::maybeNormalizePath(header_map, config_));
+  EXPECT_EQ(header_map.getPathValue(), "/xyz%EA/abc");
+}
+
+// maybeNormalizePath() returns REDIRECT if escaped slashes were detected and configured to
+// REDIRECT.
+TEST_F(ConnectionManagerUtilityTest, RedirectIfEscapedSlashesPresentAndConfiguredToRedirect) {
+  ON_CALL(config_, pathWithEscapedSlashesAction())
+      .WillByDefault(Return(envoy::extensions::filters::network::http_connection_manager::v3::
+                                HttpConnectionManager::UNESCAPE_AND_REDIRECT));
+  TestRequestHeaderMapImpl original_headers;
+  original_headers.setPath("/xyz%2F../%5cabc");
+
+  TestRequestHeaderMapImpl header_map(original_headers);
+  EXPECT_EQ(ConnectionManagerUtility::NormalizePathAction::Redirect,
+            ConnectionManagerUtility::maybeNormalizePath(header_map, config_));
+  EXPECT_EQ(header_map.getPathValue(), "/xyz/../\\abc");
+}
+
+// maybeNormalizePath() returns CONTINUE if escaped slashes were NOT present and configured to
+// REDIRECT.
+TEST_F(ConnectionManagerUtilityTest, ContinueIfEscapedSlashesNotFoundAndConfiguredToRedirect) {
+  ON_CALL(config_, pathWithEscapedSlashesAction())
+      .WillByDefault(Return(envoy::extensions::filters::network::http_connection_manager::v3::
+                                HttpConnectionManager::UNESCAPE_AND_REDIRECT));
+  TestRequestHeaderMapImpl original_headers;
+  original_headers.setPath("/xyz%30..//abc");
+
+  TestRequestHeaderMapImpl header_map(original_headers);
+  EXPECT_EQ(ConnectionManagerUtility::NormalizePathAction::Continue,
+            ConnectionManagerUtility::maybeNormalizePath(header_map, config_));
+  EXPECT_EQ(header_map.getPathValue(), "/xyz%30..//abc");
+}
+
+// maybeNormalizePath() returns CONTINUE if escaped slashes were detected and configured to
+// UNESCAPE_AND_FORWARD.
+TEST_F(ConnectionManagerUtilityTest, ContinueIfEscapedSlashesPresentAndConfiguredToUnescape) {
+  ON_CALL(config_, pathWithEscapedSlashesAction())
+      .WillByDefault(Return(envoy::extensions::filters::network::http_connection_manager::v3::
+                                HttpConnectionManager::UNESCAPE_AND_FORWARD));
+  TestRequestHeaderMapImpl original_headers;
+  original_headers.setPath("/xyz%2F../%5Cabc");
+
+  TestRequestHeaderMapImpl header_map(original_headers);
+  EXPECT_EQ(ConnectionManagerUtility::NormalizePathAction::Continue,
+            ConnectionManagerUtility::maybeNormalizePath(header_map, config_));
+  EXPECT_EQ(header_map.getPathValue(), "/xyz/../\\abc");
+}
+
+// maybeNormalizePath() performs both slash unescaping and Chromium URL normalization.
+TEST_F(ConnectionManagerUtilityTest, UnescapeSlashesAndChromiumNormalization) {
+  ON_CALL(config_, shouldNormalizePath()).WillByDefault(Return(true));
+  ON_CALL(config_, pathWithEscapedSlashesAction())
+      .WillByDefault(Return(envoy::extensions::filters::network::http_connection_manager::v3::
+                                HttpConnectionManager::UNESCAPE_AND_FORWARD));
+  TestRequestHeaderMapImpl original_headers;
+  original_headers.setPath("/xyz%2f../%5Cabc");
+
+  TestRequestHeaderMapImpl header_map(original_headers);
+  EXPECT_EQ(ConnectionManagerUtility::NormalizePathAction::Continue,
+            ConnectionManagerUtility::maybeNormalizePath(header_map, config_));
+  // Chromium URL path normalization converts \ to /
+  EXPECT_EQ(header_map.getPathValue(), "//abc");
+}
+
+// maybeNormalizePath() rejects request when chromium normalization fails after unescaping slashes.
+TEST_F(ConnectionManagerUtilityTest, UnescapeSlashesRedirectAndChromiumNormalizationFailure) {
+  ON_CALL(config_, shouldNormalizePath()).WillByDefault(Return(true));
+  ON_CALL(config_, pathWithEscapedSlashesAction())
+      .WillByDefault(Return(envoy::extensions::filters::network::http_connection_manager::v3::
+                                HttpConnectionManager::UNESCAPE_AND_REDIRECT));
+  TestRequestHeaderMapImpl original_headers;
+  // %00 is an invalid sequence in URL path and causes path normalization to fail.
+  original_headers.setPath("/xyz%2f../%5Cabc%00");
+
+  TestRequestHeaderMapImpl header_map(original_headers);
+  EXPECT_EQ(ConnectionManagerUtility::NormalizePathAction::Reject,
+            ConnectionManagerUtility::maybeNormalizePath(header_map, config_));
+}
+
+// maybeNormalizePath() performs both unescaping and merging slashes when configured.
+TEST_F(ConnectionManagerUtilityTest, UnescapeAndMergeSlashes) {
+  ON_CALL(config_, shouldMergeSlashes()).WillByDefault(Return(true));
+  ON_CALL(config_, pathWithEscapedSlashesAction())
+      .WillByDefault(Return(envoy::extensions::filters::network::http_connection_manager::v3::
+                                HttpConnectionManager::UNESCAPE_AND_REDIRECT));
+  TestRequestHeaderMapImpl original_headers;
+  original_headers.setPath("/xyz%2f/..//abc%5C%5c");
+
+  TestRequestHeaderMapImpl header_map(original_headers);
+  EXPECT_EQ(ConnectionManagerUtility::NormalizePathAction::Redirect,
+            ConnectionManagerUtility::maybeNormalizePath(header_map, config_));
+  // Envoy does not merge back slashes
+  EXPECT_EQ(header_map.getPathValue(), "/xyz/../abc\\\\");
+}
+
+// maybeNormalizePath() performs all path transformations.
+TEST_F(ConnectionManagerUtilityTest, AllNormalizations) {
+  ON_CALL(config_, shouldNormalizePath()).WillByDefault(Return(true));
+  ON_CALL(config_, shouldMergeSlashes()).WillByDefault(Return(true));
+  ON_CALL(config_, pathWithEscapedSlashesAction())
+      .WillByDefault(Return(envoy::extensions::filters::network::http_connection_manager::v3::
+                                HttpConnectionManager::UNESCAPE_AND_FORWARD));
+  TestRequestHeaderMapImpl original_headers;
+  original_headers.setPath("/xyz%2f..%5c/%2Fabc");
+
+  TestRequestHeaderMapImpl header_map(original_headers);
+  EXPECT_EQ(ConnectionManagerUtility::NormalizePathAction::Continue,
+            ConnectionManagerUtility::maybeNormalizePath(header_map, config_));
+  EXPECT_EQ(header_map.getPathValue(), "/abc");
+}
+
+// maybeNormalizePath() redirects because of escaped slashes after all other transformations.
+TEST_F(ConnectionManagerUtilityTest, RedirectAfterAllOtherNormalizations) {
+  ON_CALL(config_, shouldNormalizePath()).WillByDefault(Return(true));
+  ON_CALL(config_, shouldMergeSlashes()).WillByDefault(Return(true));
+  ON_CALL(config_, pathWithEscapedSlashesAction())
+      .WillByDefault(Return(envoy::extensions::filters::network::http_connection_manager::v3::
+                                HttpConnectionManager::UNESCAPE_AND_REDIRECT));
+  TestRequestHeaderMapImpl original_headers;
+  original_headers.setPath("/xyz%2f..%5c/%2Fabc");
+
+  TestRequestHeaderMapImpl header_map(original_headers);
+  EXPECT_EQ(ConnectionManagerUtility::NormalizePathAction::Redirect,
+            ConnectionManagerUtility::maybeNormalizePath(header_map, config_));
+  EXPECT_EQ(header_map.getPathValue(), "/abc");
+}
+
 // test preserve_external_request_id true does not reset the passed requestId if passed
 TEST_F(ConnectionManagerUtilityTest, PreserveExternalRequestId) {
   connection_.remote_address_ = std::make_shared<Network::Address::Ipv4Instance>("134.2.2.11");
diff --git a/test/common/http/path_utility_test.cc b/test/common/http/path_utility_test.cc
index 0cd17e3..38a2931 100644
--- a/test/common/http/path_utility_test.cc
+++ b/test/common/http/path_utility_test.cc
@@ -1,3 +1,4 @@
+#include <tuple>
 #include <utility>
 #include <vector>
 
@@ -127,5 +128,59 @@ TEST_F(PathUtilityTest, RemoveQueryAndFragment) {
   EXPECT_EQ("/abc", PathUtil::removeQueryAndFragment("/abc?param=value#fragment"));
 }
 
+TEST_F(PathUtilityTest, UnescapeSlashes) {
+  using UnescapeResult = std::tuple<std::string, PathUtil::UnescapeSlashesResult>;
+  auto unescapeSlashes = [this](const std::string& path_value) {
+    auto& path_header = pathHeaderEntry(path_value);
+    auto result = PathUtil::unescapeSlashes(headers_);
+    auto sanitized_path_value = path_header.value().getStringView();
+    return UnescapeResult(std::string(sanitized_path_value), result);
+  };
+  EXPECT_EQ(UnescapeResult("", PathUtil::UnescapeSlashesResult::NotFound),
+            unescapeSlashes("")); // empty
+  EXPECT_EQ(UnescapeResult("//", PathUtil::UnescapeSlashesResult::FoundAndUnescaped),
+            unescapeSlashes("%2f%2F")); // case-insensitive
+  EXPECT_EQ(UnescapeResult("/a/b/c/", PathUtil::UnescapeSlashesResult::FoundAndUnescaped),
+            unescapeSlashes("/a%2Fb%2fc/")); // between other characters
+  EXPECT_EQ(UnescapeResult("%2b", PathUtil::UnescapeSlashesResult::NotFound),
+            unescapeSlashes("%2b")); // not %2f
+  EXPECT_EQ(UnescapeResult("/a/b/c", PathUtil::UnescapeSlashesResult::NotFound),
+            unescapeSlashes("/a/b/c")); // not %2f
+  EXPECT_EQ(UnescapeResult("%2", PathUtil::UnescapeSlashesResult::NotFound),
+            unescapeSlashes("%2")); // incomplete
+  EXPECT_EQ(UnescapeResult("%", PathUtil::UnescapeSlashesResult::NotFound),
+            unescapeSlashes("%")); // incomplete
+  EXPECT_EQ(UnescapeResult("/abc%2", PathUtil::UnescapeSlashesResult::NotFound),
+            unescapeSlashes("/abc%2")); // incomplete
+  EXPECT_EQ(UnescapeResult("foo%", PathUtil::UnescapeSlashesResult::NotFound),
+            unescapeSlashes("foo%")); // incomplete
+  EXPECT_EQ(UnescapeResult("/a/", PathUtil::UnescapeSlashesResult::FoundAndUnescaped),
+            unescapeSlashes("/a%2F")); // prefixed
+  EXPECT_EQ(UnescapeResult("/a/", PathUtil::UnescapeSlashesResult::FoundAndUnescaped),
+            unescapeSlashes("%2fa/")); // suffixed
+  EXPECT_EQ(UnescapeResult("%/a/", PathUtil::UnescapeSlashesResult::FoundAndUnescaped),
+            unescapeSlashes("%%2fa/")); // double escape
+  EXPECT_EQ(UnescapeResult("%2/a/", PathUtil::UnescapeSlashesResult::FoundAndUnescaped),
+            unescapeSlashes("%2%2fa/")); // incomplete escape
+
+  EXPECT_EQ(UnescapeResult("\\\\", PathUtil::UnescapeSlashesResult::FoundAndUnescaped),
+            unescapeSlashes("%5c%5C")); // case-insensitive
+  EXPECT_EQ(UnescapeResult("/a\\b\\c/", PathUtil::UnescapeSlashesResult::FoundAndUnescaped),
+            unescapeSlashes("/a%5Cb%5cc/")); // between other characters
+  EXPECT_EQ(UnescapeResult("/a\\", PathUtil::UnescapeSlashesResult::FoundAndUnescaped),
+            unescapeSlashes("/a%5C")); // prefixed
+  EXPECT_EQ(UnescapeResult("\\a/", PathUtil::UnescapeSlashesResult::FoundAndUnescaped),
+            unescapeSlashes("%5ca/")); // suffixed
+  EXPECT_EQ(UnescapeResult("/x/%2E%2e/z//abc\\../def",
+                           PathUtil::UnescapeSlashesResult::FoundAndUnescaped),
+            unescapeSlashes("/x/%2E%2e/z%2f%2Fabc%5C../def"));
+
+  EXPECT_EQ(UnescapeResult("/a\\b/c\\", PathUtil::UnescapeSlashesResult::FoundAndUnescaped),
+            unescapeSlashes("%2fa%5Cb%2fc%5c")); // %5c and %2f together
+  EXPECT_EQ(UnescapeResult("/a\\b/c\\?%2fabcd%5C%%2f%",
+                           PathUtil::UnescapeSlashesResult::FoundAndUnescaped),
+            unescapeSlashes("%2fa%5Cb%2fc%5c?%2fabcd%5C%%2f%")); // query is untouched
+}
+
 } // namespace Http
 } // namespace Envoy
diff --git a/test/extensions/filters/network/http_connection_manager/config_test.cc b/test/extensions/filters/network/http_connection_manager/config_test.cc
index 54b4382..1771e5d 100644
--- a/test/extensions/filters/network/http_connection_manager/config_test.cc
+++ b/test/extensions/filters/network/http_connection_manager/config_test.cc
@@ -24,6 +24,7 @@
 
 using testing::_;
 using testing::An;
+using testing::AnyNumber;
 using testing::Eq;
 using testing::NotNull;
 using testing::Pointee;
@@ -768,8 +769,8 @@ TEST_F(HttpConnectionManagerConfigTest, ServerOverwrite) {
   )EOF";
 
   EXPECT_CALL(context_.runtime_loader_.snapshot_, featureEnabled(_, An<uint64_t>()))
-      .WillOnce(Invoke(&context_.runtime_loader_.snapshot_,
-                       &Runtime::MockSnapshot::featureEnabledDefault));
+      .WillRepeatedly(Invoke(&context_.runtime_loader_.snapshot_,
+                             &Runtime::MockSnapshot::featureEnabledDefault));
   HttpConnectionManagerConfig config(parseHttpConnectionManagerFromV2Yaml(yaml_string), context_,
                                      date_provider_, route_config_provider_manager_,
                                      scoped_routes_config_provider_manager_, http_tracer_manager_);
@@ -788,8 +789,8 @@ TEST_F(HttpConnectionManagerConfigTest, ServerAppendIfAbsent) {
   )EOF";
 
   EXPECT_CALL(context_.runtime_loader_.snapshot_, featureEnabled(_, An<uint64_t>()))
-      .WillOnce(Invoke(&context_.runtime_loader_.snapshot_,
-                       &Runtime::MockSnapshot::featureEnabledDefault));
+      .WillRepeatedly(Invoke(&context_.runtime_loader_.snapshot_,
+                             &Runtime::MockSnapshot::featureEnabledDefault));
   HttpConnectionManagerConfig config(parseHttpConnectionManagerFromV2Yaml(yaml_string), context_,
                                      date_provider_, route_config_provider_manager_,
                                      scoped_routes_config_provider_manager_, http_tracer_manager_);
@@ -808,8 +809,8 @@ TEST_F(HttpConnectionManagerConfigTest, ServerPassThrough) {
   )EOF";
 
   EXPECT_CALL(context_.runtime_loader_.snapshot_, featureEnabled(_, An<uint64_t>()))
-      .WillOnce(Invoke(&context_.runtime_loader_.snapshot_,
-                       &Runtime::MockSnapshot::featureEnabledDefault));
+      .WillRepeatedly(Invoke(&context_.runtime_loader_.snapshot_,
+                             &Runtime::MockSnapshot::featureEnabledDefault));
   HttpConnectionManagerConfig config(parseHttpConnectionManagerFromV2Yaml(yaml_string), context_,
                                      date_provider_, route_config_provider_manager_,
                                      scoped_routes_config_provider_manager_, http_tracer_manager_);
@@ -829,8 +830,8 @@ TEST_F(HttpConnectionManagerConfigTest, NormalizePathDefault) {
   )EOF";
 
   EXPECT_CALL(context_.runtime_loader_.snapshot_, featureEnabled(_, An<uint64_t>()))
-      .WillOnce(Invoke(&context_.runtime_loader_.snapshot_,
-                       &Runtime::MockSnapshot::featureEnabledDefault));
+      .WillRepeatedly(Invoke(&context_.runtime_loader_.snapshot_,
+                             &Runtime::MockSnapshot::featureEnabledDefault));
   HttpConnectionManagerConfig config(parseHttpConnectionManagerFromV2Yaml(yaml_string), context_,
                                      date_provider_, route_config_provider_manager_,
                                      scoped_routes_config_provider_manager_, http_tracer_manager_);
@@ -851,9 +852,9 @@ TEST_F(HttpConnectionManagerConfigTest, NormalizePathRuntime) {
   - name: envoy.filters.http.router
   )EOF";
 
-  EXPECT_CALL(context_.runtime_loader_.snapshot_,
-              featureEnabled("http_connection_manager.normalize_path", An<uint64_t>()))
-      .WillOnce(Return(true));
+  EXPECT_CALL(context_.runtime_loader_.snapshot_, featureEnabled(_, An<uint64_t>()))
+      .WillRepeatedly(Invoke(&context_.runtime_loader_.snapshot_,
+                             &Runtime::MockSnapshot::featureEnabledDefault));
   HttpConnectionManagerConfig config(parseHttpConnectionManagerFromV2Yaml(yaml_string), context_,
                                      date_provider_, route_config_provider_manager_,
                                      scoped_routes_config_provider_manager_, http_tracer_manager_);
@@ -871,9 +872,9 @@ TEST_F(HttpConnectionManagerConfigTest, NormalizePathTrue) {
   - name: envoy.filters.http.router
   )EOF";
 
-  EXPECT_CALL(context_.runtime_loader_.snapshot_,
-              featureEnabled("http_connection_manager.normalize_path", An<uint64_t>()))
-      .Times(0);
+  EXPECT_CALL(context_.runtime_loader_.snapshot_, featureEnabled(_, An<uint64_t>()))
+      .WillRepeatedly(Invoke(&context_.runtime_loader_.snapshot_,
+                             &Runtime::MockSnapshot::featureEnabledDefault));
   HttpConnectionManagerConfig config(parseHttpConnectionManagerFromV2Yaml(yaml_string), context_,
                                      date_provider_, route_config_provider_manager_,
                                      scoped_routes_config_provider_manager_, http_tracer_manager_);
@@ -891,9 +892,9 @@ TEST_F(HttpConnectionManagerConfigTest, NormalizePathFalse) {
   - name: envoy.filters.http.router
   )EOF";
 
-  EXPECT_CALL(context_.runtime_loader_.snapshot_,
-              featureEnabled("http_connection_manager.normalize_path", An<uint64_t>()))
-      .Times(0);
+  EXPECT_CALL(context_.runtime_loader_.snapshot_, featureEnabled(_, An<uint64_t>()))
+     .WillRepeatedly(Invoke(&context_.runtime_loader_.snapshot_,
+                             &Runtime::MockSnapshot::featureEnabledDefault));
   HttpConnectionManagerConfig config(parseHttpConnectionManagerFromV2Yaml(yaml_string), context_,
                                      date_provider_, route_config_provider_manager_,
                                      scoped_routes_config_provider_manager_, http_tracer_manager_);
@@ -1739,6 +1740,156 @@ TEST_F(FilterChainTest, InvalidConfig) {
       EnvoyException, "Error: multiple upgrade configs with the same name: 'websocket'");
 }
 
+TEST_F(HttpConnectionManagerConfigTest, PathWithEscapedSlashesActionDefault) {
+  const std::string yaml_string = R"EOF(
+  stat_prefix: ingress_http
+  route_config:
+    name: local_route
+  http_filters:
+  - name: envoy.filters.http.router
+  )EOF";
+
+  EXPECT_CALL(context_.runtime_loader_.snapshot_,
+              featureEnabled(_, An<const envoy::type::v3::FractionalPercent&>()))
+      .WillOnce(Return(true));
+  EXPECT_CALL(context_.runtime_loader_.snapshot_, getInteger(_, _)).Times(AnyNumber());
+  EXPECT_CALL(context_.runtime_loader_.snapshot_,
+              getInteger("http_connection_manager.path_with_escaped_slashes_action", 0))
+      .WillOnce(Return(0));
+  HttpConnectionManagerConfig config(parseHttpConnectionManagerFromV2Yaml(yaml_string), context_,
+                                     date_provider_, route_config_provider_manager_,
+                                     scoped_routes_config_provider_manager_, http_tracer_manager_);
+  EXPECT_EQ(envoy::extensions::filters::network::http_connection_manager::v3::
+                HttpConnectionManager::KEEP_UNCHANGED,
+            config.pathWithEscapedSlashesAction());
+}
+
+TEST_F(HttpConnectionManagerConfigTest, PathWithEscapedSlashesActionDefaultOverriden) {
+  const std::string yaml_string = R"EOF(
+  stat_prefix: ingress_http
+  path_with_escaped_slashes_action: IMPLEMENTATION_SPECIFIC_DEFAULT
+  route_config:
+    name: local_route
+  http_filters:
+  - name: envoy.filters.http.router
+  )EOF";
+
+  EXPECT_CALL(context_.runtime_loader_.snapshot_,
+              featureEnabled(_, An<const envoy::type::v3::FractionalPercent&>()))
+      .WillRepeatedly(Return(true));
+  EXPECT_CALL(context_.runtime_loader_.snapshot_, getInteger(_, _)).Times(AnyNumber());
+  EXPECT_CALL(context_.runtime_loader_.snapshot_,
+              getInteger("http_connection_manager.path_with_escaped_slashes_action", 0))
+      .WillOnce(Return(3));
+  HttpConnectionManagerConfig config(parseHttpConnectionManagerFromV2Yaml(yaml_string), context_,
+                                     date_provider_, route_config_provider_manager_,
+                                     scoped_routes_config_provider_manager_, http_tracer_manager_);
+  EXPECT_EQ(envoy::extensions::filters::network::http_connection_manager::v3::
+                HttpConnectionManager::UNESCAPE_AND_REDIRECT,
+            config.pathWithEscapedSlashesAction());
+
+  // Check the UNESCAPE_AND_FORWARD override to mollify coverage check
+  EXPECT_CALL(context_.runtime_loader_.snapshot_,
+              getInteger("http_connection_manager.path_with_escaped_slashes_action", 0))
+      .WillOnce(Return(4));
+  HttpConnectionManagerConfig config1(parseHttpConnectionManagerFromV2Yaml(yaml_string), context_,
+                                      date_provider_, route_config_provider_manager_,
+                                      scoped_routes_config_provider_manager_, http_tracer_manager_);
+  EXPECT_EQ(envoy::extensions::filters::network::http_connection_manager::v3::
+                HttpConnectionManager::UNESCAPE_AND_FORWARD,
+            config1.pathWithEscapedSlashesAction());
+}
+
+// Verify that runtime override does not affect non default configuration value.
+TEST_F(HttpConnectionManagerConfigTest,
+       PathWithEscapedSlashesActionRuntimeOverrideDoesNotChangeNonDefaultConfigValue) {
+  const std::string yaml_string = R"EOF(
+  stat_prefix: ingress_http
+  path_with_escaped_slashes_action: REJECT_REQUEST
+  route_config:
+    name: local_route
+  http_filters:
+  - name: envoy.filters.http.router
+  )EOF";
+
+  EXPECT_CALL(context_.runtime_loader_.snapshot_,
+              featureEnabled(_, An<const envoy::type::v3::FractionalPercent&>()))
+      .WillOnce(Return(true));
+  EXPECT_CALL(context_.runtime_loader_.snapshot_, getInteger(_, _)).Times(AnyNumber());
+  // When configuration value is not the IMPLEMENTATION_SPECIFIC_DEFAULT the runtime override should
+  // not even be considered.
+  EXPECT_CALL(context_.runtime_loader_.snapshot_,
+              getInteger("http_connection_manager.path_with_escaped_slashes_action", 0))
+      .Times(0);
+  HttpConnectionManagerConfig config(parseHttpConnectionManagerFromV2Yaml(yaml_string), context_,
+                                     date_provider_, route_config_provider_manager_,
+                                     scoped_routes_config_provider_manager_, http_tracer_manager_);
+  EXPECT_EQ(envoy::extensions::filters::network::http_connection_manager::v3::
+                HttpConnectionManager::REJECT_REQUEST,
+            config.pathWithEscapedSlashesAction());
+}
+
+// Verify that disabling unescaping slashes results in the KEEP_UNCHANGED action when config is
+// value is not set.
+TEST_F(HttpConnectionManagerConfigTest, PathWithEscapedSlashesActionDefaultOverridenAndDisabled) {
+  const std::string yaml_string = R"EOF(
+  stat_prefix: ingress_http
+  route_config:
+    name: local_route
+  http_filters:
+ - name: envoy.filters.http.router
+  )EOF";
+
+  EXPECT_CALL(context_.runtime_loader_.snapshot_, featureEnabled(_, An<uint64_t>()))
+      .WillRepeatedly(Invoke(&context_.runtime_loader_.snapshot_,
+                             &Runtime::MockSnapshot::featureEnabledDefault));
+  EXPECT_CALL(context_.runtime_loader_.snapshot_,
+              featureEnabled("http_connection_manager.path_with_escaped_slashes_action_enabled",
+                             An<const envoy::type::v3::FractionalPercent&>()))
+      .WillOnce(Return(false));
+  EXPECT_CALL(context_.runtime_loader_.snapshot_, getInteger(_, _)).Times(AnyNumber());
+  EXPECT_CALL(context_.runtime_loader_.snapshot_,
+              getInteger("http_connection_manager.path_with_escaped_slashes_action", 0))
+      .Times(0);
+  HttpConnectionManagerConfig config(parseHttpConnectionManagerFromV2Yaml(yaml_string), context_,
+                                     date_provider_, route_config_provider_manager_,
+                                     scoped_routes_config_provider_manager_, http_tracer_manager_);
+  EXPECT_EQ(envoy::extensions::filters::network::http_connection_manager::v3::
+                HttpConnectionManager::KEEP_UNCHANGED,
+            config.pathWithEscapedSlashesAction());
+}
+
+// Verify that disabling unescaping slashes results in the KEEP_UNCHANGED action when config is
+// value is set.
+TEST_F(HttpConnectionManagerConfigTest, PathWithEscapedSlashesActionSetAndDisabled) {
+  const std::string yaml_string = R"EOF(
+  stat_prefix: ingress_http
+  path_with_escaped_slashes_action: UNESCAPE_AND_REDIRECT
+  route_config:
+    name: local_route
+  http_filters:
+  - name: envoy.filters.http.router
+  )EOF";
+
+  EXPECT_CALL(context_.runtime_loader_.snapshot_, featureEnabled(_, An<uint64_t>()))
+      .WillRepeatedly(Invoke(&context_.runtime_loader_.snapshot_,
+                             &Runtime::MockSnapshot::featureEnabledDefault));
+  EXPECT_CALL(context_.runtime_loader_.snapshot_,
+              featureEnabled("http_connection_manager.path_with_escaped_slashes_action_enabled",
+                             An<const envoy::type::v3::FractionalPercent&>()))
+      .WillOnce(Return(false));
+  EXPECT_CALL(context_.runtime_loader_.snapshot_, getInteger(_, _)).Times(AnyNumber());
+  EXPECT_CALL(context_.runtime_loader_.snapshot_,
+              getInteger("http_connection_manager.path_with_escaped_slashes_action", 0))
+      .Times(0);
+  HttpConnectionManagerConfig config(parseHttpConnectionManagerFromV2Yaml(yaml_string), context_,
+                                     date_provider_, route_config_provider_manager_,
+                                     scoped_routes_config_provider_manager_, http_tracer_manager_);
+  EXPECT_EQ(envoy::extensions::filters::network::http_connection_manager::v3::
+                HttpConnectionManager::KEEP_UNCHANGED,
+            config.pathWithEscapedSlashesAction());
+}
+
 class HcmUtilityTest : public testing::Test {
 public:
   HcmUtilityTest() {
diff --git a/test/integration/header_integration_test.cc b/test/integration/header_integration_test.cc
index e7a2db5..a9a9c0e 100644
--- a/test/integration/header_integration_test.cc
+++ b/test/integration/header_integration_test.cc
@@ -327,7 +327,7 @@ public:
             }
           }
 
-          hcm.mutable_normalize_path()->set_value(normalize_path_);
+          hcm.set_path_with_escaped_slashes_action(path_with_escaped_slashes_action_);
 
           if (append) {
             // The config specifies append by default: no modifications needed.
@@ -431,8 +431,7 @@ protected:
     compareHeaders(response->headers(), expected_response_headers);
   }
 
-  void compareHeaders(Http::TestHeaderMapImpl&& headers,
-                      Http::TestHeaderMapImpl& expected_headers) {
+  void compareHeaders(Headers&& headers, const ExpectedHeaders& expected_headers) {
     headers.remove(Envoy::Http::LowerCaseString{"content-length"});
     headers.remove(Envoy::Http::LowerCaseString{"date"});
     if (!routerSuppressEnvoyHeaders()) {
@@ -448,6 +447,10 @@ protected:
 
   bool use_eds_{false};
   bool normalize_path_{false};
+  envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager::
+      PathWithEscapedSlashesAction path_with_escaped_slashes_action_{
+          envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager::
+              KEEP_UNCHANGED};
   FakeHttpConnectionPtr eds_connection_;
   FakeStreamPtr eds_stream_;
 };
@@ -1084,6 +1087,164 @@ TEST_P(HeaderIntegrationTest, TestPathAndRouteOnNormalizedPath) {
       });
 }
 
+// Validates that Envoy by default does not modify escaped slashes.
+TEST_P(HeaderIntegrationTest, PathWithEscapedSlashesByDefaultUnchanghed) {
+  path_with_escaped_slashes_action_ = envoy::extensions::filters::network::http_connection_manager::
+      v3::HttpConnectionManager::IMPLEMENTATION_SPECIFIC_DEFAULT;
+  normalize_path_ = true;
+  initializeFilter(HeaderMode::Append, false);
+  performRequest(
+      Http::TestRequestHeaderMapImpl{
+          {":method", "GET"},
+          {":path", "/private/..%2Fpublic%5c"},
+          {":scheme", "http"},
+          {":authority", "path-sanitization.com"},
+      },
+      Http::TestRequestHeaderMapImpl{{":authority", "path-sanitization.com"},
+                                     {":path", "/private/..%2Fpublic%5c"},
+                                     {":method", "GET"},
+                                     {"x-site", "private"}},
+      Http::TestResponseHeaderMapImpl{
+          {"server", "envoy"},
+          {"content-length", "0"},
+          {":status", "200"},
+          {"x-unmodified", "response"},
+      },
+      Http::TestResponseHeaderMapImpl{
+          {"server", "envoy"},
+          {"x-unmodified", "response"},
+          {":status", "200"},
+      });
+}
+
+// Validates that default action can be overridden through runtime.
+TEST_P(HeaderIntegrationTest, PathWithEscapedSlashesDefaultOverriden) {
+  // Override the default action to REJECT
+  config_helper_.addRuntimeOverride("http_connection_manager.path_with_escaped_slashes_action",
+                                    "2");
+  path_with_escaped_slashes_action_ = envoy::extensions::filters::network::http_connection_manager::
+      v3::HttpConnectionManager::IMPLEMENTATION_SPECIFIC_DEFAULT;
+  initializeFilter(HeaderMode::Append, false);
+  registerTestServerPorts({"http"});
+  codec_client_ = makeHttpConnection(makeClientConnection(lookupPort("http")));
+  IntegrationStreamDecoderPtr response =
+      codec_client_->makeHeaderOnlyRequest(Http::TestRequestHeaderMapImpl{
+          {":method", "GET"},
+          {":path", "/private%2f../public"},
+          {":scheme", "http"},
+          {":authority", "path-sanitization.com"},
+      });
+  response->waitForEndStream();
+ Http::TestResponseHeaderMapImpl response_headers{response->headers()};
+  compareHeaders(response_headers, Http::TestResponseHeaderMapImpl{
+                                       {"server", "envoy"},
+                                       {":status", "400"},
+                                   });
+}
+
+TEST_P(HeaderIntegrationTest, PathWithEscapedSlashesRejected) {
+  path_with_escaped_slashes_action_ = envoy::extensions::filters::network::http_connection_manager::
+      v3::HttpConnectionManager::REJECT_REQUEST;
+  initializeFilter(HeaderMode::Append, false);
+  registerTestServerPorts({"http"});
+  codec_client_ = makeHttpConnection(makeClientConnection(lookupPort("http")));
+  IntegrationStreamDecoderPtr response =
+      codec_client_->makeHeaderOnlyRequest(Http::TestRequestHeaderMapImpl{
+          {":method", "GET"},
+          {":path", "/private%2f../public"},
+          {":scheme", "http"},
+          {":authority", "path-sanitization.com"},
+      });
+  response->waitForEndStream();
+  Http::TestResponseHeaderMapImpl response_headers{response->headers()};
+  compareHeaders(response_headers, Http::TestResponseHeaderMapImpl{
+                                       {"server", "envoy"},
+                                       {":status", "400"},
+                                   });
+}
+
+// Validates that Envoy does not modify escaped slashes when configured.
+TEST_P(HeaderIntegrationTest, PathWithEscapedSlashesUnmodified) {
+  path_with_escaped_slashes_action_ = envoy::extensions::filters::network::http_connection_manager::
+      v3::HttpConnectionManager::KEEP_UNCHANGED;
+  normalize_path_ = true;
+  initializeFilter(HeaderMode::Append, false);
+  performRequest(
+      Http::TestRequestHeaderMapImpl{
+          {":method", "GET"},
+          {":path", "/private/..%2Fpublic%5c"},
+          {":scheme", "http"},
+          {":authority", "path-sanitization.com"},
+      },
+      Http::TestRequestHeaderMapImpl{{":authority", "path-sanitization.com"},
+                                     {":path", "/private/..%2Fpublic%5c"},
+                                     {":method", "GET"},
+                                     {"x-site", "private"}},
+      Http::TestResponseHeaderMapImpl{
+          {"server", "envoy"},
+          {"content-length", "0"},
+          {":status", "200"},
+          {"x-unmodified", "response"},
+      },
+      Http::TestResponseHeaderMapImpl{
+          {"server", "envoy"},
+          {"x-unmodified", "response"},
+          {":status", "200"},
+      });
+}
+
+// Validates that Envoy forwards unescaped slashes when configured.
+TEST_P(HeaderIntegrationTest, PathWithEscapedSlashesAndNormalizationForwarded) {
+  path_with_escaped_slashes_action_ = envoy::extensions::filters::network::http_connection_manager::
+      v3::HttpConnectionManager::UNESCAPE_AND_FORWARD;
+  normalize_path_ = true;
+  initializeFilter(HeaderMode::Append, false);
+  performRequest(
+      Http::TestRequestHeaderMapImpl{
+          {":method", "GET"},
+          {":path", "/private/..%2Fpublic%5c%2e%2Fabc"},
+          {":scheme", "http"},
+          {":authority", "path-sanitization.com"},
+      },
+      Http::TestRequestHeaderMapImpl{{":authority", "path-sanitization.com"},
+                                     {":path", "/public/abc"},
+                                     {":method", "GET"},
+                                     {"x-site", "public"}},
+      Http::TestResponseHeaderMapImpl{
+          {"server", "envoy"},
+          {"content-length", "0"},
+          {":status", "200"},
+          {"x-unmodified", "response"},
+      },
+      Http::TestResponseHeaderMapImpl{
+          {"server", "envoy"},
+          {"x-unmodified", "response"},
+          {":status", "200"},
+      });
+}
+
+TEST_P(HeaderIntegrationTest, PathWithEscapedSlashesRedirected) {
+  path_with_escaped_slashes_action_ = envoy::extensions::filters::network::http_connection_manager::
+      v3::HttpConnectionManager::UNESCAPE_AND_REDIRECT;
+  initializeFilter(HeaderMode::Append, false);
+  registerTestServerPorts({"http"});
+  codec_client_ = makeHttpConnection(makeClientConnection(lookupPort("http")));
+  IntegrationStreamDecoderPtr response =
+      codec_client_->makeHeaderOnlyRequest(Http::TestRequestHeaderMapImpl{
+          {":method", "GET"},
+          {":path", "/private%2f../%2e%5Cpublic"},
+          {":scheme", "http"},
+          {":authority", "path-sanitization.com"},
+      });
+  response->waitForEndStream();
+  Http::TestResponseHeaderMapImpl response_headers{response->headers()};
+  compareHeaders(response_headers, Http::TestResponseHeaderMapImpl{
+                                       {"location", "/private/../%2e\\public"},
+                                       {"server", "envoy"},
+                                       {":status", "307"},
+                                   });
+}
+
 // Validates TE header is forwarded if it contains a supported value
 TEST_P(HeaderIntegrationTest, TestTeHeaderPassthrough) {
   initializeFilter(HeaderMode::Append, false);
diff --git a/test/integration/protocol_integration_test.cc b/test/integration/protocol_integration_test.cc
index 074181c73699..47be2bc923a8 100644
--- a/test/integration/protocol_integration_test.cc
+++ b/test/integration/protocol_integration_test.cc
@@ -1979,6 +1979,25 @@ TEST_P(DownstreamProtocolIntegrationTest, ConnectStreamRejection) {
   EXPECT_FALSE(codec_client_->disconnected());
 }
 
+TEST_P(DownstreamProtocolIntegrationTest, HeaderNormalizationRejection) {
+  config_helper_.addConfigModifier(
+      [](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&
+             hcm) -> void {
+        hcm.set_path_with_escaped_slashes_action(
+            envoy::extensions::filters::network::http_connection_manager::v3::
+                HttpConnectionManager::REJECT_REQUEST);
+      });
+
+  initialize();
+  codec_client_ = makeHttpConnection(lookupPort("http"));
+  default_request_headers_.setPath("/test/long%2Furl");
+  auto response = codec_client_->makeHeaderOnlyRequest(default_request_headers_);
+
+  response->waitForEndStream();
+  EXPECT_TRUE(response->complete());
+  EXPECT_EQ("400", response->headers().getStatusValue());
+}
+
 // For tests which focus on downstream-to-Envoy behavior, and don't need to be
 // run with both HTTP/1 and HTTP/2 upstreams.
 INSTANTIATE_TEST_SUITE_P(Protocols, DownstreamProtocolIntegrationTest,
