From 9cb9b65de81512802da59b3a2df64d018530e915 Mon Sep 17 00:00:00 2001
From: AJ Heller <hork@google.com>
Date: Tue, 11 Jul 2023 08:55:13 -0700
Subject: [PATCH 01/11] [iomgr][EventEngine] Improve handling of file
 descriptor exhaustion

---
 .../posix_engine/posix_engine_listener.cc     | 16 +++++++
 .../posix_engine/posix_engine_listener.h      |  9 +++-
 src/core/lib/gprpp/time.h                     |  4 +-
 src/core/lib/iomgr/tcp_server_posix.cc        | 44 ++++++++++++++-----
 src/core/lib/iomgr/tcp_server_utils_posix.h   |  6 +++
 .../iomgr/tcp_server_utils_posix_common.cc    |  9 ++++
 6 files changed, 73 insertions(+), 15 deletions(-)

diff --git a/src/core/lib/event_engine/posix_engine/posix_engine_listener.cc b/src/core/lib/event_engine/posix_engine/posix_engine_listener.cc
index 59facad83b50..a380ee3a0488 100644
--- a/src/core/lib/event_engine/posix_engine/posix_engine_listener.cc
+++ b/src/core/lib/event_engine/posix_engine/posix_engine_listener.cc
@@ -138,6 +138,22 @@ void PosixEngineListenerImpl::AsyncConnectionAcceptor::NotifyOnAccept(
       switch (errno) {
         case EINTR:
           continue;
+        case EMFILE:
+          // When the process runs out of fds, accept4() returns EMFILE. When
+          // this happens, the connection is left in the accept queue until
+          // either a read event triggers the on_read callback, or time has
+          // passed and the accept should be re-tried regardless. This callback
+          // is not cancelled, so a spurious wakeup may occur even when there's
+          // nothing to accept. This is not a performant code path, but if an fd
+          // limit has been reached, the system is likely in an unhappy state
+          // regardless.
+          GRPC_LOG_EVERY_N_SEC(1, GPR_ERROR, "%s",
+                               "File descriptor limit reached. Retrying.");
+          handle_->NotifyOnRead(notify_on_accept_);
+          if (retry_timer_armed_.exchange(false)) return;
+          std::ignore = engine_->RunAfter(grpc_core::Duration::Seconds(1),
+                                          retry_closure_);
+          return;
         case EAGAIN:
         case ECONNABORTED:
           handle_->NotifyOnRead(notify_on_accept_);
diff --git a/src/core/lib/event_engine/posix_engine/posix_engine_listener.h b/src/core/lib/event_engine/posix_engine/posix_engine_listener.h
index c0b793a50159..88bf54fe560a 100644
--- a/src/core/lib/event_engine/posix_engine/posix_engine_listener.h
+++ b/src/core/lib/event_engine/posix_engine/posix_engine_listener.h
@@ -94,7 +94,12 @@ class PosixEngineListenerImpl
                   ResolvedAddressToNormalizedString(socket_.addr),
               listener_->poller_->CanTrackErrors())),
           notify_on_accept_(PosixEngineClosure::ToPermanentClosure(
-              [this](absl::Status status) { NotifyOnAccept(status); })){};
+              [this](absl::Status status) { NotifyOnAccept(status); })),
+          retry_closure_(
+              PosixEngineClosure::ToPermanentClosure([this](absl::Status) {
+                retry_timer_armed_.store(false);
+                handle_->SetReadable();
+              })){};
     // Start listening for incoming connections on the socket.
     void Start();
     // Internal callback invoked when the socket has incoming connections to
@@ -121,6 +126,8 @@ class PosixEngineListenerImpl
     ListenerSocketsContainer::ListenerSocket socket_;
     EventHandle* handle_;
     PosixEngineClosure* notify_on_accept_;
+    PosixEngineClosure* retry_closure_;
+    std::atomic<bool> retry_timer_armed_{false};
   };
   class ListenerAsyncAcceptors : public ListenerSocketsContainer {
    public:
diff --git a/src/core/lib/gprpp/time.h b/src/core/lib/gprpp/time.h
index 3c39916c3b07..32b1065e380b 100644
--- a/src/core/lib/gprpp/time.h
+++ b/src/core/lib/gprpp/time.h
@@ -37,8 +37,8 @@
     uint64_t now = grpc_core::Timestamp::FromTimespecRoundDown( \
                        gpr_now(GPR_CLOCK_MONOTONIC))            \
                        .milliseconds_after_process_epoch();     \
-    uint64_t prev_tsamp = prev.exchange(now);                   \
-    if (prev_tsamp == 0 || now - prev_tsamp > (n)*1000) {       \
+    if (prev == 0 || now - prev > (n)*1000) {                   \
+      prev = now;                                               \
       gpr_log(severity, format, __VA_ARGS__);                   \
     }                                                           \
   } while (0)
diff --git a/src/core/lib/iomgr/tcp_server_posix.cc b/src/core/lib/iomgr/tcp_server_posix.cc
index 3c292ac28d04..2f7eb83d8f48 100644
--- a/src/core/lib/iomgr/tcp_server_posix.cc
+++ b/src/core/lib/iomgr/tcp_server_posix.cc
@@ -18,6 +18,8 @@
 
 #include <grpc/support/port_platform.h>
 
+#include <utility>
+
 #include <grpc/support/atm.h>
 
 // FIXME: "posix" files shouldn't be depending on _GNU_SOURCE
@@ -79,6 +81,8 @@
 #include "src/core/lib/transport/error_utils.h"
 
 static std::atomic<int64_t> num_dropped_connections{0};
+static constexpr grpc_core::Duration kRetryAcceptWaitTime{
+    grpc_core::Duration::Seconds(1)};
 
 using ::grpc_event_engine::experimental::EndpointConfig;
 using ::grpc_event_engine::experimental::EventEngine;
@@ -362,22 +366,38 @@ static void on_read(void* arg, grpc_error_handle err) {
     if (fd < 0) {
       if (errno == EINTR) {
         continue;
-      } else if (errno == EAGAIN || errno == ECONNABORTED ||
-                 errno == EWOULDBLOCK) {
+      }
+      // When the process runs out of fds, accept4() returns EMFILE. When this
+      // happens, the connection is left in the accept queue until either a
+      // read event triggers the on_read callback, or time has passed and the
+      // accept should be re-tried regardless. This callback is not cancelled,
+      // so a spurious wakeup may occur even when there's nothing to accept.
+      // This is not a performant code path, but if an fd limit has been
+      // reached, the system is likely in an unhappy state regardless.
+      if (errno == EMFILE) {
+        GRPC_LOG_EVERY_N_SEC(1, GPR_ERROR, "%s",
+                             "File descriptor limit reached. Retrying.");
+        grpc_fd_notify_on_read(sp->emfd, &sp->read_closure);
+        if (std::exchange(sp->retry_timer_armed, true)) return;
+        grpc_timer_init(&sp->retry_timer,
+                        grpc_core::Timestamp::Now() + kRetryAcceptWaitTime,
+                        &sp->retry_closure);
+        return;
+      }
+      if (errno == EAGAIN || errno == ECONNABORTED || errno == EWOULDBLOCK) {
         grpc_fd_notify_on_read(sp->emfd, &sp->read_closure);
         return;
+      }
+      gpr_mu_lock(&sp->server->mu);
+      if (!sp->server->shutdown_listeners) {
+        gpr_log(GPR_ERROR, "Failed accept4: %s",
+                grpc_core::StrError(errno).c_str());
       } else {
-        gpr_mu_lock(&sp->server->mu);
-        if (!sp->server->shutdown_listeners) {
-          gpr_log(GPR_ERROR, "Failed accept4: %s",
-                  grpc_core::StrError(errno).c_str());
-        } else {
-          // if we have shutdown listeners, accept4 could fail, and we
-          // needn't notify users
-        }
-        gpr_mu_unlock(&sp->server->mu);
-        goto error;
+        // if we have shutdown listeners, accept4 could fail, and we
+        // needn't notify users
       }
+      gpr_mu_unlock(&sp->server->mu);
+      goto error;
     }
 
     if (sp->server->memory_quota->IsMemoryPressureHigh()) {
diff --git a/src/core/lib/iomgr/tcp_server_utils_posix.h b/src/core/lib/iomgr/tcp_server_utils_posix.h
index 7fbd772224bd..601df8a382e4 100644
--- a/src/core/lib/iomgr/tcp_server_utils_posix.h
+++ b/src/core/lib/iomgr/tcp_server_utils_posix.h
@@ -30,6 +30,7 @@
 #include "src/core/lib/iomgr/resolve_address.h"
 #include "src/core/lib/iomgr/socket_utils_posix.h"
 #include "src/core/lib/iomgr/tcp_server.h"
+#include "src/core/lib/iomgr/timer.h"
 #include "src/core/lib/resource_quota/memory_quota.h"
 
 // one listening port
@@ -52,6 +53,11 @@ typedef struct grpc_tcp_listener {
   // identified while iterating through 'next'.
   struct grpc_tcp_listener* sibling;
   int is_sibling;
+  // If an accept4() call fails, a timer is started to drain the accept queue in
+  // case no further connection attempts reach the gRPC server.
+  grpc_timer retry_timer;
+  grpc_closure retry_closure;
+  bool retry_timer_armed;
 } grpc_tcp_listener;
 
 // the overall server
diff --git a/src/core/lib/iomgr/tcp_server_utils_posix_common.cc b/src/core/lib/iomgr/tcp_server_utils_posix_common.cc
index 8f75a3ed5e02..37fb612c81f4 100644
--- a/src/core/lib/iomgr/tcp_server_utils_posix_common.cc
+++ b/src/core/lib/iomgr/tcp_server_utils_posix_common.cc
@@ -82,6 +82,12 @@ static int get_max_accept_queue_size(void) {
   return s_max_accept_queue_size;
 }
 
+static void listener_retry_timer_cb(void* arg, grpc_error_handle /* err */) {
+  grpc_tcp_listener* sp = static_cast<grpc_tcp_listener*>(arg);
+  sp->retry_timer_armed = false;
+  grpc_fd_set_readable(sp->emfd);
+}
+
 static grpc_error_handle add_socket_to_server(grpc_tcp_server* s, int fd,
                                               const grpc_resolved_address* addr,
                                               unsigned port_index,
@@ -113,6 +119,9 @@ static grpc_error_handle add_socket_to_server(grpc_tcp_server* s, int fd,
   sp->server = s;
   sp->fd = fd;
   sp->emfd = grpc_fd_create(fd, name.c_str(), true);
+  sp->retry_timer_armed = false;
+  GRPC_CLOSURE_INIT(&sp->retry_closure, listener_retry_timer_cb, sp,
+                    grpc_schedule_on_exec_ctx);
 
   // Check and set fd as prellocated
   if (grpc_tcp_server_pre_allocated_fd(s) == fd) {

From 7257ded8541c7eda9db283d74bc61fadd68beb63 Mon Sep 17 00:00:00 2001
From: AJ Heller <hork@google.com>
Date: Tue, 11 Jul 2023 14:11:54 -0700
Subject: [PATCH 02/11] caution

---
 src/core/lib/event_engine/posix_engine/posix_engine.h | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/core/lib/event_engine/posix_engine/posix_engine.h b/src/core/lib/event_engine/posix_engine/posix_engine.h
index 2084ab4041f3..815a663d3d0a 100644
--- a/src/core/lib/event_engine/posix_engine/posix_engine.h
+++ b/src/core/lib/event_engine/posix_engine/posix_engine.h
@@ -192,6 +192,7 @@ class PosixEventEngine final : public PosixEventEngineWithFdSupport,
       const DNSResolver::ResolverOptions& options) override;
   void Run(Closure* closure) override;
   void Run(absl::AnyInvocable<void()> closure) override;
+  // Caution!! The timer implementation cannot create any fds. See #20418.
   TaskHandle RunAfter(Duration when, Closure* closure) override;
   TaskHandle RunAfter(Duration when,
                       absl::AnyInvocable<void()> closure) override;

From 3d486bd76770233f069c6bf3e2502f4e040852c2 Mon Sep 17 00:00:00 2001
From: AJ Heller <hork@google.com>
Date: Tue, 11 Jul 2023 15:25:26 -0700
Subject: [PATCH 03/11] handle retry timer cancellation in listener destruction

---
 .../posix_engine/posix_engine_listener.cc     | 18 ++++++++++---
 .../posix_engine/posix_engine_listener.h      | 27 +++++++++++++------
 2 files changed, 34 insertions(+), 11 deletions(-)

diff --git a/src/core/lib/event_engine/posix_engine/posix_engine_listener.cc b/src/core/lib/event_engine/posix_engine/posix_engine_listener.cc
index a380ee3a0488..daabd55f8791 100644
--- a/src/core/lib/event_engine/posix_engine/posix_engine_listener.cc
+++ b/src/core/lib/event_engine/posix_engine/posix_engine_listener.cc
@@ -24,6 +24,7 @@
 #include <sys/socket.h>  // IWYU pragma: keep
 #include <unistd.h>      // IWYU pragma: keep
 
+#include <atomic>
 #include <string>
 #include <type_traits>
 #include <utility>
@@ -150,9 +151,20 @@ void PosixEngineListenerImpl::AsyncConnectionAcceptor::NotifyOnAccept(
           GRPC_LOG_EVERY_N_SEC(1, GPR_ERROR, "%s",
                                "File descriptor limit reached. Retrying.");
           handle_->NotifyOnRead(notify_on_accept_);
-          if (retry_timer_armed_.exchange(false)) return;
-          std::ignore = engine_->RunAfter(grpc_core::Duration::Seconds(1),
-                                          retry_closure_);
+          {
+            grpc_core::MutexLock lock(&retry_timer_mu_);
+            if (retry_timer_handle_ == EventEngine::TaskHandle::kInvalid) {
+              return;
+            }
+            retry_timer_handle_ =
+                engine_->RunAfter(grpc_core::Duration::Seconds(1), [this]() {
+                  {
+                    grpc_core::MutexLock lock(&retry_timer_mu_);
+                    retry_timer_handle_ = EventEngine::TaskHandle::kInvalid;
+                  }
+                  handle_->SetReadable();
+                });
+          }
           return;
         case EAGAIN:
         case ECONNABORTED:
diff --git a/src/core/lib/event_engine/posix_engine/posix_engine_listener.h b/src/core/lib/event_engine/posix_engine/posix_engine_listener.h
index 88bf54fe560a..b87f707cd7df 100644
--- a/src/core/lib/event_engine/posix_engine/posix_engine_listener.h
+++ b/src/core/lib/event_engine/posix_engine/posix_engine_listener.h
@@ -94,12 +94,7 @@ class PosixEngineListenerImpl
                   ResolvedAddressToNormalizedString(socket_.addr),
               listener_->poller_->CanTrackErrors())),
           notify_on_accept_(PosixEngineClosure::ToPermanentClosure(
-              [this](absl::Status status) { NotifyOnAccept(status); })),
-          retry_closure_(
-              PosixEngineClosure::ToPermanentClosure([this](absl::Status) {
-                retry_timer_armed_.store(false);
-                handle_->SetReadable();
-              })){};
+              [this](absl::Status status) { NotifyOnAccept(status); })){};
     // Start listening for incoming connections on the socket.
     void Start();
     // Internal callback invoked when the socket has incoming connections to
@@ -115,6 +110,18 @@ class PosixEngineListenerImpl
     }
     ListenerSocketsContainer::ListenerSocket& Socket() { return socket_; }
     ~AsyncConnectionAcceptor() {
+      // Ensure the retry timer is not waiting.
+      retry_timer_mu_.Lock();
+      if (retry_timer_handle_ != EventEngine::TaskHandle::kInvalid &&
+          !engine_->Cancel(retry_timer_handle_)) {
+        // Could not cancel the retry timer, so wait for it to run.
+        do {
+          retry_timer_mu_.Unlock();
+          absl::SleepFor(absl::Milliseconds(100));
+          retry_timer_mu_.Lock();
+        } while (retry_timer_handle_ != EventEngine::TaskHandle::kInvalid);
+      }
+      retry_timer_mu_.Unlock();
       handle_->OrphanHandle(nullptr, nullptr, "");
       delete notify_on_accept_;
     }
@@ -126,8 +133,12 @@ class PosixEngineListenerImpl
     ListenerSocketsContainer::ListenerSocket socket_;
     EventHandle* handle_;
     PosixEngineClosure* notify_on_accept_;
-    PosixEngineClosure* retry_closure_;
-    std::atomic<bool> retry_timer_armed_{false};
+    // A backup timer to retry accept calls after file descriptor exhaustion.
+    // Note that a mutex is required here, since check and set cannot be an
+    // atomic operation when scheduling a timer.
+    grpc_core::Mutex retry_timer_mu_;
+    EventEngine::TaskHandle retry_timer_handle_
+        ABSL_GUARDED_BY(retry_timer_mu_) = EventEngine::TaskHandle::kInvalid;
   };
   class ListenerAsyncAcceptors : public ListenerSocketsContainer {
    public:

From 48a5dffa1203908bc03b508ef96eda6d7fe75323 Mon Sep 17 00:00:00 2001
From: AJ Heller <hork@google.com>
Date: Tue, 11 Jul 2023 15:43:31 -0700
Subject: [PATCH 04/11] revert timed logging changes

---
 src/core/lib/gprpp/time.h | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/core/lib/gprpp/time.h b/src/core/lib/gprpp/time.h
index 32b1065e380b..3c39916c3b07 100644
--- a/src/core/lib/gprpp/time.h
+++ b/src/core/lib/gprpp/time.h
@@ -37,8 +37,8 @@
     uint64_t now = grpc_core::Timestamp::FromTimespecRoundDown( \
                        gpr_now(GPR_CLOCK_MONOTONIC))            \
                        .milliseconds_after_process_epoch();     \
-    if (prev == 0 || now - prev > (n)*1000) {                   \
-      prev = now;                                               \
+    uint64_t prev_tsamp = prev.exchange(now);                   \
+    if (prev_tsamp == 0 || now - prev_tsamp > (n)*1000) {       \
       gpr_log(severity, format, __VA_ARGS__);                   \
     }                                                           \
   } while (0)

From 6cb896e49623f794faedc0967a9f17c8cb96c07a Mon Sep 17 00:00:00 2001
From: AJ Heller <hork@google.com>
Date: Tue, 11 Jul 2023 16:08:04 -0700
Subject: [PATCH 05/11] simplify the listener shutdown story

---
 .../posix_engine/posix_engine_listener.cc             |  4 ++++
 .../event_engine/posix_engine/posix_engine_listener.h | 11 -----------
 2 files changed, 4 insertions(+), 11 deletions(-)

diff --git a/src/core/lib/event_engine/posix_engine/posix_engine_listener.cc b/src/core/lib/event_engine/posix_engine/posix_engine_listener.cc
index daabd55f8791..e7ead4554c63 100644
--- a/src/core/lib/event_engine/posix_engine/posix_engine_listener.cc
+++ b/src/core/lib/event_engine/posix_engine/posix_engine_listener.cc
@@ -156,6 +156,9 @@ void PosixEngineListenerImpl::AsyncConnectionAcceptor::NotifyOnAccept(
             if (retry_timer_handle_ == EventEngine::TaskHandle::kInvalid) {
               return;
             }
+            // Hold a ref while the retry timer is waiting, to prevent listener
+            // destruction and the races that would ensue.
+            Ref();
             retry_timer_handle_ =
                 engine_->RunAfter(grpc_core::Duration::Seconds(1), [this]() {
                   {
@@ -163,6 +166,7 @@ void PosixEngineListenerImpl::AsyncConnectionAcceptor::NotifyOnAccept(
                     retry_timer_handle_ = EventEngine::TaskHandle::kInvalid;
                   }
                   handle_->SetReadable();
+                  Unref();
                 });
           }
           return;
diff --git a/src/core/lib/event_engine/posix_engine/posix_engine_listener.h b/src/core/lib/event_engine/posix_engine/posix_engine_listener.h
index b87f707cd7df..d1e38516f64a 100644
--- a/src/core/lib/event_engine/posix_engine/posix_engine_listener.h
+++ b/src/core/lib/event_engine/posix_engine/posix_engine_listener.h
@@ -111,17 +111,6 @@ class PosixEngineListenerImpl
     ListenerSocketsContainer::ListenerSocket& Socket() { return socket_; }
     ~AsyncConnectionAcceptor() {
       // Ensure the retry timer is not waiting.
-      retry_timer_mu_.Lock();
-      if (retry_timer_handle_ != EventEngine::TaskHandle::kInvalid &&
-          !engine_->Cancel(retry_timer_handle_)) {
-        // Could not cancel the retry timer, so wait for it to run.
-        do {
-          retry_timer_mu_.Unlock();
-          absl::SleepFor(absl::Milliseconds(100));
-          retry_timer_mu_.Lock();
-        } while (retry_timer_handle_ != EventEngine::TaskHandle::kInvalid);
-      }
-      retry_timer_mu_.Unlock();
       handle_->OrphanHandle(nullptr, nullptr, "");
       delete notify_on_accept_;
     }

From 3a23167d35bf4be978fc6f7ec18a30d141388e33 Mon Sep 17 00:00:00 2001
From: AJ Heller <hork@google.com>
Date: Tue, 11 Jul 2023 16:08:59 -0700
Subject: [PATCH 06/11] cleanup

---
 src/core/lib/event_engine/posix_engine/posix_engine_listener.h | 1 -
 1 file changed, 1 deletion(-)

diff --git a/src/core/lib/event_engine/posix_engine/posix_engine_listener.h b/src/core/lib/event_engine/posix_engine/posix_engine_listener.h
index d1e38516f64a..de76b32b46a3 100644
--- a/src/core/lib/event_engine/posix_engine/posix_engine_listener.h
+++ b/src/core/lib/event_engine/posix_engine/posix_engine_listener.h
@@ -110,7 +110,6 @@ class PosixEngineListenerImpl
     }
     ListenerSocketsContainer::ListenerSocket& Socket() { return socket_; }
     ~AsyncConnectionAcceptor() {
-      // Ensure the retry timer is not waiting.
       handle_->OrphanHandle(nullptr, nullptr, "");
       delete notify_on_accept_;
     }

From 34512a7667bbfc0b5b5e42d0f4cf2ed188faa478 Mon Sep 17 00:00:00 2001
From: AJ Heller <hork@google.com>
Date: Tue, 11 Jul 2023 16:26:36 -0700
Subject: [PATCH 07/11] only set readable if the handle is not shut down

---
 .../lib/event_engine/posix_engine/posix_engine_listener.cc    | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/src/core/lib/event_engine/posix_engine/posix_engine_listener.cc b/src/core/lib/event_engine/posix_engine/posix_engine_listener.cc
index e7ead4554c63..591d563b0026 100644
--- a/src/core/lib/event_engine/posix_engine/posix_engine_listener.cc
+++ b/src/core/lib/event_engine/posix_engine/posix_engine_listener.cc
@@ -165,7 +165,9 @@ void PosixEngineListenerImpl::AsyncConnectionAcceptor::NotifyOnAccept(
                     grpc_core::MutexLock lock(&retry_timer_mu_);
                     retry_timer_handle_ = EventEngine::TaskHandle::kInvalid;
                   }
-                  handle_->SetReadable();
+                  if (!handle_->IsHandleShutdown()) {
+                    handle_->SetReadable();
+                  }
                   Unref();
                 });
           }

From a5b01717b2b64511be05ca6c0a618712ad290828 Mon Sep 17 00:00:00 2001
From: AJ Heller <hork@google.com>
Date: Tue, 11 Jul 2023 16:39:20 -0700
Subject: [PATCH 08/11] better atomics for iomgr

---
 src/core/lib/iomgr/tcp_server_posix.cc            |  3 ++-
 src/core/lib/iomgr/tcp_server_utils_posix.h       |  4 ++--
 .../lib/iomgr/tcp_server_utils_posix_common.cc    | 15 +++++++++++----
 3 files changed, 15 insertions(+), 7 deletions(-)

diff --git a/src/core/lib/iomgr/tcp_server_posix.cc b/src/core/lib/iomgr/tcp_server_posix.cc
index 2f7eb83d8f48..ee122a59f650 100644
--- a/src/core/lib/iomgr/tcp_server_posix.cc
+++ b/src/core/lib/iomgr/tcp_server_posix.cc
@@ -378,7 +378,7 @@ static void on_read(void* arg, grpc_error_handle err) {
         GRPC_LOG_EVERY_N_SEC(1, GPR_ERROR, "%s",
                              "File descriptor limit reached. Retrying.");
         grpc_fd_notify_on_read(sp->emfd, &sp->read_closure);
-        if (std::exchange(sp->retry_timer_armed, true)) return;
+        if (gpr_atm_full_xchg(&sp->retry_timer_armed, true)) return;
         grpc_timer_init(&sp->retry_timer,
                         grpc_core::Timestamp::Now() + kRetryAcceptWaitTime,
                         &sp->retry_closure);
@@ -838,6 +838,7 @@ static void tcp_server_shutdown_listeners(grpc_tcp_server* s) {
   if (s->active_ports) {
     grpc_tcp_listener* sp;
     for (sp = s->head; sp; sp = sp->next) {
+      grpc_timer_cancel(&sp->retry_timer);
       grpc_fd_shutdown(sp->emfd, GRPC_ERROR_CREATE("Server shutdown"));
     }
   }
diff --git a/src/core/lib/iomgr/tcp_server_utils_posix.h b/src/core/lib/iomgr/tcp_server_utils_posix.h
index 601df8a382e4..a7fd947358bc 100644
--- a/src/core/lib/iomgr/tcp_server_utils_posix.h
+++ b/src/core/lib/iomgr/tcp_server_utils_posix.h
@@ -55,9 +55,9 @@ typedef struct grpc_tcp_listener {
   int is_sibling;
   // If an accept4() call fails, a timer is started to drain the accept queue in
   // case no further connection attempts reach the gRPC server.
-  grpc_timer retry_timer;
   grpc_closure retry_closure;
-  bool retry_timer_armed;
+  grpc_timer retry_timer;
+  gpr_atm retry_timer_armed;
 } grpc_tcp_listener;
 
 // the overall server
diff --git a/src/core/lib/iomgr/tcp_server_utils_posix_common.cc b/src/core/lib/iomgr/tcp_server_utils_posix_common.cc
index 37fb612c81f4..df399f5f95dc 100644
--- a/src/core/lib/iomgr/tcp_server_utils_posix_common.cc
+++ b/src/core/lib/iomgr/tcp_server_utils_posix_common.cc
@@ -18,6 +18,8 @@
 
 #include <grpc/support/port_platform.h>
 
+#include <grpc/support/atm.h>
+
 #include "src/core/lib/iomgr/port.h"
 
 #ifdef GRPC_POSIX_SOCKET_TCP_SERVER_UTILS_COMMON
@@ -82,10 +84,14 @@ static int get_max_accept_queue_size(void) {
   return s_max_accept_queue_size;
 }
 
-static void listener_retry_timer_cb(void* arg, grpc_error_handle /* err */) {
+static void listener_retry_timer_cb(void* arg, grpc_error_handle err) {
+  // Do nothing if cancelled.
+  if (!err.ok()) return;
   grpc_tcp_listener* sp = static_cast<grpc_tcp_listener*>(arg);
-  sp->retry_timer_armed = false;
-  grpc_fd_set_readable(sp->emfd);
+  gpr_atm_no_barrier_store(&sp->retry_timer_armed, false);
+  if (!grpc_fd_is_shutdown(sp->emfd)) {
+    grpc_fd_set_readable(sp->emfd);
+  }
 }
 
 static grpc_error_handle add_socket_to_server(grpc_tcp_server* s, int fd,
@@ -119,7 +125,8 @@ static grpc_error_handle add_socket_to_server(grpc_tcp_server* s, int fd,
   sp->server = s;
   sp->fd = fd;
   sp->emfd = grpc_fd_create(fd, name.c_str(), true);
-  sp->retry_timer_armed = false;
+  gpr_atm_no_barrier_store(&sp->retry_timer_armed, false);
+  grpc_timer_init_unset(&sp->retry_timer);
   GRPC_CLOSURE_INIT(&sp->retry_closure, listener_retry_timer_cb, sp,
                     grpc_schedule_on_exec_ctx);
 

From a9104707ef27edf9eed51eee1a650d5468b18d43 Mon Sep 17 00:00:00 2001
From: AJ Heller <hork@google.com>
Date: Tue, 11 Jul 2023 17:09:10 -0700
Subject: [PATCH 09/11] simplify PosixEE tracking of retry timer armed status

---
 .../posix_engine/posix_engine_listener.cc     | 33 ++++++++-----------
 .../posix_engine/posix_engine_listener.h      |  9 ++---
 2 files changed, 16 insertions(+), 26 deletions(-)

diff --git a/src/core/lib/event_engine/posix_engine/posix_engine_listener.cc b/src/core/lib/event_engine/posix_engine/posix_engine_listener.cc
index 591d563b0026..6dae61e5fe8d 100644
--- a/src/core/lib/event_engine/posix_engine/posix_engine_listener.cc
+++ b/src/core/lib/event_engine/posix_engine/posix_engine_listener.cc
@@ -151,26 +151,19 @@ void PosixEngineListenerImpl::AsyncConnectionAcceptor::NotifyOnAccept(
           GRPC_LOG_EVERY_N_SEC(1, GPR_ERROR, "%s",
                                "File descriptor limit reached. Retrying.");
           handle_->NotifyOnRead(notify_on_accept_);
-          {
-            grpc_core::MutexLock lock(&retry_timer_mu_);
-            if (retry_timer_handle_ == EventEngine::TaskHandle::kInvalid) {
-              return;
-            }
-            // Hold a ref while the retry timer is waiting, to prevent listener
-            // destruction and the races that would ensue.
-            Ref();
-            retry_timer_handle_ =
-                engine_->RunAfter(grpc_core::Duration::Seconds(1), [this]() {
-                  {
-                    grpc_core::MutexLock lock(&retry_timer_mu_);
-                    retry_timer_handle_ = EventEngine::TaskHandle::kInvalid;
-                  }
-                  if (!handle_->IsHandleShutdown()) {
-                    handle_->SetReadable();
-                  }
-                  Unref();
-                });
-          }
+          // Do not schedule another timer if one is already armed.
+          if (retry_timer_armed_.exchange(true)) return;
+          // Hold a ref while the retry timer is waiting, to prevent listener
+          // destruction and the races that would ensue.
+          Ref();
+          std::ignore =
+              engine_->RunAfter(grpc_core::Duration::Seconds(1), [this]() {
+                retry_timer_armed_.store(false);
+                if (!handle_->IsHandleShutdown()) {
+                  handle_->SetReadable();
+                }
+                Unref();
+              });
           return;
         case EAGAIN:
         case ECONNABORTED:
diff --git a/src/core/lib/event_engine/posix_engine/posix_engine_listener.h b/src/core/lib/event_engine/posix_engine/posix_engine_listener.h
index de76b32b46a3..b24c2baad568 100644
--- a/src/core/lib/event_engine/posix_engine/posix_engine_listener.h
+++ b/src/core/lib/event_engine/posix_engine/posix_engine_listener.h
@@ -121,12 +121,9 @@ class PosixEngineListenerImpl
     ListenerSocketsContainer::ListenerSocket socket_;
     EventHandle* handle_;
     PosixEngineClosure* notify_on_accept_;
-    // A backup timer to retry accept calls after file descriptor exhaustion.
-    // Note that a mutex is required here, since check and set cannot be an
-    // atomic operation when scheduling a timer.
-    grpc_core::Mutex retry_timer_mu_;
-    EventEngine::TaskHandle retry_timer_handle_
-        ABSL_GUARDED_BY(retry_timer_mu_) = EventEngine::TaskHandle::kInvalid;
+    // Tracks the status of a backup timer to retry accept4 calls after file
+    // descriptor exhaustion.
+    std::atomic<bool> retry_timer_armed_{false};
   };
   class ListenerAsyncAcceptors : public ListenerSocketsContainer {
    public:

From 0e388c7d16c5f8d44d2f83d0e1f6f518c5268e25 Mon Sep 17 00:00:00 2001
From: AJ Heller <hork@google.com>
Date: Tue, 11 Jul 2023 17:40:43 -0700
Subject: [PATCH 10/11] iwyu

---
 src/core/BUILD                                                  | 1 +
 src/core/lib/event_engine/posix_engine/posix_engine_listener.cc | 2 ++
 2 files changed, 3 insertions(+)

diff --git a/src/core/BUILD b/src/core/BUILD
index 25277c162b6b..fd5828ef7428 100644
--- a/src/core/BUILD
+++ b/src/core/BUILD
@@ -1944,6 +1944,7 @@ grpc_cc_library(
         "posix_event_engine_tcp_socket_utils",
         "socket_mutator",
         "status_helper",
+        "time",
         "//:event_engine_base_hdrs",
         "//:exec_ctx",
         "//:gpr",
diff --git a/src/core/lib/event_engine/posix_engine/posix_engine_listener.cc b/src/core/lib/event_engine/posix_engine/posix_engine_listener.cc
index 6dae61e5fe8d..bb97756dc7c5 100644
--- a/src/core/lib/event_engine/posix_engine/posix_engine_listener.cc
+++ b/src/core/lib/event_engine/posix_engine/posix_engine_listener.cc
@@ -26,6 +26,7 @@
 
 #include <atomic>
 #include <string>
+#include <tuple>
 #include <type_traits>
 #include <utility>
 
@@ -44,6 +45,7 @@
 #include "src/core/lib/event_engine/posix_engine/tcp_socket_utils.h"
 #include "src/core/lib/event_engine/tcp_socket_utils.h"
 #include "src/core/lib/gprpp/status_helper.h"
+#include "src/core/lib/gprpp/time.h"
 #include "src/core/lib/iomgr/socket_mutator.h"
 
 namespace grpc_event_engine {

From 838e08a09cd47b59cfaf9e2ad7d9d3eb3be034c3 Mon Sep 17 00:00:00 2001
From: AJ Heller <hork@google.com>
Date: Wed, 12 Jul 2023 10:08:38 -0700
Subject: [PATCH 11/11] initialize retry timer when port is cloned

---
 src/core/lib/iomgr/tcp_server_posix.cc        |  1 +
 src/core/lib/iomgr/tcp_server_utils_posix.h   |  6 ++++++
 .../iomgr/tcp_server_utils_posix_common.cc    | 21 ++++++++++++-------
 3 files changed, 20 insertions(+), 8 deletions(-)

diff --git a/src/core/lib/iomgr/tcp_server_posix.cc b/src/core/lib/iomgr/tcp_server_posix.cc
index ee122a59f650..1640c8baf61b 100644
--- a/src/core/lib/iomgr/tcp_server_posix.cc
+++ b/src/core/lib/iomgr/tcp_server_posix.cc
@@ -590,6 +590,7 @@ static grpc_error_handle clone_port(grpc_tcp_listener* listener,
     sp->port_index = listener->port_index;
     sp->fd_index = listener->fd_index + count - i;
     GPR_ASSERT(sp->emfd);
+    grpc_tcp_server_listener_initialize_retry_timer(sp);
     while (listener->server->tail->next != nullptr) {
       listener->server->tail = listener->server->tail->next;
     }
diff --git a/src/core/lib/iomgr/tcp_server_utils_posix.h b/src/core/lib/iomgr/tcp_server_utils_posix.h
index a7fd947358bc..afe6833e60d9 100644
--- a/src/core/lib/iomgr/tcp_server_utils_posix.h
+++ b/src/core/lib/iomgr/tcp_server_utils_posix.h
@@ -145,4 +145,10 @@ grpc_error_handle grpc_tcp_server_prepare_socket(
 // Ruturn true if the platform supports ifaddrs
 bool grpc_tcp_server_have_ifaddrs(void);
 
+// Initialize (but don't start) the timer and callback to retry accept4() on a
+// listening socket after file descriptors have been exhausted. This must be
+// called when creating a new listener.
+void grpc_tcp_server_listener_initialize_retry_timer(
+    grpc_tcp_listener* listener);
+
 #endif  // GRPC_SRC_CORE_LIB_IOMGR_TCP_SERVER_UTILS_POSIX_H
diff --git a/src/core/lib/iomgr/tcp_server_utils_posix_common.cc b/src/core/lib/iomgr/tcp_server_utils_posix_common.cc
index df399f5f95dc..23dccc76e03e 100644
--- a/src/core/lib/iomgr/tcp_server_utils_posix_common.cc
+++ b/src/core/lib/iomgr/tcp_server_utils_posix_common.cc
@@ -87,13 +87,21 @@ static int get_max_accept_queue_size(void) {
 static void listener_retry_timer_cb(void* arg, grpc_error_handle err) {
   // Do nothing if cancelled.
   if (!err.ok()) return;
-  grpc_tcp_listener* sp = static_cast<grpc_tcp_listener*>(arg);
-  gpr_atm_no_barrier_store(&sp->retry_timer_armed, false);
-  if (!grpc_fd_is_shutdown(sp->emfd)) {
-    grpc_fd_set_readable(sp->emfd);
+  grpc_tcp_listener* listener = static_cast<grpc_tcp_listener*>(arg);
+  gpr_atm_no_barrier_store(&listener->retry_timer_armed, false);
+  if (!grpc_fd_is_shutdown(listener->emfd)) {
+    grpc_fd_set_readable(listener->emfd);
   }
 }
 
+void grpc_tcp_server_listener_initialize_retry_timer(
+    grpc_tcp_listener* listener) {
+  gpr_atm_no_barrier_store(&listener->retry_timer_armed, false);
+  grpc_timer_init_unset(&listener->retry_timer);
+  GRPC_CLOSURE_INIT(&listener->retry_closure, listener_retry_timer_cb, listener,
+                    grpc_schedule_on_exec_ctx);
+}
+
 static grpc_error_handle add_socket_to_server(grpc_tcp_server* s, int fd,
                                               const grpc_resolved_address* addr,
                                               unsigned port_index,
@@ -125,10 +133,7 @@ static grpc_error_handle add_socket_to_server(grpc_tcp_server* s, int fd,
   sp->server = s;
   sp->fd = fd;
   sp->emfd = grpc_fd_create(fd, name.c_str(), true);
-  gpr_atm_no_barrier_store(&sp->retry_timer_armed, false);
-  grpc_timer_init_unset(&sp->retry_timer);
-  GRPC_CLOSURE_INIT(&sp->retry_closure, listener_retry_timer_cb, sp,
-                    grpc_schedule_on_exec_ctx);
+  grpc_tcp_server_listener_initialize_retry_timer(sp);
 
   // Check and set fd as prellocated
   if (grpc_tcp_server_pre_allocated_fd(s) == fd) {
