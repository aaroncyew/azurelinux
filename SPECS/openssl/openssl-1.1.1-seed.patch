diff --git a/crypto/rand/drbg_lib.c b/crypto/rand/drbg_lib.c
index 5d7a1d7..b4f996a 100644
--- a/crypto/rand/drbg_lib.c
+++ b/crypto/rand/drbg_lib.c
@@ -298,6 +298,12 @@ int RAND_DRBG_instantiate(RAND_DRBG *drbg,
     size_t min_entropy = drbg->strength;
     size_t min_entropylen = drbg->min_entropylen;
     size_t max_entropylen = drbg->max_entropylen;
+#ifdef OPENSSL_FIPS
+    unsigned char *tmp_pers = NULL;
+    size_t pers_idx = 0, bytes_needed = 0, tmp_perslen = 0;
+    ssize_t bytes = 0;
+    int rng_attempts = 3;
+#endif
 
     if (perslen > drbg->max_perslen) {
         RANDerr(RAND_F_RAND_DRBG_INSTANTIATE,
@@ -350,6 +356,48 @@ int RAND_DRBG_instantiate(RAND_DRBG *drbg,
         }
     }
 
+#ifdef OPENSSL_FIPS
+    if (FIPS_mode()) {
+        // Concatenate personalization string with output from Linux RNG
+        bytes_needed = drbg->strength / 8;
+        tmp_perslen = perslen;
+        if (tmp_perslen + bytes_needed > drbg->max_perslen) {
+            RANDerr(RAND_F_RAND_DRBG_INSTANTIATE,
+                    RAND_R_PERSONALISATION_STRING_TOO_LONG);
+            goto end;
+        }
+
+        tmp_pers = OPENSSL_zalloc(bytes_needed + tmp_perslen);
+        if (tmp_pers == NULL) {
+            goto end;
+        }
+
+        if (pers != NULL) {
+            memcpy(tmp_pers, pers, tmp_perslen);
+        }
+
+        pers_idx = tmp_perslen;
+
+        while (bytes_needed != 0 && rng_attempts-- > 0) {
+            bytes = syscall_random(tmp_pers + pers_idx, bytes_needed, 0);
+            if (bytes > 0) {
+                pers_idx += bytes;
+                bytes_needed -= bytes;
+                rng_attempts = 3; /* reset counter after successful attempt */
+            } else if (bytes < 0 && errno != EINTR) {
+                break;
+            }
+        }
+
+        if (bytes_needed > 0) {
+            goto end;
+        }
+
+        pers = tmp_pers;
+        perslen = tmp_perslen + drbg->strength / 8;
+    }
+#endif
+
     if (!drbg->meth->instantiate(drbg, entropy, entropylen,
                          nonce, noncelen, pers, perslen)) {
         RANDerr(RAND_F_RAND_DRBG_INSTANTIATE, RAND_R_ERROR_INSTANTIATING_DRBG);
@@ -368,6 +416,10 @@ int RAND_DRBG_instantiate(RAND_DRBG *drbg,
     }
 
  end:
+ #ifdef OPENSSL_FIPS
+    if (tmp_pers != NULL)
+        OPENSSL_clear_free(tmp_pers, tmp_perslen + drbg->strength / 8);
+ #endif
     if (entropy != NULL && drbg->cleanup_entropy != NULL)
         drbg->cleanup_entropy(drbg, entropy, entropylen);
     if (nonce != NULL && drbg->cleanup_nonce != NULL)
@@ -414,6 +466,12 @@ int RAND_DRBG_reseed(RAND_DRBG *drbg,
 {
     unsigned char *entropy = NULL;
     size_t entropylen = 0;
+#ifdef OPENSSL_FIPS
+    unsigned char *tmp_adin = NULL;
+    size_t adin_idx = 0, bytes_needed = 0, tmp_adinlen = 0;
+    ssize_t bytes = 0;
+    int rng_attempts = 3;
+#endif
 
     if (drbg->state == DRBG_ERROR) {
         RANDerr(RAND_F_RAND_DRBG_RESEED, RAND_R_IN_ERROR_STATE);
@@ -443,6 +501,47 @@ int RAND_DRBG_reseed(RAND_DRBG *drbg,
         goto end;
     }
 
+#ifdef OPENSSL_FIPS
+    if (FIPS_mode()) {
+        // Concatenate additional input string with output from Linux RNG
+        bytes_needed = drbg->strength / 8;
+        tmp_adinlen = adinlen;
+        if (tmp_adinlen + bytes_needed > drbg->max_adinlen) {
+            RANDerr(RAND_F_RAND_DRBG_RESEED, RAND_R_ADDITIONAL_INPUT_TOO_LONG);
+            goto end;
+        }
+
+        tmp_adin = OPENSSL_zalloc(bytes_needed + tmp_adinlen);
+        if (tmp_adin == NULL) {
+            goto end;
+        }
+
+        if (adin != NULL) {
+            memcpy(tmp_adin, adin, tmp_adinlen);
+        }
+
+        adin_idx = tmp_adinlen;
+
+        while (bytes_needed != 0 && rng_attempts-- > 0) {
+            bytes = syscall_random(tmp_adin + adin_idx, bytes_needed, 0);
+            if (bytes > 0) {
+                adin_idx += bytes;
+                bytes_needed -= bytes;
+                rng_attempts = 3; /* reset counter after successful attempt */
+            } else if (bytes < 0 && errno != EINTR) {
+                break;
+            }
+        }
+
+        if (bytes_needed > 0) {
+            goto end;
+        }
+
+        adin = tmp_adin;
+        adinlen = tmp_adinlen + drbg->strength / 8;
+    }
+#endif
+
     if (!drbg->meth->reseed(drbg, entropy, entropylen, adin, adinlen))
         goto end;
 
@@ -458,6 +557,10 @@ int RAND_DRBG_reseed(RAND_DRBG *drbg,
     }
 
  end:
+#ifdef OPENSSL_FIPS
+    if (tmp_adin != NULL)
+        OPENSSL_clear_free(tmp_adin, tmp_adinlen + drbg->strength / 8);
+#endif
     if (entropy != NULL && drbg->cleanup_entropy != NULL)
         drbg->cleanup_entropy(drbg, entropy, entropylen);
     if (drbg->state == DRBG_READY)
diff --git a/crypto/rand/rand_lib.c b/crypto/rand/rand_lib.c
index d8d3498..fdcb0c8 100644
--- a/crypto/rand/rand_lib.c
+++ b/crypto/rand/rand_lib.c
@@ -243,6 +243,33 @@ size_t rand_drbg_get_nonce(RAND_DRBG *drbg,
         int count;
     } data;
 
+#ifdef OPENSSL_FIPS
+    size_t entropy_available = 0;
+
+    if (FIPS_mode()) {
+        /* Use the SP800-90B compliant entropy source to acquire a nonce */
+        if (entropy < drbg->strength / 2) {
+            entropy = drbg->strength / 2;
+        }
+
+        pool = rand_pool_new(entropy, drbg->secure, min_len, max_len);
+        if (pool == NULL)
+            return 0;
+
+        entropy_available = rand_pool_acquire_entropy(pool);
+
+        if (entropy_available > 0) {
+            CRYPTO_atomic_add(&rand_nonce_count, 1, &data.count, rand_nonce_lock);
+            ret = rand_pool_length(pool);
+            *pout = rand_pool_detach(pool);
+        }
+
+        rand_pool_free(pool);
+
+        return ret;
+    }
+#endif
+
     memset(&data, 0, sizeof(data));
     pool = rand_pool_new(0, 0, min_len, max_len);
     if (pool == NULL)
diff --git a/crypto/rand/rand_unix.c b/crypto/rand/rand_unix.c
index 4c2d54e..722d721 100644
--- a/crypto/rand/rand_unix.c
+++ b/crypto/rand/rand_unix.c
@@ -346,7 +346,7 @@ static ssize_t sysctl_random(char *buf, size_t buflen)
  * syscall_random(): Try to get random data using a system call
  * returns the number of bytes returned in buf, or < 0 on error.
  */
-static ssize_t syscall_random(void *buf, size_t buflen, int nonblock)
+ssize_t syscall_random(void *buf, size_t buflen, int nonblock)
 {
     /*
      * Note: 'buflen' equals the size of the buffer which is used by the
diff --git a/include/crypto/rand.h b/include/crypto/rand.h
index 479c16d..e9ebb73 100644
--- a/include/crypto/rand.h
+++ b/include/crypto/rand.h
@@ -145,4 +145,9 @@ void rand_pool_keep_random_devices_open(int keep);
  */
 int rand_drbg_selftest(void);
 
+/*
+ * Acquire random bits from Linux RNG
+ */
+ssize_t syscall_random(void *buf, size_t buflen, int nonblock);
+
 #endif
diff --git a/util/libcrypto.num b/util/libcrypto.num
index e354631..834ad60 100644
--- a/util/libcrypto.num
+++ b/util/libcrypto.num
@@ -4635,4 +4635,5 @@ EVP_KDF_ctrl_str                        6595	1_1_1b	EXIST::FUNCTION:
 EVP_KDF_size                            6596	1_1_1b	EXIST::FUNCTION:
 EVP_KDF_derive                          6597	1_1_1b	EXIST::FUNCTION:
 EC_GROUP_check_named_curve              6598    1_1_1g	EXIST::FUNCTION:EC
-FIPS_init_entropy                       6599    1_1_1k  EXIST::FUNCTION:
\ No newline at end of file
+FIPS_init_entropy                       6599    1_1_1k  EXIST::FUNCTION:
+syscall_random                          6600    1_1_1k  EXIST::FUNCTION:
\ No newline at end of file
