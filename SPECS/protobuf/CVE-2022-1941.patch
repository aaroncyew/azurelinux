diff --git protobuf-3.17.3protobuf-3.17.3/src/google/protobuf/extension_set_inl.h protobuf-3.17.3-patchedprotobuf-3.17.3-patched/src/google/protobuf/extension_set_inl.h
index 074784b..f88e170 100644
--- protobuf-3.17.3protobuf-3.17.3/src/google/protobuf/extension_set_inl.h
+++ protobuf-3.17.3-patchedprotobuf-3.17.3-patched/src/google/protobuf/extension_set_inl.h
@@ -31,9 +31,9 @@
 #ifndef GOOGLE_PROTOBUF_EXTENSION_SET_INL_H__
 #define GOOGLE_PROTOBUF_EXTENSION_SET_INL_H__
 
-#include <google/protobuf/parse_context.h>
 #include <google/protobuf/extension_set.h>
 #include <google/protobuf/metadata_lite.h>
+#include <google/protobuf/parse_context.h>
 
 namespace google {
 namespace protobuf {
@@ -83,7 +83,7 @@ const char* ExtensionSet::ParseFieldWithExtensionInfo(
     switch (extension.type) {
 #define HANDLE_VARINT_TYPE(UPPERCASE, CPP_CAMELCASE)                        \
   case WireFormatLite::TYPE_##UPPERCASE: {                                  \
-    uint64 value;                                                           \
+    uint64_t value;                                                         \
     ptr = VarintParse(ptr, &value);                                         \
     GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);                                    \
     if (extension.is_repeated) {                                            \
@@ -103,7 +103,7 @@ const char* ExtensionSet::ParseFieldWithExtensionInfo(
 #undef HANDLE_VARINT_TYPE
 #define HANDLE_SVARINT_TYPE(UPPERCASE, CPP_CAMELCASE, SIZE)                 \
   case WireFormatLite::TYPE_##UPPERCASE: {                                  \
-    uint64 val;                                                             \
+    uint64_t val;                                                             \
     ptr = VarintParse(ptr, &val);                                           \
     GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);                                    \
     auto value = WireFormatLite::ZigZagDecode##SIZE(val);                   \
@@ -132,16 +132,16 @@ const char* ExtensionSet::ParseFieldWithExtensionInfo(
     }                                                                       \
   } break
 
-      HANDLE_FIXED_TYPE(FIXED32, UInt32, uint32);
-      HANDLE_FIXED_TYPE(FIXED64, UInt64, uint64);
-      HANDLE_FIXED_TYPE(SFIXED32, Int32, int32);
-      HANDLE_FIXED_TYPE(SFIXED64, Int64, int64);
+      HANDLE_FIXED_TYPE(FIXED32, UInt32, uint32_t);
+      HANDLE_FIXED_TYPE(FIXED64, UInt64, uint64_t);
+      HANDLE_FIXED_TYPE(SFIXED32, Int32, int32_t);
+      HANDLE_FIXED_TYPE(SFIXED64, Int64, int64_t);
       HANDLE_FIXED_TYPE(FLOAT, Float, float);
       HANDLE_FIXED_TYPE(DOUBLE, Double, double);
 #undef HANDLE_FIXED_TYPE
 
       case WireFormatLite::TYPE_ENUM: {
-        uint64 val;
+        uint64_t val;
         ptr = VarintParse(ptr, &val);
         GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
         int value = val;
@@ -181,7 +181,7 @@ const char* ExtensionSet::ParseFieldWithExtensionInfo(
                 : MutableMessage(number, WireFormatLite::TYPE_GROUP,
                                  *extension.message_info.prototype,
                                  extension.descriptor);
-        uint32 tag = (number << 3) + WireFormatLite::WIRETYPE_START_GROUP;
+        uint32_t tag = (number << 3) + WireFormatLite::WIRETYPE_START_GROUP;
         return ctx->ParseGroup(value, ptr, tag);
       }
 
@@ -203,22 +203,27 @@ const char* ExtensionSet::ParseFieldWithExtensionInfo(
 
 template <typename Msg, typename T>
 const char* ExtensionSet::ParseMessageSetItemTmpl(
-    const char* ptr, const Msg* containing_type,
-    internal::InternalMetadata* metadata, internal::ParseContext* ctx) {
+    const char* ptr, const Msg* extendee, internal::InternalMetadata* metadata,
+    internal::ParseContext* ctx) {
   std::string payload;
-  uint32 type_id = 0;
-  bool payload_read = false;
+  uint32_t type_id;
+  enum class State { kNoTag, kHasType, kHasPayload, kDone };
+  State state = State::kNoTag;
+
   while (!ctx->Done(&ptr)) {
-    uint32 tag = static_cast<uint8>(*ptr++);
+    uint32_t tag = static_cast<uint8_t>(*ptr++);
     if (tag == WireFormatLite::kMessageSetTypeIdTag) {
-      uint64 tmp;
+      uint64_t tmp;
       ptr = ParseBigVarint(ptr, &tmp);
       GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
-      type_id = tmp;
-      if (payload_read) {
+      if (state == State::kNoTag) {
+        type_id = tmp;
+        state = State::kHasType;
+      } else if (state == State::kHasPayload) {
+        type_id = tmp;
         ExtensionInfo extension;
         bool was_packed_on_wire;
-        if (!FindExtension(2, type_id, containing_type, ctx, &extension,
+        if (!FindExtension(2, type_id, extendee, ctx, &extension,
                            &was_packed_on_wire)) {
           WriteLengthDelimited(type_id, payload,
                                metadata->mutable_unknown_fields<T>());
@@ -241,20 +246,24 @@ const char* ExtensionSet::ParseMessageSetItemTmpl(
           GOOGLE_PROTOBUF_PARSER_ASSERT(value->_InternalParse(p, &tmp_ctx) &&
                                          tmp_ctx.EndedAtLimit());
         }
-        type_id = 0;
+        state = State::kDone;
       }
     } else if (tag == WireFormatLite::kMessageSetMessageTag) {
-      if (type_id != 0) {
-        ptr = ParseFieldMaybeLazily(static_cast<uint64>(type_id) * 8 + 2, ptr,
-                                    containing_type, metadata, ctx);
+      if (state == State::kHasType) {
+        ptr = ParseFieldMaybeLazily(static_cast<uint64_t>(type_id) * 8 + 2, ptr,
+                                    extendee, metadata, ctx);
         GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
-        type_id = 0;
+        state = State::kDone;
       } else {
-        int32 size = ReadSize(&ptr);
+        std::string tmp;
+        int32_t size = ReadSize(&ptr);
         GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
-        ptr = ctx->ReadString(ptr, size, &payload);
+        ptr = ctx->ReadString(ptr, size, &tmp);
         GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
-        payload_read = true;
+        if (state == State::kNoTag) {
+          payload = std::move(tmp);
+          state = State::kHasPayload;
+        }
       }
     } else {
       ptr = ReadTag(ptr - 1, &tag);
@@ -262,7 +271,7 @@ const char* ExtensionSet::ParseMessageSetItemTmpl(
         ctx->SetLastTag(tag);
         return ptr;
       }
-      ptr = ParseField(tag, ptr, containing_type, metadata, ctx);
+      ptr = ParseField(tag, ptr, extendee, metadata, ctx);
       GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
     }
   }
diff --git protobuf-3.17.3protobuf-3.17.3/src/google/protobuf/io/coded_stream.cc protobuf-3.17.3-patchedprotobuf-3.17.3-patched/src/google/protobuf/io/coded_stream.cc
index a318da4..0546393 100644
--- protobuf-3.17.3protobuf-3.17.3/src/google/protobuf/io/coded_stream.cc
+++ protobuf-3.17.3-patchedprotobuf-3.17.3-patched/src/google/protobuf/io/coded_stream.cc
@@ -54,6 +54,7 @@
 #include <google/protobuf/stubs/stl_util.h>
 
 
+// Must be included last.
 #include <google/protobuf/port_def.inc>
 
 namespace google {
@@ -151,7 +152,7 @@ CodedInputStream::IncrementRecursionDepthAndPushLimit(int byte_limit) {
 }
 
 CodedInputStream::Limit CodedInputStream::ReadLengthAndPushLimit() {
-  uint32 length;
+  uint32_t length;
   return PushLimit(ReadVarint32(&length) ? length : 0);
 }
 
@@ -243,7 +244,7 @@ bool CodedInputStream::ReadRaw(void* buffer, int size) {
   while ((current_buffer_size = BufferSize()) < size) {
     // Reading past end of buffer.  Copy what we have, then refresh.
     memcpy(buffer, buffer_, current_buffer_size);
-    buffer = reinterpret_cast<uint8*>(buffer) + current_buffer_size;
+    buffer = reinterpret_cast<uint8_t*>(buffer) + current_buffer_size;
     size -= current_buffer_size;
     Advance(current_buffer_size);
     if (!Refresh()) return false;
@@ -308,11 +309,11 @@ bool CodedInputStream::ReadStringFallback(std::string* buffer, int size) {
 }
 
 
-bool CodedInputStream::ReadLittleEndian32Fallback(uint32* value) {
-  uint8 bytes[sizeof(*value)];
+bool CodedInputStream::ReadLittleEndian32Fallback(uint32_t* value) {
+  uint8_t bytes[sizeof(*value)];
 
-  const uint8* ptr;
-  if (BufferSize() >= static_cast<int64>(sizeof(*value))) {
+  const uint8_t* ptr;
+  if (BufferSize() >= static_cast<int64_t>(sizeof(*value))) {
     // Fast path:  Enough bytes in the buffer to read directly.
     ptr = buffer_;
     Advance(sizeof(*value));
@@ -325,11 +326,11 @@ bool CodedInputStream::ReadLittleEndian32Fallback(uint32* value) {
   return true;
 }
 
-bool CodedInputStream::ReadLittleEndian64Fallback(uint64* value) {
-  uint8 bytes[sizeof(*value)];
+bool CodedInputStream::ReadLittleEndian64Fallback(uint64_t* value) {
+  uint8_t bytes[sizeof(*value)];
 
-  const uint8* ptr;
-  if (BufferSize() >= static_cast<int64>(sizeof(*value))) {
+  const uint8_t* ptr;
+  if (BufferSize() >= static_cast<int64_t>(sizeof(*value))) {
     // Fast path:  Enough bytes in the buffer to read directly.
     ptr = buffer_;
     Advance(sizeof(*value));
@@ -348,11 +349,11 @@ namespace {
 // compile time, compiler can generate optimal code. For example, instead of
 // subtracting 0x80 at each iteration, it subtracts properly shifted mask once.
 template <size_t N>
-const uint8* DecodeVarint64KnownSize(const uint8* buffer, uint64* value) {
+const uint8_t* DecodeVarint64KnownSize(const uint8_t* buffer, uint64_t* value) {
   GOOGLE_DCHECK_GT(N, 0);
-  uint64 result = static_cast<uint64>(buffer[N - 1]) << (7 * (N - 1));
+  uint64_t result = static_cast<uint64_t>(buffer[N - 1]) << (7 * (N - 1));
   for (size_t i = 0, offset = 0; i < N - 1; i++, offset += 7) {
-    result += static_cast<uint64>(buffer[i] - 0x80) << offset;
+    result += static_cast<uint64_t>(buffer[i] - 0x80) << offset;
   }
   *value = result;
   return buffer + N;
@@ -363,18 +364,18 @@ const uint8* DecodeVarint64KnownSize(const uint8* buffer, uint64* value) {
 // part is buffer + (number of bytes read).  This function is always inlined,
 // so returning a pair is costless.
 PROTOBUF_ALWAYS_INLINE
-::std::pair<bool, const uint8*> ReadVarint32FromArray(uint32 first_byte,
-                                                      const uint8* buffer,
-                                                      uint32* value);
-inline ::std::pair<bool, const uint8*> ReadVarint32FromArray(
-    uint32 first_byte, const uint8* buffer, uint32* value) {
+::std::pair<bool, const uint8_t*> ReadVarint32FromArray(uint32_t first_byte,
+                                                      const uint8_t* buffer,
+                                                      uint32_t* value);
+inline ::std::pair<bool, const uint8_t*> ReadVarint32FromArray(
+    uint32_t first_byte, const uint8_t* buffer, uint32_t* value) {
   // Fast path:  We have enough bytes left in the buffer to guarantee that
   // this read won't cross the end, so we can skip the checks.
   GOOGLE_DCHECK_EQ(*buffer, first_byte);
   GOOGLE_DCHECK_EQ(first_byte & 0x80, 0x80) << first_byte;
-  const uint8* ptr = buffer;
-  uint32 b;
-  uint32 result = first_byte - 0x80;
+  const uint8_t* ptr = buffer;
+  uint32_t b;
+  uint32_t result = first_byte - 0x80;
   ++ptr;  // We just processed the first byte.  Move on to the second.
   b = *(ptr++);
   result += b << 7;
@@ -409,14 +410,14 @@ done:
   return std::make_pair(true, ptr);
 }
 
-PROTOBUF_ALWAYS_INLINE::std::pair<bool, const uint8*> ReadVarint64FromArray(
-    const uint8* buffer, uint64* value);
-inline ::std::pair<bool, const uint8*> ReadVarint64FromArray(
-    const uint8* buffer, uint64* value) {
+PROTOBUF_ALWAYS_INLINE::std::pair<bool, const uint8_t*> ReadVarint64FromArray(
+    const uint8_t* buffer, uint64_t* value);
+inline ::std::pair<bool, const uint8_t*> ReadVarint64FromArray(
+    const uint8_t* buffer, uint64_t* value) {
   // Assumes varint64 is at least 2 bytes.
   GOOGLE_DCHECK_GE(buffer[0], 128);
 
-  const uint8* next;
+  const uint8_t* next;
   if (buffer[1] < 128) {
     next = DecodeVarint64KnownSize<2>(buffer, value);
   } else if (buffer[2] < 128) {
@@ -446,23 +447,23 @@ inline ::std::pair<bool, const uint8*> ReadVarint64FromArray(
 
 }  // namespace
 
-bool CodedInputStream::ReadVarint32Slow(uint32* value) {
+bool CodedInputStream::ReadVarint32Slow(uint32_t* value) {
   // Directly invoke ReadVarint64Fallback, since we already tried to optimize
   // for one-byte varints.
-  std::pair<uint64, bool> p = ReadVarint64Fallback();
-  *value = static_cast<uint32>(p.first);
+  std::pair<uint64_t, bool> p = ReadVarint64Fallback();
+  *value = static_cast<uint32_t>(p.first);
   return p.second;
 }
 
-int64 CodedInputStream::ReadVarint32Fallback(uint32 first_byte_or_zero) {
+int64_t CodedInputStream::ReadVarint32Fallback(uint32_t first_byte_or_zero) {
   if (BufferSize() >= kMaxVarintBytes ||
       // Optimization:  We're also safe if the buffer is non-empty and it ends
       // with a byte that would terminate a varint.
       (buffer_end_ > buffer_ && !(buffer_end_[-1] & 0x80))) {
     GOOGLE_DCHECK_NE(first_byte_or_zero, 0)
         << "Caller should provide us with *buffer_ when buffer is non-empty";
-    uint32 temp;
-    ::std::pair<bool, const uint8*> p =
+    uint32_t temp;
+    ::std::pair<bool, const uint8_t*> p =
         ReadVarint32FromArray(first_byte_or_zero, buffer_, &temp);
     if (!p.first) return -1;
     buffer_ = p.second;
@@ -471,16 +472,16 @@ int64 CodedInputStream::ReadVarint32Fallback(uint32 first_byte_or_zero) {
     // Really slow case: we will incur the cost of an extra function call here,
     // but moving this out of line reduces the size of this function, which
     // improves the common case. In micro benchmarks, this is worth about 10-15%
-    uint32 temp;
-    return ReadVarint32Slow(&temp) ? static_cast<int64>(temp) : -1;
+    uint32_t temp;
+    return ReadVarint32Slow(&temp) ? static_cast<int64_t>(temp) : -1;
   }
 }
 
 int CodedInputStream::ReadVarintSizeAsIntSlow() {
   // Directly invoke ReadVarint64Fallback, since we already tried to optimize
   // for one-byte varints.
-  std::pair<uint64, bool> p = ReadVarint64Fallback();
-  if (!p.second || p.first > static_cast<uint64>(INT_MAX)) return -1;
+  std::pair<uint64_t, bool> p = ReadVarint64Fallback();
+  if (!p.second || p.first > static_cast<uint64_t>(INT_MAX)) return -1;
   return p.first;
 }
 
@@ -489,9 +490,9 @@ int CodedInputStream::ReadVarintSizeAsIntFallback() {
       // Optimization:  We're also safe if the buffer is non-empty and it ends
       // with a byte that would terminate a varint.
       (buffer_end_ > buffer_ && !(buffer_end_[-1] & 0x80))) {
-    uint64 temp;
-    ::std::pair<bool, const uint8*> p = ReadVarint64FromArray(buffer_, &temp);
-    if (!p.first || temp > static_cast<uint64>(INT_MAX)) return -1;
+    uint64_t temp;
+    ::std::pair<bool, const uint8_t*> p = ReadVarint64FromArray(buffer_, &temp);
+    if (!p.first || temp > static_cast<uint64_t>(INT_MAX)) return -1;
     buffer_ = p.second;
     return temp;
   } else {
@@ -502,7 +503,7 @@ int CodedInputStream::ReadVarintSizeAsIntFallback() {
   }
 }
 
-uint32 CodedInputStream::ReadTagSlow() {
+uint32_t CodedInputStream::ReadTagSlow() {
   if (buffer_ == buffer_end_) {
     // Call refresh.
     if (!Refresh()) {
@@ -523,12 +524,12 @@ uint32 CodedInputStream::ReadTagSlow() {
 
   // For the slow path, just do a 64-bit read. Try to optimize for one-byte tags
   // again, since we have now refreshed the buffer.
-  uint64 result = 0;
+  uint64_t result = 0;
   if (!ReadVarint64(&result)) return 0;
-  return static_cast<uint32>(result);
+  return static_cast<uint32_t>(result);
 }
 
-uint32 CodedInputStream::ReadTagFallback(uint32 first_byte_or_zero) {
+uint32_t CodedInputStream::ReadTagFallback(uint32_t first_byte_or_zero) {
   const int buf_size = BufferSize();
   if (buf_size >= kMaxVarintBytes ||
       // Optimization:  We're also safe if the buffer is non-empty and it ends
@@ -539,8 +540,8 @@ uint32 CodedInputStream::ReadTagFallback(uint32 first_byte_or_zero) {
       ++buffer_;
       return 0;
     }
-    uint32 tag;
-    ::std::pair<bool, const uint8*> p =
+    uint32_t tag;
+    ::std::pair<bool, const uint8_t*> p =
         ReadVarint32FromArray(first_byte_or_zero, buffer_, &tag);
     if (!p.first) {
       return 0;
@@ -565,13 +566,13 @@ uint32 CodedInputStream::ReadTagFallback(uint32 first_byte_or_zero) {
   }
 }
 
-bool CodedInputStream::ReadVarint64Slow(uint64* value) {
+bool CodedInputStream::ReadVarint64Slow(uint64_t* value) {
   // Slow path:  This read might cross the end of the buffer, so we
   // need to check and refresh the buffer if and when it does.
 
-  uint64 result = 0;
+  uint64_t result = 0;
   int count = 0;
-  uint32 b;
+  uint32_t b;
 
   do {
     if (count == kMaxVarintBytes) {
@@ -585,7 +586,7 @@ bool CodedInputStream::ReadVarint64Slow(uint64* value) {
       }
     }
     b = *buffer_;
-    result |= static_cast<uint64>(b & 0x7F) << (7 * count);
+    result |= static_cast<uint64_t>(b & 0x7F) << (7 * count);
     Advance(1);
     ++count;
   } while (b & 0x80);
@@ -594,20 +595,20 @@ bool CodedInputStream::ReadVarint64Slow(uint64* value) {
   return true;
 }
 
-std::pair<uint64, bool> CodedInputStream::ReadVarint64Fallback() {
+std::pair<uint64_t, bool> CodedInputStream::ReadVarint64Fallback() {
   if (BufferSize() >= kMaxVarintBytes ||
       // Optimization:  We're also safe if the buffer is non-empty and it ends
       // with a byte that would terminate a varint.
       (buffer_end_ > buffer_ && !(buffer_end_[-1] & 0x80))) {
-    uint64 temp;
-    ::std::pair<bool, const uint8*> p = ReadVarint64FromArray(buffer_, &temp);
+    uint64_t temp;
+    ::std::pair<bool, const uint8_t*> p = ReadVarint64FromArray(buffer_, &temp);
     if (!p.first) {
       return std::make_pair(0, false);
     }
     buffer_ = p.second;
     return std::make_pair(temp, true);
   } else {
-    uint64 temp;
+    uint64_t temp;
     bool success = ReadVarint64Slow(&temp);
     return std::make_pair(temp, success);
   }
@@ -633,7 +634,7 @@ bool CodedInputStream::Refresh() {
   const void* void_buffer;
   int buffer_size;
   if (NextNonEmpty(input_, &void_buffer, &buffer_size)) {
-    buffer_ = reinterpret_cast<const uint8*>(void_buffer);
+    buffer_ = reinterpret_cast<const uint8_t*>(void_buffer);
     buffer_end_ = buffer_ + buffer_size;
     GOOGLE_CHECK_GE(buffer_size, 0);
 
@@ -670,7 +671,7 @@ void EpsCopyOutputStream::EnableAliasing(bool enabled) {
   aliasing_enabled_ = enabled && stream_->AllowsAliasing();
 }
 
-int64 EpsCopyOutputStream::ByteCount(uint8* ptr) const {
+int64_t EpsCopyOutputStream::ByteCount(uint8_t* ptr) const {
   // Calculate the current offset relative to the end of the stream buffer.
   int delta = (end_ - ptr) + (buffer_end_ ? 0 : kSlopBytes);
   return stream_->ByteCount() - delta;
@@ -679,7 +680,7 @@ int64 EpsCopyOutputStream::ByteCount(uint8* ptr) const {
 // Flushes what's written out to the underlying ZeroCopyOutputStream buffers.
 // Returns the size remaining in the buffer and sets buffer_end_ to the start
 // of the remaining buffer, ie. [buffer_end_, buffer_end_ + return value)
-int EpsCopyOutputStream::Flush(uint8* ptr) {
+int EpsCopyOutputStream::Flush(uint8_t* ptr) {
   while (buffer_end_ && ptr > end_) {
     int overrun = ptr - end_;
     GOOGLE_DCHECK(!had_error_);
@@ -701,24 +702,24 @@ int EpsCopyOutputStream::Flush(uint8* ptr) {
   return s;
 }
 
-uint8* EpsCopyOutputStream::Trim(uint8* ptr) {
+uint8_t* EpsCopyOutputStream::Trim(uint8_t* ptr) {
   if (had_error_) return ptr;
   int s = Flush(ptr);
-  if (s) stream_->BackUp(s);
+  stream_->BackUp(s);
   // Reset to initial state (expecting new buffer)
   buffer_end_ = end_ = buffer_;
   return buffer_;
 }
 
 
-uint8* EpsCopyOutputStream::FlushAndResetBuffer(uint8* ptr) {
+uint8_t* EpsCopyOutputStream::FlushAndResetBuffer(uint8_t* ptr) {
   if (had_error_) return buffer_;
   int s = Flush(ptr);
   if (had_error_) return buffer_;
   return SetInitialBuffer(buffer_end_, s);
 }
 
-bool EpsCopyOutputStream::Skip(int count, uint8** pp) {
+bool EpsCopyOutputStream::Skip(int count, uint8_t** pp) {
   if (count < 0) return false;
   if (had_error_) {
     *pp = buffer_;
@@ -737,12 +738,12 @@ bool EpsCopyOutputStream::Skip(int count, uint8** pp) {
       return false;
     }
   }
-  *pp = SetInitialBuffer(static_cast<uint8*>(data) + count, size - count);
+  *pp = SetInitialBuffer(static_cast<uint8_t*>(data) + count, size - count);
   return true;
 }
 
 bool EpsCopyOutputStream::GetDirectBufferPointer(void** data, int* size,
-                                                 uint8** pp) {
+                                                 uint8_t** pp) {
   if (had_error_) {
     *pp = buffer_;
     return false;
@@ -763,8 +764,8 @@ bool EpsCopyOutputStream::GetDirectBufferPointer(void** data, int* size,
   return true;
 }
 
-uint8* EpsCopyOutputStream::GetDirectBufferForNBytesAndAdvance(int size,
-                                                               uint8** pp) {
+uint8_t* EpsCopyOutputStream::GetDirectBufferForNBytesAndAdvance(int size,
+                                                               uint8_t** pp) {
   if (had_error_) {
     *pp = buffer_;
     return nullptr;
@@ -784,13 +785,13 @@ uint8* EpsCopyOutputStream::GetDirectBufferForNBytesAndAdvance(int size,
   }
 }
 
-uint8* EpsCopyOutputStream::Next() {
+uint8_t* EpsCopyOutputStream::Next() {
   GOOGLE_DCHECK(!had_error_);  // NOLINT
   if (PROTOBUF_PREDICT_FALSE(stream_ == nullptr)) return Error();
   if (buffer_end_) {
     // We're in the patch buffer and need to fill up the previous buffer.
     std::memcpy(buffer_end_, buffer_, end_ - buffer_);
-    uint8* ptr;
+    uint8_t* ptr;
     int size;
     do {
       void* data;
@@ -799,7 +800,7 @@ uint8* EpsCopyOutputStream::Next() {
         // able to write.
         return Error();
       }
-      ptr = static_cast<uint8*>(data);
+      ptr = static_cast<uint8_t*>(data);
     } while (size == 0);
     if (PROTOBUF_PREDICT_TRUE(size > kSlopBytes)) {
       std::memcpy(ptr, end_, kSlopBytes);
@@ -822,7 +823,7 @@ uint8* EpsCopyOutputStream::Next() {
   }
 }
 
-uint8* EpsCopyOutputStream::EnsureSpaceFallback(uint8* ptr) {
+uint8_t* EpsCopyOutputStream::EnsureSpaceFallback(uint8_t* ptr) {
   do {
     if (PROTOBUF_PREDICT_FALSE(had_error_)) return buffer_;
     int overrun = ptr - end_;
@@ -834,13 +835,13 @@ uint8* EpsCopyOutputStream::EnsureSpaceFallback(uint8* ptr) {
   return ptr;
 }
 
-uint8* EpsCopyOutputStream::WriteRawFallback(const void* data, int size,
-                                             uint8* ptr) {
+uint8_t* EpsCopyOutputStream::WriteRawFallback(const void* data, int size,
+                                             uint8_t* ptr) {
   int s = GetSize(ptr);
   while (s < size) {
     std::memcpy(ptr, data, s);
     size -= s;
-    data = static_cast<const uint8*>(data) + s;
+    data = static_cast<const uint8_t*>(data) + s;
     ptr = EnsureSpaceFallback(ptr + s);
     s = GetSize(ptr);
   }
@@ -848,8 +849,8 @@ uint8* EpsCopyOutputStream::WriteRawFallback(const void* data, int size,
   return ptr + size;
 }
 
-uint8* EpsCopyOutputStream::WriteAliasedRaw(const void* data, int size,
-                                            uint8* ptr) {
+uint8_t* EpsCopyOutputStream::WriteAliasedRaw(const void* data, int size,
+                                            uint8_t* ptr) {
   if (size < GetSize(ptr)
   ) {
     return WriteRaw(data, size, ptr);
@@ -861,13 +862,13 @@ uint8* EpsCopyOutputStream::WriteAliasedRaw(const void* data, int size,
 }
 
 #ifndef PROTOBUF_LITTLE_ENDIAN
-uint8* EpsCopyOutputStream::WriteRawLittleEndian32(const void* data, int size,
-                                                   uint8* ptr) {
-  auto p = static_cast<const uint8*>(data);
+uint8_t* EpsCopyOutputStream::WriteRawLittleEndian32(const void* data, int size,
+                                                   uint8_t* ptr) {
+  auto p = static_cast<const uint8_t*>(data);
   auto end = p + size;
   while (end - p >= kSlopBytes) {
     ptr = EnsureSpace(ptr);
-    uint32 buffer[4];
+    uint32_t buffer[4];
     static_assert(sizeof(buffer) == kSlopBytes, "Buffer must be kSlopBytes");
     std::memcpy(buffer, p, kSlopBytes);
     p += kSlopBytes;
@@ -876,7 +877,7 @@ uint8* EpsCopyOutputStream::WriteRawLittleEndian32(const void* data, int size,
   }
   while (p < end) {
     ptr = EnsureSpace(ptr);
-    uint32 buffer;
+    uint32_t buffer;
     std::memcpy(&buffer, p, 4);
     p += 4;
     ptr = CodedOutputStream::WriteLittleEndian32ToArray(buffer, ptr);
@@ -884,13 +885,13 @@ uint8* EpsCopyOutputStream::WriteRawLittleEndian32(const void* data, int size,
   return ptr;
 }
 
-uint8* EpsCopyOutputStream::WriteRawLittleEndian64(const void* data, int size,
-                                                   uint8* ptr) {
-  auto p = static_cast<const uint8*>(data);
+uint8_t* EpsCopyOutputStream::WriteRawLittleEndian64(const void* data, int size,
+                                                   uint8_t* ptr) {
+  auto p = static_cast<const uint8_t*>(data);
   auto end = p + size;
   while (end - p >= kSlopBytes) {
     ptr = EnsureSpace(ptr);
-    uint64 buffer[2];
+    uint64_t buffer[2];
     static_assert(sizeof(buffer) == kSlopBytes, "Buffer must be kSlopBytes");
     std::memcpy(buffer, p, kSlopBytes);
     p += kSlopBytes;
@@ -899,7 +900,7 @@ uint8* EpsCopyOutputStream::WriteRawLittleEndian64(const void* data, int size,
   }
   while (p < end) {
     ptr = EnsureSpace(ptr);
-    uint64 buffer;
+    uint64_t buffer;
     std::memcpy(&buffer, p, 8);
     p += 8;
     ptr = CodedOutputStream::WriteLittleEndian64ToArray(buffer, ptr);
@@ -909,19 +910,19 @@ uint8* EpsCopyOutputStream::WriteRawLittleEndian64(const void* data, int size,
 #endif
 
 
-uint8* EpsCopyOutputStream::WriteStringMaybeAliasedOutline(uint32 num,
+uint8_t* EpsCopyOutputStream::WriteStringMaybeAliasedOutline(uint32_t num,
                                                            const std::string& s,
-                                                           uint8* ptr) {
+                                                           uint8_t* ptr) {
   ptr = EnsureSpace(ptr);
-  uint32 size = s.size();
+  uint32_t size = s.size();
   ptr = WriteLengthDelim(num, size, ptr);
   return WriteRawMaybeAliased(s.data(), size, ptr);
 }
 
-uint8* EpsCopyOutputStream::WriteStringOutline(uint32 num, const std::string& s,
-                                               uint8* ptr) {
+uint8_t* EpsCopyOutputStream::WriteStringOutline(uint32_t num, const std::string& s,
+                                               uint8_t* ptr) {
   ptr = EnsureSpace(ptr);
-  uint32 size = s.size();
+  uint32_t size = s.size();
   ptr = WriteLengthDelim(num, size, ptr);
   return WriteRaw(s.data(), size, ptr);
 }
@@ -944,28 +945,28 @@ CodedOutputStream::CodedOutputStream(ZeroCopyOutputStream* stream,
 CodedOutputStream::~CodedOutputStream() { Trim(); }
 
 
-uint8* CodedOutputStream::WriteStringWithSizeToArray(const std::string& str,
-                                                     uint8* target) {
-  GOOGLE_DCHECK_LE(str.size(), kuint32max);
+uint8_t* CodedOutputStream::WriteStringWithSizeToArray(const std::string& str,
+                                                     uint8_t* target) {
+  GOOGLE_DCHECK_LE(str.size(), std::numeric_limits<uint32_t>::max());
   target = WriteVarint32ToArray(str.size(), target);
   return WriteStringToArray(str, target);
 }
 
-uint8* CodedOutputStream::WriteVarint32ToArrayOutOfLineHelper(uint32 value,
-                                                              uint8* target) {
+uint8_t* CodedOutputStream::WriteVarint32ToArrayOutOfLineHelper(uint32_t value,
+                                                              uint8_t* target) {
   GOOGLE_DCHECK_GE(value, 0x80);
-  target[0] |= static_cast<uint8>(0x80);
+  target[0] |= static_cast<uint8_t>(0x80);
   value >>= 7;
-  target[1] = static_cast<uint8>(value);
+  target[1] = static_cast<uint8_t>(value);
   if (value < 0x80) {
     return target + 2;
   }
   target += 2;
   do {
     // Turn on continuation bit in the byte we just wrote.
-    target[-1] |= static_cast<uint8>(0x80);
+    target[-1] |= static_cast<uint8_t>(0x80);
     value >>= 7;
-    *target = static_cast<uint8>(value);
+    *target = static_cast<uint8_t>(value);
     ++target;
   } while (value >= 0x80);
   return target;
diff --git protobuf-3.17.3protobuf-3.17.3/src/google/protobuf/io/coded_stream.h protobuf-3.17.3-patchedprotobuf-3.17.3-patched/src/google/protobuf/io/coded_stream.h
index 1cf0068..079fd64 100644
--- protobuf-3.17.3protobuf-3.17.3/src/google/protobuf/io/coded_stream.h
+++ protobuf-3.17.3-patchedprotobuf-3.17.3-patched/src/google/protobuf/io/coded_stream.h
@@ -75,7 +75,7 @@
 //     return;
 //   }
 //
-//   uint32 size;
+//   uint32_t size;
 //   coded_input->ReadVarint32(&size);
 //
 //   char* text = new char[size + 1];
@@ -116,6 +116,7 @@
 #include <climits>
 #include <cstddef>
 #include <cstring>
+#include <limits>
 #include <string>
 #include <type_traits>
 #include <utility>
@@ -135,6 +136,10 @@
 #include <machine/endian.h>  // __BYTE_ORDER
 #elif defined(__FreeBSD__)
 #include <sys/endian.h>  // __BYTE_ORDER
+#elif (defined(sun) || defined(__sun)) && (defined(__SVR4) || defined(__svr4__))
+#include <sys/isa_defs.h>  // __BYTE_ORDER
+#elif defined(_AIX) || defined(__TOS_AIX__)
+#include <sys/machine.h>  // BYTE_ORDER
 #else
 #if !defined(__QNX__)
 #include <endian.h>  // __BYTE_ORDER
@@ -153,6 +158,7 @@
 #include <google/protobuf/stubs/port.h>
 
 
+// Must be included last.
 #include <google/protobuf/port_def.inc>
 
 namespace google {
@@ -194,7 +200,7 @@ class PROTOBUF_EXPORT CodedInputStream {
   // Create a CodedInputStream that reads from the given flat array.  This is
   // faster than using an ArrayInputStream.  PushLimit(size) is implied by
   // this constructor.
-  explicit CodedInputStream(const uint8* buffer, int size);
+  explicit CodedInputStream(const uint8_t* buffer, int size);
 
   // Destroy the CodedInputStream and position the underlying
   // ZeroCopyInputStream at the first unread byte.  If an error occurred while
@@ -233,25 +239,25 @@ class PROTOBUF_EXPORT CodedInputStream {
 
 
   // Read a 32-bit little-endian integer.
-  bool ReadLittleEndian32(uint32* value);
+  bool ReadLittleEndian32(uint32_t* value);
   // Read a 64-bit little-endian integer.
-  bool ReadLittleEndian64(uint64* value);
+  bool ReadLittleEndian64(uint64_t* value);
 
   // These methods read from an externally provided buffer. The caller is
   // responsible for ensuring that the buffer has sufficient space.
   // Read a 32-bit little-endian integer.
-  static const uint8* ReadLittleEndian32FromArray(const uint8* buffer,
-                                                  uint32* value);
+  static const uint8_t* ReadLittleEndian32FromArray(const uint8_t* buffer,
+                                                    uint32_t* value);
   // Read a 64-bit little-endian integer.
-  static const uint8* ReadLittleEndian64FromArray(const uint8* buffer,
-                                                  uint64* value);
+  static const uint8_t* ReadLittleEndian64FromArray(const uint8_t* buffer,
+                                                    uint64_t* value);
 
   // Read an unsigned integer with Varint encoding, truncating to 32 bits.
   // Reading a 32-bit value is equivalent to reading a 64-bit one and casting
-  // it to uint32, but may be more efficient.
-  bool ReadVarint32(uint32* value);
+  // it to uint32_t, but may be more efficient.
+  bool ReadVarint32(uint32_t* value);
   // Read an unsigned integer with Varint encoding.
-  bool ReadVarint64(uint64* value);
+  bool ReadVarint64(uint64_t* value);
 
   // Reads a varint off the wire into an "int". This should be used for reading
   // sizes off the wire (sizes of strings, submessages, bytes fields, etc).
@@ -272,11 +278,11 @@ class PROTOBUF_EXPORT CodedInputStream {
   // Always inline because this is only called in one place per parse loop
   // but it is called for every iteration of said loop, so it should be fast.
   // GCC doesn't want to inline this by default.
-  PROTOBUF_ALWAYS_INLINE uint32 ReadTag() {
+  PROTOBUF_ALWAYS_INLINE uint32_t ReadTag() {
     return last_tag_ = ReadTagNoLastTag();
   }
 
-  PROTOBUF_ALWAYS_INLINE uint32 ReadTagNoLastTag();
+  PROTOBUF_ALWAYS_INLINE uint32_t ReadTagNoLastTag();
 
   // This usually a faster alternative to ReadTag() when cutoff is a manifest
   // constant.  It does particularly well for cutoff >= 127.  The first part
@@ -287,14 +293,14 @@ class PROTOBUF_EXPORT CodedInputStream {
   // because that can arise in several ways, and for best performance we want
   // to avoid an extra "is tag == 0?" check here.)
   PROTOBUF_ALWAYS_INLINE
-  std::pair<uint32, bool> ReadTagWithCutoff(uint32 cutoff) {
-    std::pair<uint32, bool> result = ReadTagWithCutoffNoLastTag(cutoff);
+  std::pair<uint32_t, bool> ReadTagWithCutoff(uint32_t cutoff) {
+    std::pair<uint32_t, bool> result = ReadTagWithCutoffNoLastTag(cutoff);
     last_tag_ = result.first;
     return result;
   }
 
   PROTOBUF_ALWAYS_INLINE
-  std::pair<uint32, bool> ReadTagWithCutoffNoLastTag(uint32 cutoff);
+  std::pair<uint32_t, bool> ReadTagWithCutoffNoLastTag(uint32_t cutoff);
 
   // Usually returns true if calling ReadVarint32() now would produce the given
   // value.  Will always return false if ReadVarint32() would not return the
@@ -303,7 +309,7 @@ class PROTOBUF_EXPORT CodedInputStream {
   // parameter.
   // Always inline because this collapses to a small number of instructions
   // when given a constant parameter, but GCC doesn't want to inline by default.
-  PROTOBUF_ALWAYS_INLINE bool ExpectTag(uint32 expected);
+  PROTOBUF_ALWAYS_INLINE bool ExpectTag(uint32_t expected);
 
   // Like above, except this reads from the specified buffer. The caller is
   // responsible for ensuring that the buffer is large enough to read a varint
@@ -313,7 +319,8 @@ class PROTOBUF_EXPORT CodedInputStream {
   // Returns a pointer beyond the expected tag if it was found, or NULL if it
   // was not.
   PROTOBUF_ALWAYS_INLINE
-  static const uint8* ExpectTagFromArray(const uint8* buffer, uint32 expected);
+  static const uint8_t* ExpectTagFromArray(const uint8_t* buffer,
+                                           uint32_t expected);
 
   // Usually returns true if no more bytes can be read.  Always returns false
   // if more bytes can be read.  If ExpectAtEnd() returns true, a subsequent
@@ -332,8 +339,8 @@ class PROTOBUF_EXPORT CodedInputStream {
   // of the enclosing message.  The enclosing message would like to check that
   // tag to make sure it had the right number, so it calls LastTagWas() on
   // return from the embedded parser to check.
-  bool LastTagWas(uint32 expected);
-  void SetLastTag(uint32 tag) { last_tag_ = tag; }
+  bool LastTagWas(uint32_t expected);
+  void SetLastTag(uint32_t tag) { last_tag_ = tag; }
 
   // When parsing message (but NOT a group), this method must be called
   // immediately after MergeFromCodedStream() returns (if it returns true)
@@ -399,13 +406,6 @@ class PROTOBUF_EXPORT CodedInputStream {
   // This is unrelated to PushLimit()/PopLimit().
   void SetTotalBytesLimit(int total_bytes_limit);
 
-  PROTOBUF_DEPRECATED_MSG(
-      "Please use the single parameter version of SetTotalBytesLimit(). The "
-      "second parameter is ignored.")
-  void SetTotalBytesLimit(int total_bytes_limit, int) {
-    SetTotalBytesLimit(total_bytes_limit);
-  }
-
   // The Total Bytes Limit minus the Current Position, or -1 if the total bytes
   // limit is INT_MAX.
   int BytesUntilTotalBytesLimit() const;
@@ -543,8 +543,8 @@ class PROTOBUF_EXPORT CodedInputStream {
  private:
   GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(CodedInputStream);
 
-  const uint8* buffer_;
-  const uint8* buffer_end_;  // pointer to the end of the buffer.
+  const uint8_t* buffer_;
+  const uint8_t* buffer_end_;  // pointer to the end of the buffer.
   ZeroCopyInputStream* input_;
   int total_bytes_read_;  // total bytes read from input_, including
                           // the current buffer
@@ -554,7 +554,7 @@ class PROTOBUF_EXPORT CodedInputStream {
   int overflow_bytes_;
 
   // LastTagWas() stuff.
-  uint32 last_tag_;  // result of last ReadTag() or ReadTagWithCutoff().
+  uint32_t last_tag_;  // result of last ReadTag() or ReadTagWithCutoff().
 
   // This is set true by ReadTag{Fallback/Slow}() if it is called when exactly
   // at EOF, or by ExpectAtEnd() when it returns true.  This happens when we
@@ -622,22 +622,22 @@ class PROTOBUF_EXPORT CodedInputStream {
   // message crosses multiple buffers.  Note: ReadVarint32Fallback() and
   // ReadVarint64Fallback() are called frequently and generally not inlined, so
   // they have been optimized to avoid "out" parameters.  The former returns -1
-  // if it fails and the uint32 it read otherwise.  The latter has a bool
+  // if it fails and the uint32_t it read otherwise.  The latter has a bool
   // indicating success or failure as part of its return type.
-  int64 ReadVarint32Fallback(uint32 first_byte_or_zero);
+  int64_t ReadVarint32Fallback(uint32_t first_byte_or_zero);
   int ReadVarintSizeAsIntFallback();
-  std::pair<uint64, bool> ReadVarint64Fallback();
-  bool ReadVarint32Slow(uint32* value);
-  bool ReadVarint64Slow(uint64* value);
+  std::pair<uint64_t, bool> ReadVarint64Fallback();
+  bool ReadVarint32Slow(uint32_t* value);
+  bool ReadVarint64Slow(uint64_t* value);
   int ReadVarintSizeAsIntSlow();
-  bool ReadLittleEndian32Fallback(uint32* value);
-  bool ReadLittleEndian64Fallback(uint64* value);
+  bool ReadLittleEndian32Fallback(uint32_t* value);
+  bool ReadLittleEndian64Fallback(uint64_t* value);
 
   // Fallback/slow methods for reading tags. These do not update last_tag_,
   // but will set legitimate_message_end_ if we are at the end of the input
   // stream.
-  uint32 ReadTagFallback(uint32 first_byte_or_zero);
-  uint32 ReadTagSlow();
+  uint32_t ReadTagFallback(uint32_t first_byte_or_zero);
+  uint32_t ReadTagSlow();
   bool ReadStringFallback(std::string* buffer, int size);
 
   // Return the size of the buffer.
@@ -663,7 +663,7 @@ class PROTOBUF_EXPORT EpsCopyOutputStream {
 
   // Initialize from a stream.
   EpsCopyOutputStream(ZeroCopyOutputStream* stream, bool deterministic,
-                      uint8** pp)
+                      uint8_t** pp)
       : end_(buffer_),
         stream_(stream),
         is_serialization_deterministic_(deterministic) {
@@ -674,33 +674,33 @@ class PROTOBUF_EXPORT EpsCopyOutputStream {
   // pointed to the end of the array. When using this the total size is already
   // known, so no need to maintain the slop region.
   EpsCopyOutputStream(void* data, int size, bool deterministic)
-      : end_(static_cast<uint8*>(data) + size),
+      : end_(static_cast<uint8_t*>(data) + size),
         buffer_end_(nullptr),
         stream_(nullptr),
         is_serialization_deterministic_(deterministic) {}
 
   // Initialize from stream but with the first buffer already given (eager).
   EpsCopyOutputStream(void* data, int size, ZeroCopyOutputStream* stream,
-                      bool deterministic, uint8** pp)
+                      bool deterministic, uint8_t** pp)
       : stream_(stream), is_serialization_deterministic_(deterministic) {
     *pp = SetInitialBuffer(data, size);
   }
 
   // Flush everything that's written into the underlying ZeroCopyOutputStream
   // and trims the underlying stream to the location of ptr.
-  uint8* Trim(uint8* ptr);
+  uint8_t* Trim(uint8_t* ptr);
 
   // After this it's guaranteed you can safely write kSlopBytes to ptr. This
   // will never fail! The underlying stream can produce an error. Use HadError
   // to check for errors.
-  PROTOBUF_MUST_USE_RESULT uint8* EnsureSpace(uint8* ptr) {
+  PROTOBUF_MUST_USE_RESULT uint8_t* EnsureSpace(uint8_t* ptr) {
     if (PROTOBUF_PREDICT_FALSE(ptr >= end_)) {
       return EnsureSpaceFallback(ptr);
     }
     return ptr;
   }
 
-  uint8* WriteRaw(const void* data, int size, uint8* ptr) {
+  uint8_t* WriteRaw(const void* data, int size, uint8_t* ptr) {
     if (PROTOBUF_PREDICT_FALSE(end_ - ptr < size)) {
       return WriteRawFallback(data, size, ptr);
     }
@@ -711,7 +711,7 @@ class PROTOBUF_EXPORT EpsCopyOutputStream {
   // aliasing the buffer (ie. not copying the data). The caller is responsible
   // to make sure the buffer is alive for the duration of the
   // ZeroCopyOutputStream.
-  uint8* WriteRawMaybeAliased(const void* data, int size, uint8* ptr) {
+  uint8_t* WriteRawMaybeAliased(const void* data, int size, uint8_t* ptr) {
     if (aliasing_enabled_) {
       return WriteAliasedRaw(data, size, ptr);
     } else {
@@ -720,78 +720,80 @@ class PROTOBUF_EXPORT EpsCopyOutputStream {
   }
 
 
-  uint8* WriteStringMaybeAliased(uint32 num, const std::string& s, uint8* ptr) {
+  uint8_t* WriteStringMaybeAliased(uint32_t num, const std::string& s,
+                                   uint8_t* ptr) {
     std::ptrdiff_t size = s.size();
     if (PROTOBUF_PREDICT_FALSE(
             size >= 128 || end_ - ptr + 16 - TagSize(num << 3) - 1 < size)) {
       return WriteStringMaybeAliasedOutline(num, s, ptr);
     }
     ptr = UnsafeVarint((num << 3) | 2, ptr);
-    *ptr++ = static_cast<uint8>(size);
+    *ptr++ = static_cast<uint8_t>(size);
     std::memcpy(ptr, s.data(), size);
     return ptr + size;
   }
-  uint8* WriteBytesMaybeAliased(uint32 num, const std::string& s, uint8* ptr) {
+  uint8_t* WriteBytesMaybeAliased(uint32_t num, const std::string& s,
+                                  uint8_t* ptr) {
     return WriteStringMaybeAliased(num, s, ptr);
   }
 
   template <typename T>
-  PROTOBUF_ALWAYS_INLINE uint8* WriteString(uint32 num, const T& s,
-                                            uint8* ptr) {
+  PROTOBUF_ALWAYS_INLINE uint8_t* WriteString(uint32_t num, const T& s,
+                                              uint8_t* ptr) {
     std::ptrdiff_t size = s.size();
     if (PROTOBUF_PREDICT_FALSE(
             size >= 128 || end_ - ptr + 16 - TagSize(num << 3) - 1 < size)) {
       return WriteStringOutline(num, s, ptr);
     }
     ptr = UnsafeVarint((num << 3) | 2, ptr);
-    *ptr++ = static_cast<uint8>(size);
+    *ptr++ = static_cast<uint8_t>(size);
     std::memcpy(ptr, s.data(), size);
     return ptr + size;
   }
   template <typename T>
-  uint8* WriteBytes(uint32 num, const T& s, uint8* ptr) {
+  uint8_t* WriteBytes(uint32_t num, const T& s, uint8_t* ptr) {
     return WriteString(num, s, ptr);
   }
 
   template <typename T>
-  PROTOBUF_ALWAYS_INLINE uint8* WriteInt32Packed(int num, const T& r, int size,
-                                                 uint8* ptr) {
+  PROTOBUF_ALWAYS_INLINE uint8_t* WriteInt32Packed(int num, const T& r,
+                                                   int size, uint8_t* ptr) {
     return WriteVarintPacked(num, r, size, ptr, Encode64);
   }
   template <typename T>
-  PROTOBUF_ALWAYS_INLINE uint8* WriteUInt32Packed(int num, const T& r, int size,
-                                                  uint8* ptr) {
+  PROTOBUF_ALWAYS_INLINE uint8_t* WriteUInt32Packed(int num, const T& r,
+                                                    int size, uint8_t* ptr) {
     return WriteVarintPacked(num, r, size, ptr, Encode32);
   }
   template <typename T>
-  PROTOBUF_ALWAYS_INLINE uint8* WriteSInt32Packed(int num, const T& r, int size,
-                                                  uint8* ptr) {
+  PROTOBUF_ALWAYS_INLINE uint8_t* WriteSInt32Packed(int num, const T& r,
+                                                    int size, uint8_t* ptr) {
     return WriteVarintPacked(num, r, size, ptr, ZigZagEncode32);
   }
   template <typename T>
-  PROTOBUF_ALWAYS_INLINE uint8* WriteInt64Packed(int num, const T& r, int size,
-                                                 uint8* ptr) {
+  PROTOBUF_ALWAYS_INLINE uint8_t* WriteInt64Packed(int num, const T& r,
+                                                   int size, uint8_t* ptr) {
     return WriteVarintPacked(num, r, size, ptr, Encode64);
   }
   template <typename T>
-  PROTOBUF_ALWAYS_INLINE uint8* WriteUInt64Packed(int num, const T& r, int size,
-                                                  uint8* ptr) {
+  PROTOBUF_ALWAYS_INLINE uint8_t* WriteUInt64Packed(int num, const T& r,
+                                                    int size, uint8_t* ptr) {
     return WriteVarintPacked(num, r, size, ptr, Encode64);
   }
   template <typename T>
-  PROTOBUF_ALWAYS_INLINE uint8* WriteSInt64Packed(int num, const T& r, int size,
-                                                  uint8* ptr) {
+  PROTOBUF_ALWAYS_INLINE uint8_t* WriteSInt64Packed(int num, const T& r,
+                                                    int size, uint8_t* ptr) {
     return WriteVarintPacked(num, r, size, ptr, ZigZagEncode64);
   }
   template <typename T>
-  PROTOBUF_ALWAYS_INLINE uint8* WriteEnumPacked(int num, const T& r, int size,
-                                                uint8* ptr) {
+  PROTOBUF_ALWAYS_INLINE uint8_t* WriteEnumPacked(int num, const T& r, int size,
+                                                  uint8_t* ptr) {
     return WriteVarintPacked(num, r, size, ptr, Encode64);
   }
 
   template <typename T>
-  PROTOBUF_ALWAYS_INLINE uint8* WriteFixedPacked(int num, const T& r,
-                                                 uint8* ptr) {
+  PROTOBUF_ALWAYS_INLINE uint8_t* WriteFixedPacked(int num, const T& r,
+                                                   uint8_t* ptr) {
     ptr = EnsureSpace(ptr);
     constexpr auto element_size = sizeof(typename T::value_type);
     auto size = r.size() * element_size;
@@ -827,34 +829,35 @@ class PROTOBUF_EXPORT EpsCopyOutputStream {
 
   // The number of bytes written to the stream at position ptr, relative to the
   // stream's overall position.
-  int64 ByteCount(uint8* ptr) const;
+  int64_t ByteCount(uint8_t* ptr) const;
 
 
  private:
-  uint8* end_;
-  uint8* buffer_end_ = buffer_;
-  uint8 buffer_[2 * kSlopBytes];
+  uint8_t* end_;
+  uint8_t* buffer_end_ = buffer_;
+  uint8_t buffer_[2 * kSlopBytes];
   ZeroCopyOutputStream* stream_;
   bool had_error_ = false;
   bool aliasing_enabled_ = false;  // See EnableAliasing().
   bool is_serialization_deterministic_;
+  bool skip_check_consistency = false;
 
-  uint8* EnsureSpaceFallback(uint8* ptr);
-  inline uint8* Next();
-  int Flush(uint8* ptr);
-  std::ptrdiff_t GetSize(uint8* ptr) const {
+  uint8_t* EnsureSpaceFallback(uint8_t* ptr);
+  inline uint8_t* Next();
+  int Flush(uint8_t* ptr);
+  std::ptrdiff_t GetSize(uint8_t* ptr) const {
     GOOGLE_DCHECK(ptr <= end_ + kSlopBytes);  // NOLINT
     return end_ + kSlopBytes - ptr;
   }
 
-  uint8* Error() {
+  uint8_t* Error() {
     had_error_ = true;
     // We use the patch buffer to always guarantee space to write to.
     end_ = buffer_ + kSlopBytes;
     return buffer_;
   }
 
-  static constexpr int TagSize(uint32 tag) {
+  static constexpr int TagSize(uint32_t tag) {
     return (tag < (1 << 7))    ? 1
            : (tag < (1 << 14)) ? 2
            : (tag < (1 << 21)) ? 3
@@ -862,28 +865,30 @@ class PROTOBUF_EXPORT EpsCopyOutputStream {
                                : 5;
   }
 
-  PROTOBUF_ALWAYS_INLINE uint8* WriteTag(uint32 num, uint32 wt, uint8* ptr) {
+  PROTOBUF_ALWAYS_INLINE uint8_t* WriteTag(uint32_t num, uint32_t wt,
+                                           uint8_t* ptr) {
     GOOGLE_DCHECK(ptr < end_);  // NOLINT
     return UnsafeVarint((num << 3) | wt, ptr);
   }
 
-  PROTOBUF_ALWAYS_INLINE uint8* WriteLengthDelim(int num, uint32 size,
-                                                 uint8* ptr) {
+  PROTOBUF_ALWAYS_INLINE uint8_t* WriteLengthDelim(int num, uint32_t size,
+                                                   uint8_t* ptr) {
     ptr = WriteTag(num, 2, ptr);
     return UnsafeWriteSize(size, ptr);
   }
 
-  uint8* WriteRawFallback(const void* data, int size, uint8* ptr);
+  uint8_t* WriteRawFallback(const void* data, int size, uint8_t* ptr);
 
-  uint8* WriteAliasedRaw(const void* data, int size, uint8* ptr);
+  uint8_t* WriteAliasedRaw(const void* data, int size, uint8_t* ptr);
 
-  uint8* WriteStringMaybeAliasedOutline(uint32 num, const std::string& s,
-                                        uint8* ptr);
-  uint8* WriteStringOutline(uint32 num, const std::string& s, uint8* ptr);
+  uint8_t* WriteStringMaybeAliasedOutline(uint32_t num, const std::string& s,
+                                          uint8_t* ptr);
+  uint8_t* WriteStringOutline(uint32_t num, const std::string& s, uint8_t* ptr);
 
   template <typename T, typename E>
-  PROTOBUF_ALWAYS_INLINE uint8* WriteVarintPacked(int num, const T& r, int size,
-                                                  uint8* ptr, const E& encode) {
+  PROTOBUF_ALWAYS_INLINE uint8_t* WriteVarintPacked(int num, const T& r,
+                                                    int size, uint8_t* ptr,
+                                                    const E& encode) {
     ptr = EnsureSpace(ptr);
     ptr = WriteLengthDelim(num, size, ptr);
     auto it = r.data();
@@ -895,65 +900,65 @@ class PROTOBUF_EXPORT EpsCopyOutputStream {
     return ptr;
   }
 
-  static uint32 Encode32(uint32 v) { return v; }
-  static uint64 Encode64(uint64 v) { return v; }
-  static uint32 ZigZagEncode32(int32 v) {
-    return (static_cast<uint32>(v) << 1) ^ static_cast<uint32>(v >> 31);
+  static uint32_t Encode32(uint32_t v) { return v; }
+  static uint64_t Encode64(uint64_t v) { return v; }
+  static uint32_t ZigZagEncode32(int32_t v) {
+    return (static_cast<uint32_t>(v) << 1) ^ static_cast<uint32_t>(v >> 31);
   }
-  static uint64 ZigZagEncode64(int64 v) {
-    return (static_cast<uint64>(v) << 1) ^ static_cast<uint64>(v >> 63);
+  static uint64_t ZigZagEncode64(int64_t v) {
+    return (static_cast<uint64_t>(v) << 1) ^ static_cast<uint64_t>(v >> 63);
   }
 
   template <typename T>
-  PROTOBUF_ALWAYS_INLINE static uint8* UnsafeVarint(T value, uint8* ptr) {
+  PROTOBUF_ALWAYS_INLINE static uint8_t* UnsafeVarint(T value, uint8_t* ptr) {
     static_assert(std::is_unsigned<T>::value,
                   "Varint serialization must be unsigned");
-    ptr[0] = static_cast<uint8>(value);
+    ptr[0] = static_cast<uint8_t>(value);
     if (value < 0x80) {
       return ptr + 1;
     }
     // Turn on continuation bit in the byte we just wrote.
-    ptr[0] |= static_cast<uint8>(0x80);
+    ptr[0] |= static_cast<uint8_t>(0x80);
     value >>= 7;
-    ptr[1] = static_cast<uint8>(value);
+    ptr[1] = static_cast<uint8_t>(value);
     if (value < 0x80) {
       return ptr + 2;
     }
     ptr += 2;
     do {
       // Turn on continuation bit in the byte we just wrote.
-      ptr[-1] |= static_cast<uint8>(0x80);
+      ptr[-1] |= static_cast<uint8_t>(0x80);
       value >>= 7;
-      *ptr = static_cast<uint8>(value);
+      *ptr = static_cast<uint8_t>(value);
       ++ptr;
     } while (value >= 0x80);
     return ptr;
   }
 
-  PROTOBUF_ALWAYS_INLINE static uint8* UnsafeWriteSize(uint32 value,
-                                                       uint8* ptr) {
+  PROTOBUF_ALWAYS_INLINE static uint8_t* UnsafeWriteSize(uint32_t value,
+                                                         uint8_t* ptr) {
     while (PROTOBUF_PREDICT_FALSE(value >= 0x80)) {
-      *ptr = static_cast<uint8>(value | 0x80);
+      *ptr = static_cast<uint8_t>(value | 0x80);
       value >>= 7;
       ++ptr;
     }
-    *ptr++ = static_cast<uint8>(value);
+    *ptr++ = static_cast<uint8_t>(value);
     return ptr;
   }
 
   template <int S>
-  uint8* WriteRawLittleEndian(const void* data, int size, uint8* ptr);
+  uint8_t* WriteRawLittleEndian(const void* data, int size, uint8_t* ptr);
 #ifndef PROTOBUF_LITTLE_ENDIAN
-  uint8* WriteRawLittleEndian32(const void* data, int size, uint8* ptr);
-  uint8* WriteRawLittleEndian64(const void* data, int size, uint8* ptr);
+  uint8_t* WriteRawLittleEndian32(const void* data, int size, uint8_t* ptr);
+  uint8_t* WriteRawLittleEndian64(const void* data, int size, uint8_t* ptr);
 #endif
 
   // These methods are for CodedOutputStream. Ideally they should be private
   // but to match current behavior of CodedOutputStream as close as possible
   // we allow it some functionality.
  public:
-  uint8* SetInitialBuffer(void* data, int size) {
-    auto ptr = static_cast<uint8*>(data);
+  uint8_t* SetInitialBuffer(void* data, int size) {
+    auto ptr = static_cast<uint8_t*>(data);
     if (size > kSlopBytes) {
       end_ = ptr + size - kSlopBytes;
       buffer_end_ = nullptr;
@@ -968,28 +973,28 @@ class PROTOBUF_EXPORT EpsCopyOutputStream {
  private:
   // Needed by CodedOutputStream HadError. HadError needs to flush the patch
   // buffers to ensure there is no error as of yet.
-  uint8* FlushAndResetBuffer(uint8*);
+  uint8_t* FlushAndResetBuffer(uint8_t*);
 
   // The following functions mimic the old CodedOutputStream behavior as close
   // as possible. They flush the current state to the stream, behave as
   // the old CodedOutputStream and then return to normal operation.
-  bool Skip(int count, uint8** pp);
-  bool GetDirectBufferPointer(void** data, int* size, uint8** pp);
-  uint8* GetDirectBufferForNBytesAndAdvance(int size, uint8** pp);
+  bool Skip(int count, uint8_t** pp);
+  bool GetDirectBufferPointer(void** data, int* size, uint8_t** pp);
+  uint8_t* GetDirectBufferForNBytesAndAdvance(int size, uint8_t** pp);
 
   friend class CodedOutputStream;
 };
 
 template <>
-inline uint8* EpsCopyOutputStream::WriteRawLittleEndian<1>(const void* data,
-                                                           int size,
-                                                           uint8* ptr) {
+inline uint8_t* EpsCopyOutputStream::WriteRawLittleEndian<1>(const void* data,
+                                                             int size,
+                                                             uint8_t* ptr) {
   return WriteRaw(data, size, ptr);
 }
 template <>
-inline uint8* EpsCopyOutputStream::WriteRawLittleEndian<4>(const void* data,
-                                                           int size,
-                                                           uint8* ptr) {
+inline uint8_t* EpsCopyOutputStream::WriteRawLittleEndian<4>(const void* data,
+                                                             int size,
+                                                             uint8_t* ptr) {
 #ifdef PROTOBUF_LITTLE_ENDIAN
   return WriteRaw(data, size, ptr);
 #else
@@ -997,9 +1002,9 @@ inline uint8* EpsCopyOutputStream::WriteRawLittleEndian<4>(const void* data,
 #endif
 }
 template <>
-inline uint8* EpsCopyOutputStream::WriteRawLittleEndian<8>(const void* data,
-                                                           int size,
-                                                           uint8* ptr) {
+inline uint8_t* EpsCopyOutputStream::WriteRawLittleEndian<8>(const void* data,
+                                                             int size,
+                                                             uint8_t* ptr) {
 #ifdef PROTOBUF_LITTLE_ENDIAN
   return WriteRaw(data, size, ptr);
 #else
@@ -1035,7 +1040,7 @@ inline uint8* EpsCopyOutputStream::WriteRawLittleEndian<8>(const void* data,
 //                    CodedOutputStream::VarintSize32(strlen(text)) +
 //                    strlen(text);
 //
-//   uint8* buffer =
+//   uint8_t* buffer =
 //       coded_output->GetDirectBufferForNBytesAndAdvance(coded_size);
 //   if (buffer != nullptr) {
 //     // The output stream has enough space in the buffer: write directly to
@@ -1107,7 +1112,7 @@ class PROTOBUF_EXPORT CodedOutputStream {
   // there are not enough bytes available, returns NULL.  The return pointer is
   // invalidated as soon as any other non-const method of CodedOutputStream
   // is called.
-  inline uint8* GetDirectBufferForNBytesAndAdvance(int size) {
+  inline uint8_t* GetDirectBufferForNBytesAndAdvance(int size) {
     return impl_.GetDirectBufferForNBytesAndAdvance(size, &cur_);
   }
 
@@ -1123,72 +1128,80 @@ class PROTOBUF_EXPORT CodedOutputStream {
   // copy loops. Since this gets called by every field with string or bytes
   // type, inlining may lead to a significant amount of code bloat, with only a
   // minor performance gain.
-  static uint8* WriteRawToArray(const void* buffer, int size, uint8* target);
+  static uint8_t* WriteRawToArray(const void* buffer, int size,
+                                  uint8_t* target);
 
   // Equivalent to WriteRaw(str.data(), str.size()).
   void WriteString(const std::string& str);
   // Like WriteString()  but writing directly to the target array.
-  static uint8* WriteStringToArray(const std::string& str, uint8* target);
+  static uint8_t* WriteStringToArray(const std::string& str, uint8_t* target);
   // Write the varint-encoded size of str followed by str.
-  static uint8* WriteStringWithSizeToArray(const std::string& str,
-                                           uint8* target);
+  static uint8_t* WriteStringWithSizeToArray(const std::string& str,
+                                             uint8_t* target);
 
 
   // Write a 32-bit little-endian integer.
-  void WriteLittleEndian32(uint32 value) {
+  void WriteLittleEndian32(uint32_t value) {
     cur_ = impl_.EnsureSpace(cur_);
     SetCur(WriteLittleEndian32ToArray(value, Cur()));
   }
   // Like WriteLittleEndian32()  but writing directly to the target array.
-  static uint8* WriteLittleEndian32ToArray(uint32 value, uint8* target);
+  static uint8_t* WriteLittleEndian32ToArray(uint32_t value, uint8_t* target);
   // Write a 64-bit little-endian integer.
-  void WriteLittleEndian64(uint64 value) {
+  void WriteLittleEndian64(uint64_t value) {
     cur_ = impl_.EnsureSpace(cur_);
     SetCur(WriteLittleEndian64ToArray(value, Cur()));
   }
   // Like WriteLittleEndian64()  but writing directly to the target array.
-  static uint8* WriteLittleEndian64ToArray(uint64 value, uint8* target);
+  static uint8_t* WriteLittleEndian64ToArray(uint64_t value, uint8_t* target);
 
   // Write an unsigned integer with Varint encoding.  Writing a 32-bit value
-  // is equivalent to casting it to uint64 and writing it as a 64-bit value,
+  // is equivalent to casting it to uint64_t and writing it as a 64-bit value,
   // but may be more efficient.
-  void WriteVarint32(uint32 value);
+  void WriteVarint32(uint32_t value);
   // Like WriteVarint32()  but writing directly to the target array.
-  static uint8* WriteVarint32ToArray(uint32 value, uint8* target);
-  // Like WriteVarint32()  but writing directly to the target array, and with the
-  // less common-case paths being out of line rather than inlined.
-  static uint8* WriteVarint32ToArrayOutOfLine(uint32 value, uint8* target);
+  static uint8_t* WriteVarint32ToArray(uint32_t value, uint8_t* target);
+  // Like WriteVarint32()  but writing directly to the target array, and with
+  // the less common-case paths being out of line rather than inlined.
+  static uint8_t* WriteVarint32ToArrayOutOfLine(uint32_t value,
+                                                uint8_t* target);
   // Write an unsigned integer with Varint encoding.
-  void WriteVarint64(uint64 value);
+  void WriteVarint64(uint64_t value);
   // Like WriteVarint64()  but writing directly to the target array.
-  static uint8* WriteVarint64ToArray(uint64 value, uint8* target);
+  static uint8_t* WriteVarint64ToArray(uint64_t value, uint8_t* target);
 
   // Equivalent to WriteVarint32() except when the value is negative,
   // in which case it must be sign-extended to a full 10 bytes.
-  void WriteVarint32SignExtended(int32 value);
+  void WriteVarint32SignExtended(int32_t value);
   // Like WriteVarint32SignExtended()  but writing directly to the target array.
-  static uint8* WriteVarint32SignExtendedToArray(int32 value, uint8* target);
+  static uint8_t* WriteVarint32SignExtendedToArray(int32_t value,
+                                                   uint8_t* target);
 
   // This is identical to WriteVarint32(), but optimized for writing tags.
   // In particular, if the input is a compile-time constant, this method
   // compiles down to a couple instructions.
   // Always inline because otherwise the aforementioned optimization can't work,
   // but GCC by default doesn't want to inline this.
-  void WriteTag(uint32 value);
+  void WriteTag(uint32_t value);
   // Like WriteTag()  but writing directly to the target array.
   PROTOBUF_ALWAYS_INLINE
-  static uint8* WriteTagToArray(uint32 value, uint8* target);
+  static uint8_t* WriteTagToArray(uint32_t value, uint8_t* target);
 
   // Returns the number of bytes needed to encode the given value as a varint.
-  static size_t VarintSize32(uint32 value);
+  static size_t VarintSize32(uint32_t value);
   // Returns the number of bytes needed to encode the given value as a varint.
-  static size_t VarintSize64(uint64 value);
+  static size_t VarintSize64(uint64_t value);
 
   // If negative, 10 bytes.  Otherwise, same as VarintSize32().
-  static size_t VarintSize32SignExtended(int32 value);
+  static size_t VarintSize32SignExtended(int32_t value);
+
+  // Same as above, plus one.  The additional one comes at no compute cost.
+  static size_t VarintSize32PlusOne(uint32_t value);
+  static size_t VarintSize64PlusOne(uint64_t value);
+  static size_t VarintSize32SignExtendedPlusOne(int32_t value);
 
   // Compile-time equivalent of VarintSize32().
-  template <uint32 Value>
+  template <uint32_t Value>
   struct StaticVarintSize32 {
     static const size_t value = (Value < (1 << 7))    ? 1
                                 : (Value < (1 << 14)) ? 2
@@ -1213,7 +1226,7 @@ class PROTOBUF_EXPORT CodedOutputStream {
   // remains live until all of the data has been consumed from the stream.
   void EnableAliasing(bool enabled) { impl_.EnableAliasing(enabled); }
 
-  // Indicate to the serializer whether the user wants derministic
+  // Indicate to the serializer whether the user wants deterministic
   // serialization. The default when this is not called comes from the global
   // default, controlled by SetDefaultSerializationDeterministic.
   //
@@ -1251,14 +1264,17 @@ class PROTOBUF_EXPORT CodedOutputStream {
   template <typename Func>
   void Serialize(const Func& func);
 
-  uint8* Cur() const { return cur_; }
-  void SetCur(uint8* ptr) { cur_ = ptr; }
+  uint8_t* Cur() const { return cur_; }
+  void SetCur(uint8_t* ptr) { cur_ = ptr; }
   EpsCopyOutputStream* EpsCopy() { return &impl_; }
 
  private:
+  template <class Stream>
+  void InitEagerly(Stream* stream);
+
   EpsCopyOutputStream impl_;
-  uint8* cur_;
-  int64 start_count_;
+  uint8_t* cur_;
+  int64_t start_count_;
   static std::atomic<bool> default_serialization_deterministic_;
 
   // See above.  Other projects may use "friend" to allow them to call this.
@@ -1273,7 +1289,8 @@ class PROTOBUF_EXPORT CodedOutputStream {
     default_serialization_deterministic_.store(true, std::memory_order_relaxed);
   }
   // REQUIRES: value >= 0x80, and that (value & 7f) has been written to *target.
-  static uint8* WriteVarint32ToArrayOutOfLineHelper(uint32 value, uint8* target);
+  static uint8_t* WriteVarint32ToArrayOutOfLineHelper(uint32_t value,
+                                                      uint8_t* target);
   GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(CodedOutputStream);
 };
 
@@ -1281,8 +1298,8 @@ class PROTOBUF_EXPORT CodedOutputStream {
 // The vast majority of varints are only one byte.  These inline
 // methods optimize for that case.
 
-inline bool CodedInputStream::ReadVarint32(uint32* value) {
-  uint32 v = 0;
+inline bool CodedInputStream::ReadVarint32(uint32_t* value) {
+  uint32_t v = 0;
   if (PROTOBUF_PREDICT_TRUE(buffer_ < buffer_end_)) {
     v = *buffer_;
     if (v < 0x80) {
@@ -1291,18 +1308,18 @@ inline bool CodedInputStream::ReadVarint32(uint32* value) {
       return true;
     }
   }
-  int64 result = ReadVarint32Fallback(v);
-  *value = static_cast<uint32>(result);
+  int64_t result = ReadVarint32Fallback(v);
+  *value = static_cast<uint32_t>(result);
   return result >= 0;
 }
 
-inline bool CodedInputStream::ReadVarint64(uint64* value) {
+inline bool CodedInputStream::ReadVarint64(uint64_t* value) {
   if (PROTOBUF_PREDICT_TRUE(buffer_ < buffer_end_) && *buffer_ < 0x80) {
     *value = *buffer_;
     Advance(1);
     return true;
   }
-  std::pair<uint64, bool> p = ReadVarint64Fallback();
+  std::pair<uint64_t, bool> p = ReadVarint64Fallback();
   *value = p.first;
   return p.second;
 }
@@ -1321,40 +1338,40 @@ inline bool CodedInputStream::ReadVarintSizeAsInt(int* value) {
 }
 
 // static
-inline const uint8* CodedInputStream::ReadLittleEndian32FromArray(
-    const uint8* buffer, uint32* value) {
+inline const uint8_t* CodedInputStream::ReadLittleEndian32FromArray(
+    const uint8_t* buffer, uint32_t* value) {
 #if defined(PROTOBUF_LITTLE_ENDIAN)
   memcpy(value, buffer, sizeof(*value));
   return buffer + sizeof(*value);
 #else
-  *value = (static_cast<uint32>(buffer[0])) |
-           (static_cast<uint32>(buffer[1]) << 8) |
-           (static_cast<uint32>(buffer[2]) << 16) |
-           (static_cast<uint32>(buffer[3]) << 24);
+  *value = (static_cast<uint32_t>(buffer[0])) |
+           (static_cast<uint32_t>(buffer[1]) << 8) |
+           (static_cast<uint32_t>(buffer[2]) << 16) |
+           (static_cast<uint32_t>(buffer[3]) << 24);
   return buffer + sizeof(*value);
 #endif
 }
 // static
-inline const uint8* CodedInputStream::ReadLittleEndian64FromArray(
-    const uint8* buffer, uint64* value) {
+inline const uint8_t* CodedInputStream::ReadLittleEndian64FromArray(
+    const uint8_t* buffer, uint64_t* value) {
 #if defined(PROTOBUF_LITTLE_ENDIAN)
   memcpy(value, buffer, sizeof(*value));
   return buffer + sizeof(*value);
 #else
-  uint32 part0 = (static_cast<uint32>(buffer[0])) |
-                 (static_cast<uint32>(buffer[1]) << 8) |
-                 (static_cast<uint32>(buffer[2]) << 16) |
-                 (static_cast<uint32>(buffer[3]) << 24);
-  uint32 part1 = (static_cast<uint32>(buffer[4])) |
-                 (static_cast<uint32>(buffer[5]) << 8) |
-                 (static_cast<uint32>(buffer[6]) << 16) |
-                 (static_cast<uint32>(buffer[7]) << 24);
-  *value = static_cast<uint64>(part0) | (static_cast<uint64>(part1) << 32);
+  uint32_t part0 = (static_cast<uint32_t>(buffer[0])) |
+                   (static_cast<uint32_t>(buffer[1]) << 8) |
+                   (static_cast<uint32_t>(buffer[2]) << 16) |
+                   (static_cast<uint32_t>(buffer[3]) << 24);
+  uint32_t part1 = (static_cast<uint32_t>(buffer[4])) |
+                   (static_cast<uint32_t>(buffer[5]) << 8) |
+                   (static_cast<uint32_t>(buffer[6]) << 16) |
+                   (static_cast<uint32_t>(buffer[7]) << 24);
+  *value = static_cast<uint64_t>(part0) | (static_cast<uint64_t>(part1) << 32);
   return buffer + sizeof(*value);
 #endif
 }
 
-inline bool CodedInputStream::ReadLittleEndian32(uint32* value) {
+inline bool CodedInputStream::ReadLittleEndian32(uint32_t* value) {
 #if defined(PROTOBUF_LITTLE_ENDIAN)
   if (PROTOBUF_PREDICT_TRUE(BufferSize() >= static_cast<int>(sizeof(*value)))) {
     buffer_ = ReadLittleEndian32FromArray(buffer_, value);
@@ -1367,7 +1384,7 @@ inline bool CodedInputStream::ReadLittleEndian32(uint32* value) {
 #endif
 }
 
-inline bool CodedInputStream::ReadLittleEndian64(uint64* value) {
+inline bool CodedInputStream::ReadLittleEndian64(uint64_t* value) {
 #if defined(PROTOBUF_LITTLE_ENDIAN)
   if (PROTOBUF_PREDICT_TRUE(BufferSize() >= static_cast<int>(sizeof(*value)))) {
     buffer_ = ReadLittleEndian64FromArray(buffer_, value);
@@ -1380,8 +1397,8 @@ inline bool CodedInputStream::ReadLittleEndian64(uint64* value) {
 #endif
 }
 
-inline uint32 CodedInputStream::ReadTagNoLastTag() {
-  uint32 v = 0;
+inline uint32_t CodedInputStream::ReadTagNoLastTag() {
+  uint32_t v = 0;
   if (PROTOBUF_PREDICT_TRUE(buffer_ < buffer_end_)) {
     v = *buffer_;
     if (v < 0x80) {
@@ -1393,20 +1410,20 @@ inline uint32 CodedInputStream::ReadTagNoLastTag() {
   return v;
 }
 
-inline std::pair<uint32, bool> CodedInputStream::ReadTagWithCutoffNoLastTag(
-    uint32 cutoff) {
+inline std::pair<uint32_t, bool> CodedInputStream::ReadTagWithCutoffNoLastTag(
+    uint32_t cutoff) {
   // In performance-sensitive code we can expect cutoff to be a compile-time
   // constant, and things like "cutoff >= kMax1ByteVarint" to be evaluated at
   // compile time.
-  uint32 first_byte_or_zero = 0;
+  uint32_t first_byte_or_zero = 0;
   if (PROTOBUF_PREDICT_TRUE(buffer_ < buffer_end_)) {
     // Hot case: buffer_ non_empty, buffer_[0] in [1, 128).
     // TODO(gpike): Is it worth rearranging this? E.g., if the number of fields
     // is large enough then is it better to check for the two-byte case first?
     first_byte_or_zero = buffer_[0];
-    if (static_cast<int8>(buffer_[0]) > 0) {
-      const uint32 kMax1ByteVarint = 0x7f;
-      uint32 tag = buffer_[0];
+    if (static_cast<int8_t>(buffer_[0]) > 0) {
+      const uint32_t kMax1ByteVarint = 0x7f;
+      uint32_t tag = buffer_[0];
       Advance(1);
       return std::make_pair(tag, cutoff >= kMax1ByteVarint || tag <= cutoff);
     }
@@ -1415,8 +1432,8 @@ inline std::pair<uint32, bool> CodedInputStream::ReadTagWithCutoffNoLastTag(
     // first byte and the second byte.
     if (cutoff >= 0x80 && PROTOBUF_PREDICT_TRUE(buffer_ + 1 < buffer_end_) &&
         PROTOBUF_PREDICT_TRUE((buffer_[0] & ~buffer_[1]) >= 0x80)) {
-      const uint32 kMax2ByteVarint = (0x7f << 7) + 0x7f;
-      uint32 tag = (1u << 7) * buffer_[1] + (buffer_[0] - 0x80);
+      const uint32_t kMax2ByteVarint = (0x7f << 7) + 0x7f;
+      uint32_t tag = (1u << 7) * buffer_[1] + (buffer_[0] - 0x80);
       Advance(2);
       // It might make sense to test for tag == 0 now, but it is so rare that
       // that we don't bother.  A varint-encoded 0 should be one byte unless
@@ -1429,11 +1446,11 @@ inline std::pair<uint32, bool> CodedInputStream::ReadTagWithCutoffNoLastTag(
     }
   }
   // Slow path
-  const uint32 tag = ReadTagFallback(first_byte_or_zero);
-  return std::make_pair(tag, static_cast<uint32>(tag - 1) < cutoff);
+  const uint32_t tag = ReadTagFallback(first_byte_or_zero);
+  return std::make_pair(tag, static_cast<uint32_t>(tag - 1) < cutoff);
 }
 
-inline bool CodedInputStream::LastTagWas(uint32 expected) {
+inline bool CodedInputStream::LastTagWas(uint32_t expected) {
   return last_tag_ == expected;
 }
 
@@ -1441,7 +1458,7 @@ inline bool CodedInputStream::ConsumedEntireMessage() {
   return legitimate_message_end_;
 }
 
-inline bool CodedInputStream::ExpectTag(uint32 expected) {
+inline bool CodedInputStream::ExpectTag(uint32_t expected) {
   if (expected < (1 << 7)) {
     if (PROTOBUF_PREDICT_TRUE(buffer_ < buffer_end_) &&
         buffer_[0] == expected) {
@@ -1452,8 +1469,8 @@ inline bool CodedInputStream::ExpectTag(uint32 expected) {
     }
   } else if (expected < (1 << 14)) {
     if (PROTOBUF_PREDICT_TRUE(BufferSize() >= 2) &&
-        buffer_[0] == static_cast<uint8>(expected | 0x80) &&
-        buffer_[1] == static_cast<uint8>(expected >> 7)) {
+        buffer_[0] == static_cast<uint8_t>(expected | 0x80) &&
+        buffer_[1] == static_cast<uint8_t>(expected >> 7)) {
       Advance(2);
       return true;
     } else {
@@ -1465,15 +1482,15 @@ inline bool CodedInputStream::ExpectTag(uint32 expected) {
   }
 }
 
-inline const uint8* CodedInputStream::ExpectTagFromArray(const uint8* buffer,
-                                                         uint32 expected) {
+inline const uint8_t* CodedInputStream::ExpectTagFromArray(
+    const uint8_t* buffer, uint32_t expected) {
   if (expected < (1 << 7)) {
     if (buffer[0] == expected) {
       return buffer + 1;
     }
   } else if (expected < (1 << 14)) {
-    if (buffer[0] == static_cast<uint8>(expected | 0x80) &&
-        buffer[1] == static_cast<uint8>(expected >> 7)) {
+    if (buffer[0] == static_cast<uint8_t>(expected | 0x80) &&
+        buffer[1] == static_cast<uint8_t>(expected >> 7)) {
       return buffer + 2;
     }
   }
@@ -1552,7 +1569,7 @@ inline CodedInputStream::CodedInputStream(ZeroCopyInputStream* input)
       last_tag_(0),
       legitimate_message_end_(false),
       aliasing_enabled_(false),
-      current_limit_(kint32max),
+      current_limit_(std::numeric_limits<int32_t>::max()),
       buffer_size_after_limit_(0),
       total_bytes_limit_(kDefaultTotalBytesLimit),
       recursion_budget_(default_recursion_limit_),
@@ -1563,7 +1580,7 @@ inline CodedInputStream::CodedInputStream(ZeroCopyInputStream* input)
   Refresh();
 }
 
-inline CodedInputStream::CodedInputStream(const uint8* buffer, int size)
+inline CodedInputStream::CodedInputStream(const uint8_t* buffer, int size)
     : buffer_(buffer),
       buffer_end_(buffer + size),
       input_(nullptr),
@@ -1599,14 +1616,14 @@ inline bool CodedInputStream::Skip(int count) {
   return SkipFallback(count, original_buffer_size);
 }
 
-inline uint8* CodedOutputStream::WriteVarint32ToArray(uint32 value,
-                                                      uint8* target) {
+inline uint8* CodedOutputStream::WriteVarint32ToArray(uint32_t value,
+                                                      uint8_t* target) {
   return EpsCopyOutputStream::UnsafeVarint(value, target);
 }
 
-inline uint8* CodedOutputStream::WriteVarint32ToArrayOutOfLine(uint32 value,
-                                                               uint8* target) {
-  target[0] = static_cast<uint8>(value);
+inline uint8_t* CodedOutputStream::WriteVarint32ToArrayOutOfLine(
+    uint32_t value, uint8_t* target) {
+  target[0] = static_cast<uint8_t>(value);
   if (value < 0x80) {
     return target + 1;
   } else {
@@ -1614,95 +1631,111 @@ inline uint8* CodedOutputStream::WriteVarint32ToArrayOutOfLine(uint32 value,
   }
 }
 
-inline uint8* CodedOutputStream::WriteVarint64ToArray(uint64 value,
-                                                      uint8* target) {
+inline uint8_t* CodedOutputStream::WriteVarint64ToArray(uint64_t value,
+                                                        uint8_t* target) {
   return EpsCopyOutputStream::UnsafeVarint(value, target);
 }
 
-inline void CodedOutputStream::WriteVarint32SignExtended(int32 value) {
-  WriteVarint64(static_cast<uint64>(value));
+inline void CodedOutputStream::WriteVarint32SignExtended(int32_t value) {
+  WriteVarint64(static_cast<uint64_t>(value));
 }
 
-inline uint8* CodedOutputStream::WriteVarint32SignExtendedToArray(
-    int32 value, uint8* target) {
-  return WriteVarint64ToArray(static_cast<uint64>(value), target);
+inline uint8_t* CodedOutputStream::WriteVarint32SignExtendedToArray(
+    int32_t value, uint8_t* target) {
+  return WriteVarint64ToArray(static_cast<uint64_t>(value), target);
 }
 
-inline uint8* CodedOutputStream::WriteLittleEndian32ToArray(uint32 value,
-                                                            uint8* target) {
+inline uint8_t* CodedOutputStream::WriteLittleEndian32ToArray(uint32_t value,
+                                                              uint8_t* target) {
 #if defined(PROTOBUF_LITTLE_ENDIAN)
   memcpy(target, &value, sizeof(value));
 #else
-  target[0] = static_cast<uint8>(value);
-  target[1] = static_cast<uint8>(value >> 8);
-  target[2] = static_cast<uint8>(value >> 16);
-  target[3] = static_cast<uint8>(value >> 24);
+  target[0] = static_cast<uint8_t>(value);
+  target[1] = static_cast<uint8_t>(value >> 8);
+  target[2] = static_cast<uint8_t>(value >> 16);
+  target[3] = static_cast<uint8_t>(value >> 24);
 #endif
   return target + sizeof(value);
 }
 
-inline uint8* CodedOutputStream::WriteLittleEndian64ToArray(uint64 value,
-                                                            uint8* target) {
+inline uint8_t* CodedOutputStream::WriteLittleEndian64ToArray(uint64_t value,
+                                                              uint8_t* target) {
 #if defined(PROTOBUF_LITTLE_ENDIAN)
   memcpy(target, &value, sizeof(value));
 #else
-  uint32 part0 = static_cast<uint32>(value);
-  uint32 part1 = static_cast<uint32>(value >> 32);
-
-  target[0] = static_cast<uint8>(part0);
-  target[1] = static_cast<uint8>(part0 >> 8);
-  target[2] = static_cast<uint8>(part0 >> 16);
-  target[3] = static_cast<uint8>(part0 >> 24);
-  target[4] = static_cast<uint8>(part1);
-  target[5] = static_cast<uint8>(part1 >> 8);
-  target[6] = static_cast<uint8>(part1 >> 16);
-  target[7] = static_cast<uint8>(part1 >> 24);
+  uint32_t part0 = static_cast<uint32_t>(value);
+  uint32_t part1 = static_cast<uint32_t>(value >> 32);
+
+  target[0] = static_cast<uint8_t>(part0);
+  target[1] = static_cast<uint8_t>(part0 >> 8);
+  target[2] = static_cast<uint8_t>(part0 >> 16);
+  target[3] = static_cast<uint8_t>(part0 >> 24);
+  target[4] = static_cast<uint8_t>(part1);
+  target[5] = static_cast<uint8_t>(part1 >> 8);
+  target[6] = static_cast<uint8_t>(part1 >> 16);
+  target[7] = static_cast<uint8_t>(part1 >> 24);
 #endif
   return target + sizeof(value);
 }
 
-inline void CodedOutputStream::WriteVarint32(uint32 value) {
+inline void CodedOutputStream::WriteVarint32(uint32_t value) {
   cur_ = impl_.EnsureSpace(cur_);
   SetCur(WriteVarint32ToArray(value, Cur()));
 }
 
-inline void CodedOutputStream::WriteVarint64(uint64 value) {
+inline void CodedOutputStream::WriteVarint64(uint64_t value) {
   cur_ = impl_.EnsureSpace(cur_);
   SetCur(WriteVarint64ToArray(value, Cur()));
 }
 
-inline void CodedOutputStream::WriteTag(uint32 value) { WriteVarint32(value); }
+inline void CodedOutputStream::WriteTag(uint32_t value) {
+  WriteVarint32(value);
+}
 
-inline uint8* CodedOutputStream::WriteTagToArray(uint32 value, uint8* target) {
+inline uint8_t* CodedOutputStream::WriteTagToArray(uint32_t value,
+                                                   uint8_t* target) {
   return WriteVarint32ToArray(value, target);
 }
 
-inline size_t CodedOutputStream::VarintSize32(uint32 value) {
+inline size_t CodedOutputStream::VarintSize32(uint32_t value) {
   // This computes value == 0 ? 1 : floor(log2(value)) / 7 + 1
   // Use an explicit multiplication to implement the divide of
   // a number in the 1..31 range.
   // Explicit OR 0x1 to avoid calling Bits::Log2FloorNonZero(0), which is
   // undefined.
-  uint32 log2value = Bits::Log2FloorNonZero(value | 0x1);
+  uint32_t log2value = Bits::Log2FloorNonZero(value | 0x1);
   return static_cast<size_t>((log2value * 9 + 73) / 64);
 }
 
-inline size_t CodedOutputStream::VarintSize64(uint64 value) {
+inline size_t CodedOutputStream::VarintSize32PlusOne(uint32_t value) {
+  // Same as above, but one more.
+  uint32_t log2value = Bits::Log2FloorNonZero(value | 0x1);
+  return static_cast<size_t>((log2value * 9 + 73 + 64) / 64);
+}
+
+inline size_t CodedOutputStream::VarintSize64(uint64_t value) {
   // This computes value == 0 ? 1 : floor(log2(value)) / 7 + 1
   // Use an explicit multiplication to implement the divide of
   // a number in the 1..63 range.
   // Explicit OR 0x1 to avoid calling Bits::Log2FloorNonZero(0), which is
   // undefined.
-  uint32 log2value = Bits::Log2FloorNonZero64(value | 0x1);
+  uint32_t log2value = Bits::Log2FloorNonZero64(value | 0x1);
   return static_cast<size_t>((log2value * 9 + 73) / 64);
 }
 
-inline size_t CodedOutputStream::VarintSize32SignExtended(int32 value) {
-  if (value < 0) {
-    return 10;  // TODO(kenton):  Make this a symbolic constant.
-  } else {
-    return VarintSize32(static_cast<uint32>(value));
-  }
+inline size_t CodedOutputStream::VarintSize64PlusOne(uint64_t value) {
+  // Same as above, but one more.
+  uint32_t log2value = Bits::Log2FloorNonZero64(value | 0x1);
+  return static_cast<size_t>((log2value * 9 + 73 + 64) / 64);
+}
+
+inline size_t CodedOutputStream::VarintSize32SignExtended(int32_t value) {
+  return VarintSize64(static_cast<uint64_t>(int64_t{value}));
+}
+
+inline size_t CodedOutputStream::VarintSize32SignExtendedPlusOne(
+    int32_t value) {
+  return VarintSize64PlusOne(static_cast<uint64_t>(int64_t{value}));
 }
 
 inline void CodedOutputStream::WriteString(const std::string& str) {
@@ -1714,14 +1747,14 @@ inline void CodedOutputStream::WriteRawMaybeAliased(const void* data,
   cur_ = impl_.WriteRawMaybeAliased(data, size, cur_);
 }
 
-inline uint8* CodedOutputStream::WriteRawToArray(const void* data, int size,
-                                                 uint8* target) {
+inline uint8_t* CodedOutputStream::WriteRawToArray(const void* data, int size,
+                                                   uint8_t* target) {
   memcpy(target, data, size);
   return target + size;
 }
 
-inline uint8* CodedOutputStream::WriteStringToArray(const std::string& str,
-                                                    uint8* target) {
+inline uint8_t* CodedOutputStream::WriteStringToArray(const std::string& str,
+                                                      uint8_t* target) {
   return WriteRawToArray(str.data(), static_cast<int>(str.size()), target);
 }
 
diff --git protobuf-3.17.3protobuf-3.17.3/src/google/protobuf/io/coded_stream_unittest.cc protobuf-3.17.3-patchedprotobuf-3.17.3-patched/src/google/protobuf/io/coded_stream_unittest.cc
index d02cc88..6e45d04 100644
--- protobuf-3.17.3protobuf-3.17.3/src/google/protobuf/io/coded_stream_unittest.cc
+++ protobuf-3.17.3-patchedprotobuf-3.17.3-patched/src/google/protobuf/io/coded_stream_unittest.cc
@@ -49,6 +49,7 @@
 #include <gtest/gtest.h>
 #include <google/protobuf/stubs/casts.h>
 
+// Must be included last.
 #include <google/protobuf/port_def.inc>
 
 
@@ -741,7 +742,7 @@ TEST_1D(CodedStreamTest, ReadStringReservesMemoryOnTotalLimit, kBlockSizes) {
 
   {
     CodedInputStream coded_input(&input);
-    coded_input.SetTotalBytesLimit(sizeof(kRawBytes), sizeof(kRawBytes));
+    coded_input.SetTotalBytesLimit(sizeof(kRawBytes));
     EXPECT_EQ(sizeof(kRawBytes), coded_input.BytesUntilTotalBytesLimit());
 
     std::string str;
@@ -864,7 +865,7 @@ TEST_F(CodedStreamTest, ReadStringNoReservationSizeIsOverTheTotalBytesLimit) {
 
   {
     CodedInputStream coded_input(&input);
-    coded_input.SetTotalBytesLimit(16, 16);
+    coded_input.SetTotalBytesLimit(16);
 
     std::string str;
     EXPECT_FALSE(coded_input.ReadString(&str, strlen(kRawBytes)));
@@ -886,7 +887,7 @@ TEST_F(CodedStreamTest,
   {
     CodedInputStream coded_input(&input);
     coded_input.PushLimit(sizeof(buffer_));
-    coded_input.SetTotalBytesLimit(16, 16);
+    coded_input.SetTotalBytesLimit(16);
 
     std::string str;
     EXPECT_FALSE(coded_input.ReadString(&str, strlen(kRawBytes)));
@@ -908,7 +909,7 @@ TEST_F(CodedStreamTest,
   {
     CodedInputStream coded_input(&input);
     coded_input.PushLimit(16);
-    coded_input.SetTotalBytesLimit(sizeof(buffer_), sizeof(buffer_));
+    coded_input.SetTotalBytesLimit(sizeof(buffer_));
     EXPECT_EQ(sizeof(buffer_), coded_input.BytesUntilTotalBytesLimit());
 
     std::string str;
@@ -1180,7 +1181,7 @@ TEST_F(CodedStreamTest, OverflowLimit) {
 TEST_F(CodedStreamTest, TotalBytesLimit) {
   ArrayInputStream input(buffer_, sizeof(buffer_));
   CodedInputStream coded_input(&input);
-  coded_input.SetTotalBytesLimit(16, -1);
+  coded_input.SetTotalBytesLimit(16);
   EXPECT_EQ(16, coded_input.BytesUntilTotalBytesLimit());
 
   std::string str;
@@ -1200,7 +1201,7 @@ TEST_F(CodedStreamTest, TotalBytesLimit) {
                       "A protocol message was rejected because it was too big",
                       errors[0]);
 
-  coded_input.SetTotalBytesLimit(32, -1);
+  coded_input.SetTotalBytesLimit(32);
   EXPECT_EQ(16, coded_input.BytesUntilTotalBytesLimit());
   EXPECT_TRUE(coded_input.ReadString(&str, 16));
   EXPECT_EQ(0, coded_input.BytesUntilTotalBytesLimit());
@@ -1213,7 +1214,7 @@ TEST_F(CodedStreamTest, TotalBytesLimitNotValidMessageEnd) {
   CodedInputStream coded_input(&input);
 
   // Set both total_bytes_limit and a regular limit at 16 bytes.
-  coded_input.SetTotalBytesLimit(16, -1);
+  coded_input.SetTotalBytesLimit(16);
   CodedInputStream::Limit limit = coded_input.PushLimit(16);
 
   // Read 16 bytes.
diff --git protobuf-3.17.3protobuf-3.17.3/src/google/protobuf/map_test.cc protobuf-3.17.3-patchedprotobuf-3.17.3-patched/src/google/protobuf/map_test.cc
index 1414fc3..f7c024c 100644
--- protobuf-3.17.3protobuf-3.17.3/src/google/protobuf/map_test.cc
+++ protobuf-3.17.3-patchedprotobuf-3.17.3-patched/src/google/protobuf/map_test.cc
@@ -28,3783 +28,56 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-// A hack to include windows.h first, which ensures the GetMessage macro can
-// be undefined when we include <google/protobuf/stubs/common.h>
-#if defined(_WIN32)
-#define _WINSOCKAPI_  // to avoid re-definition in WinSock2.h
-#define NOMINMAX      // to avoid defining min/max macros
-#include <windows.h>
-#endif  // _WIN32
-
-#include <algorithm>
-#include <map>
-#include <memory>
-#include <random>
-#include <set>
-#include <sstream>
-#include <unordered_map>
-#include <unordered_set>
-#include <vector>
-
-#include <google/protobuf/stubs/logging.h>
-#include <google/protobuf/stubs/common.h>
-#include <google/protobuf/stubs/stringprintf.h>
-#include <google/protobuf/testing/file.h>
-#include <google/protobuf/arena_test_util.h>
 #include <google/protobuf/map_proto2_unittest.pb.h>
-#include <google/protobuf/map_test_util.h>
 #include <google/protobuf/map_unittest.pb.h>
-#include <google/protobuf/test_util.h>
+#include <google/protobuf/reflection_tester.h>
 #include <google/protobuf/test_util2.h>
-#include <google/protobuf/unittest.pb.h>
-#include <google/protobuf/io/coded_stream.h>
-#include <google/protobuf/io/tokenizer.h>
-#include <google/protobuf/io/zero_copy_stream_impl.h>
-#include <google/protobuf/descriptor.pb.h>
-#include <google/protobuf/descriptor.h>
-#include <google/protobuf/descriptor_database.h>
-#include <google/protobuf/dynamic_message.h>
-#include <google/protobuf/map.h>
-#include <google/protobuf/map_field_inl.h>
-#include <google/protobuf/message.h>
-#include <google/protobuf/reflection.h>
-#include <google/protobuf/reflection_ops.h>
-#include <google/protobuf/text_format.h>
-#include <google/protobuf/wire_format.h>
-#include <google/protobuf/util/message_differencer.h>
-#include <google/protobuf/util/time_util.h>
-#include <gmock/gmock.h>
-#include <google/protobuf/testing/googletest.h>
-#include <gtest/gtest.h>
-#include <google/protobuf/stubs/casts.h>
-#include <google/protobuf/stubs/substitute.h>
 
 
+#define BRIDGE_UNITTEST ::google::protobuf::bridge_unittest
+#define UNITTEST ::protobuf_unittest
+#define UNITTEST_IMPORT ::protobuf_unittest_import
+#define UNITTEST_PACKAGE_NAME "protobuf_unittest"
+
+// Must include after defining UNITTEST, etc.
+// clang-format off
+#include <google/protobuf/test_util.inc>
+#include <google/protobuf/map_test_util.inc>
+#include <google/protobuf/map_test.inc>
+// clang-format on
+
 // Must be included last.
 #include <google/protobuf/port_def.inc>
 
 namespace google {
 namespace protobuf {
-
-using unittest::ForeignMessage;
-using unittest::TestAllTypes;
-using unittest::TestMap;
-using unittest::TestRecursiveMapMessage;
-
 namespace internal {
-
-void MapTestForceDeterministic() {
-  io::CodedOutputStream::SetDefaultSerializationDeterministic();
-}
-
 namespace {
 
-// Map API Test =====================================================
-
-class MapImplTest : public ::testing::Test {
- protected:
-  MapImplTest()
-      : map_ptr_(new Map<int32, int32>()),
-        map_(*map_ptr_),
-        const_map_(*map_ptr_) {
-    EXPECT_TRUE(map_.empty());
-    EXPECT_EQ(0, map_.size());
-  }
-
-  void ExpectSingleElement(int32 key, int32 value) {
-    EXPECT_FALSE(map_.empty());
-    EXPECT_EQ(1, map_.size());
-    ExpectElement(key, value);
-  }
-
-  void ExpectElements(const std::map<int32, int32>& map) {
-    EXPECT_FALSE(map_.empty());
-    EXPECT_EQ(map.size(), map_.size());
-    for (std::map<int32, int32>::const_iterator it = map.begin();
-         it != map.end(); ++it) {
-      ExpectElement(it->first, it->second);
-    }
-  }
-
-  void ExpectElement(int32 key, int32 value) {
-    // Test map size is correct.
-    EXPECT_EQ(value, map_[key]);
-    EXPECT_EQ(1, map_.count(key));
-    EXPECT_TRUE(map_.contains(key));
-
-    // Check mutable at and find work correctly.
-    EXPECT_EQ(value, map_.at(key));
-    Map<int32, int32>::iterator it = map_.find(key);
-
-    // iterator dereferenceable
-    EXPECT_EQ(key, (*it).first);
-    EXPECT_EQ(value, (*it).second);
-    EXPECT_EQ(key, it->first);
-    EXPECT_EQ(value, it->second);
-
-    // iterator mutable
-    ((*it).second) = value + 1;
-    EXPECT_EQ(value + 1, map_[key]);
-    ((*it).second) = value;
-    EXPECT_EQ(value, map_[key]);
-
-    it->second = value + 1;
-    EXPECT_EQ(value + 1, map_[key]);
-    it->second = value;
-    EXPECT_EQ(value, map_[key]);
-
-    // copy constructor
-    Map<int32, int32>::iterator it_copy = it;
-    EXPECT_EQ(key, it_copy->first);
-    EXPECT_EQ(value, it_copy->second);
-
-    // Immutable API ================================================
-
-    // Check immutable at and find work correctly.
-    EXPECT_EQ(value, const_map_.at(key));
-    Map<int32, int32>::const_iterator const_it = const_map_.find(key);
-
-    // iterator dereferenceable
-    EXPECT_EQ(key, (*const_it).first);
-    EXPECT_EQ(value, (*const_it).second);
-    EXPECT_EQ(key, const_it->first);
-    EXPECT_EQ(value, const_it->second);
-
-    // copy constructor
-    Map<int32, int32>::const_iterator const_it_copy = const_it;
-    EXPECT_EQ(key, const_it_copy->first);
-    EXPECT_EQ(value, const_it_copy->second);
-  }
-
-  std::unique_ptr<Map<int32, int32> > map_ptr_;
-  Map<int32, int32>& map_;
-  const Map<int32, int32>& const_map_;
-};
-
-TEST_F(MapImplTest, OperatorBracket) {
-  int32 key = 0;
-  int32 value1 = 100;
-  int32 value2 = 101;
-
-  EXPECT_EQ(0, map_[key]);
-
-  map_[key] = value1;
-  ExpectSingleElement(key, value1);
-
-  map_[key] = value2;
-  ExpectSingleElement(key, value2);
-}
-
-struct MoveTestKey {
-  MoveTestKey(int data, int* copies) : data(data), copies(copies) {}
-
-  MoveTestKey(const MoveTestKey& other)
-      : data(other.data), copies(other.copies) {
-    ++*copies;
-  }
-
-  MoveTestKey(MoveTestKey&& other) noexcept
-      : data(other.data), copies(other.copies) {}
 
-  friend bool operator==(const MoveTestKey& lhs, const MoveTestKey& rhs) {
-    return lhs.data == rhs.data;
-  }
-  friend bool operator<(const MoveTestKey& lhs, const MoveTestKey& rhs) {
-    return lhs.data < rhs.data;
-  }
-
-  int data;
-  int* copies;
+struct AlignedAsDefault {
+  int x;
 };
-
-}  // namespace
-}  // namespace internal
-}  // namespace protobuf
-}  // namespace google
-
-namespace std {
-
-template <>  // NOLINT
-struct hash<google::protobuf::internal::MoveTestKey> {
-  size_t operator()(const google::protobuf::internal::MoveTestKey& key) const {
-    return hash<int>{}(key.data);
-  }
+struct alignas(8) AlignedAs8 {
+  int x;
 };
-}  // namespace std
 
-namespace google {
-namespace protobuf {
-namespace internal {
-namespace {
-
-TEST_F(MapImplTest, OperatorBracketRValue) {
+template <typename Aligned, bool on_arena = false>
+void MapTest_Aligned() {
   Arena arena;
-  for (Arena* arena_to_use : {&arena, static_cast<Arena*>(nullptr)}) {
-    int copies = 0;
-    Map<MoveTestKey, int> map(arena_to_use);
-    MoveTestKey key1(1, &copies);
-    EXPECT_EQ(copies, 0);
-    map[key1] = 0;
-    EXPECT_EQ(copies, 1);
-    map[MoveTestKey(2, &copies)] = 2;
-    EXPECT_EQ(copies, 1);
-  }
-}
-
-TEST_F(MapImplTest, OperatorBracketNonExist) {
-  int32 key = 0;
-  int32 default_value = 0;
-
-  EXPECT_EQ(default_value, map_[key]);
-  ExpectSingleElement(key, default_value);
-}
-
-TEST_F(MapImplTest, MutableAt) {
-  int32 key = 0;
-  int32 value1 = 100;
-  int32 value2 = 101;
-
-  map_[key] = value1;
-  ExpectSingleElement(key, value1);
-
-  map_.at(key) = value2;
-  ExpectSingleElement(key, value2);
-}
-
-#ifdef PROTOBUF_HAS_DEATH_TEST
-
-TEST_F(MapImplTest, MutableAtNonExistDeathTest) {
-  EXPECT_DEATH(map_.at(0), "");
-}
-
-TEST_F(MapImplTest, ImmutableAtNonExistDeathTest) {
-  EXPECT_DEATH(const_map_.at(0), "");
-}
-
-TEST_F(MapImplTest, UsageErrors) {
-  MapKey key;
-  key.SetInt64Value(1);
-  EXPECT_DEATH(key.GetUInt64Value(),
-               "Protocol Buffer map usage error:\n"
-               "MapKey::GetUInt64Value type does not match\n"
-               "  Expected : uint64\n"
-               "  Actual   : int64");
-
-  MapValueRef value;
-  EXPECT_DEATH(
-      value.SetFloatValue(0.1),
-      "Protocol Buffer map usage error:\n"
-      "MapValue[Const]*Ref::type MapValue[Const]*Ref is not initialized.");
-}
-
-#endif  // PROTOBUF_HAS_DEATH_TEST
-
-TEST_F(MapImplTest, MapKeyAssignment) {
-  MapKey from, to;
-  from.SetStringValue("abc");
-  to = from;
-  EXPECT_EQ("abc", to.GetStringValue());
-}
-
-TEST_F(MapImplTest, CountNonExist) { EXPECT_EQ(0, map_.count(0)); }
-
-TEST_F(MapImplTest, ContainNotExist) { EXPECT_FALSE(map_.contains(0)); }
-
-TEST_F(MapImplTest, ImmutableContainNotExist) {
-  EXPECT_FALSE(const_map_.contains(0));
-}
-
-TEST_F(MapImplTest, MutableFindNonExist) {
-  EXPECT_TRUE(map_.end() == map_.find(0));
-}
-
-TEST_F(MapImplTest, ImmutableFindNonExist) {
-  EXPECT_TRUE(const_map_.end() == const_map_.find(0));
-}
-
-TEST_F(MapImplTest, ConstEnd) {
-  EXPECT_TRUE(const_map_.end() == const_map_.cend());
-}
-
-TEST_F(MapImplTest, GetReferenceFromIterator) {
-  for (int i = 0; i < 10; i++) {
-    map_[i] = i;
-  }
-
-  for (Map<int32, int32>::const_iterator it = map_.cbegin();
-       it != map_.cend();) {
-    Map<int32, int32>::const_reference entry = *it++;
-    EXPECT_EQ(entry.first, entry.second);
-  }
-
-  for (Map<int32, int32>::const_iterator it = const_map_.begin();
-       it != const_map_.end();) {
-    Map<int32, int32>::const_reference entry = *it++;
-    EXPECT_EQ(entry.first, entry.second);
-  }
-
-  for (Map<int32, int32>::iterator it = map_.begin(); it != map_.end();) {
-    Map<int32, int32>::reference entry = *it++;
-    EXPECT_EQ(entry.first + 1, ++entry.second);
-  }
-}
-
-TEST_F(MapImplTest, IteratorBasic) {
-  map_[0] = 0;
-
-  // Default constructible (per forward iterator requirements).
-  Map<int, int>::const_iterator cit;
-  Map<int, int>::iterator it;
-
-  it = map_.begin();
-  cit = it;  // Converts to const_iterator
-
-  // Can compare between them.
-  EXPECT_TRUE(it == cit);
-  EXPECT_FALSE(cit != it);
-
-  // Pre increment.
-  EXPECT_FALSE(it == ++cit);
-
-  // Post increment.
-  EXPECT_FALSE(it++ == cit);
-  EXPECT_TRUE(it == cit);
-}
-
-template <typename Iterator>
-static int64 median(Iterator i0, Iterator i1) {
-  std::vector<int64> v(i0, i1);
-  std::nth_element(v.begin(), v.begin() + v.size() / 2, v.end());
-  return v[v.size() / 2];
-}
-
-static int64 Now() {
-  return util::TimeUtil::TimestampToNanoseconds(
-      util::TimeUtil::GetCurrentTime());
-}
-
-// Arbitrary odd integers for creating test data.
-static int k0 = 812398771;
-static int k1 = 1312938717;
-static int k2 = 1321555333;
-
-// A naive begin() implementation will cause begin() to get slower and slower
-// if one erases elements at the "front" of the hash map, and we'd like to
-// avoid that, as std::unordered_map does.
-TEST_F(MapImplTest, BeginIsFast) {
-  if (true) return;  // TODO(gpike): make this less flaky and re-enable it.
-  Map<int32, int32> map;
-  const int kTestSize = 250000;
-  // Create a random-looking map of size n.  Use non-negative integer keys.
-  uint32 frog = 123983;
-  int last_key = 0;
-  int counter = 0;
-  while (map.size() < kTestSize) {
-    frog *= static_cast<uint32>(k0);
-    frog ^= frog >> 17;
-    frog += counter++;
-    last_key =
-        static_cast<int>(frog) >= 0 ? static_cast<int>(frog) : last_key ^ 1;
-    GOOGLE_DCHECK_GE(last_key, 0);
-    map[last_key] = last_key ^ 1;
-  }
-  std::vector<int64> times;
-  // We're going to do map.erase(map.begin()) over and over again.  But,
-  // just in case one iteration is fast compared to the granularity of
-  // our time keeping, we measure kChunkSize iterations per outer-loop iter.
-  const int kChunkSize = 1000;
-  GOOGLE_CHECK_EQ(kTestSize % kChunkSize, 0);
-  do {
-    const int64 start = Now();
-    for (int i = 0; i < kChunkSize; i++) {
-      map.erase(map.begin());
-    }
-    const int64 end = Now();
-    if (end > start) {
-      times.push_back(end - start);
-    }
-  } while (!map.empty());
-  if (times.size() < .99 * kTestSize / kChunkSize) {
-    GOOGLE_LOG(WARNING) << "Now() isn't helping us measure time";
-    return;
-  }
-  int64 x0 = median(times.begin(), times.begin() + 9);
-  int64 x1 = median(times.begin() + times.size() - 9, times.end());
-  GOOGLE_LOG(INFO) << "x0=" << x0 << ", x1=" << x1;
-  // x1 will greatly exceed x0 if the code we just executed took O(n^2) time.
-  // And we'll probably time out and never get here.  So, this test is
-  // intentionally loose: we check that x0 and x1 are within a factor of 8.
-  EXPECT_GE(x1, x0 / 8);
-  EXPECT_GE(x0, x1 / 8);
-}
-
-// Try to create kTestSize keys that will land in just a few buckets, and
-// time the insertions, to get a rough estimate of whether an O(n^2) worst case
-// was triggered.  This test is a hacky, but probably better than nothing.
-TEST_F(MapImplTest, HashFlood) {
-  const int kTestSize = 1024;  // must be a power of 2
-  std::set<int> s;
-  for (int i = 0; s.size() < kTestSize; i++) {
-    if ((map_.hash_function()(i) & (kTestSize - 1)) < 3) {
-      s.insert(i);
-    }
-  }
-  // Create hash table with kTestSize entries that hash flood a table with
-  // 1024 (or 512 or 2048 or ...) entries.  This assumes that map_ uses powers
-  // of 2 for table sizes, and that it's sufficient to "flood" with respect to
-  // the low bits of the output of map_.hash_function().
-  std::vector<int64> times;
-  std::set<int>::iterator it = s.begin();
-  int count = 0;
-  do {
-    const int64 start = Now();
-    map_[*it] = 0;
-    const int64 end = Now();
-    if (end > start) {
-      times.push_back(end - start);
-    }
-    ++count;
-    ++it;
-  } while (it != s.end());
-  if (times.size() < .99 * count) return;
-  int64 x0 = median(times.begin(), times.begin() + 9);
-  int64 x1 = median(times.begin() + times.size() - 9, times.end());
-  // x1 will greatly exceed x0 if the code we just executed took O(n^2) time.
-  // But we want to allow O(n log n).  A factor of 20 should be generous enough.
-  EXPECT_LE(x1, x0 * 20);
-}
-
-TEST_F(MapImplTest, CopyIteratorStressTest) {
-  std::vector<Map<int32, int32>::iterator> v;
-  const int kIters = 1e5;
-  for (uint32 i = 0; i < kIters; i++) {
-    int32 key = (3 + i * (5 + i * (-8 + i * (62 + i)))) & 0x77777777;
-    map_[key] = i;
-    v.push_back(map_.find(key));
-  }
-  for (std::vector<Map<int32, int32>::iterator>::const_iterator it = v.begin();
-       it != v.end(); it++) {
-    Map<int32, int32>::iterator i = *it;
-    ASSERT_EQ(i->first, (*it)->first);
-    ASSERT_EQ(i->second, (*it)->second);
-  }
-}
-
-template <typename T, typename U>
-static void TestValidityForAllKeysExcept(int key_to_avoid, const T& check_map,
-                                         const U& map) {
-  typedef typename U::value_type value_type;  // a key-value pair
-  for (typename U::const_iterator it = map.begin(); it != map.end(); ++it) {
-    const int key = it->first;
-    if (key == key_to_avoid) continue;
-    // All iterators relevant to this key, whether old (from check_map) or new,
-    // must point to the same memory.  So, test pointer equality here.
-    const value_type* check_val = &*check_map.find(key)->second;
-    EXPECT_EQ(check_val, &*it);
-    EXPECT_EQ(check_val, &*map.find(key));
-  }
-}
-
-// EXPECT i0 and i1 to be the same.  Advancing them should have the same effect,
-// too.
-template <typename Iter>
-static void TestEqualIterators(Iter i0, Iter i1, Iter end) {
-  const int kMaxAdvance = 10;
-  for (int i = 0; i < kMaxAdvance; i++) {
-    EXPECT_EQ(i0 == end, i1 == end);
-    if (i0 == end) return;
-    EXPECT_EQ(&*i0, &*i1) << "iter " << i;
-    ++i0;
-    ++i1;
-  }
-}
-
-template <typename IteratorType>
-static void TestOldVersusNewIterator(int skip, Map<int, int>* m) {
-  const int initial_size = m->size();
-  IteratorType it = m->begin();
-  for (int i = 0; i < skip && it != m->end(); it++, i++) {
-  }
-  if (it == m->end()) return;
-  const IteratorType old = it;
-  GOOGLE_LOG(INFO) << "skip=" << skip << ", old->first=" << old->first;
-  const int target_size =
-      initial_size < 100 ? initial_size * 5 : initial_size * 5 / 4;
-  for (int i = 0; m->size() <= target_size; i++) {
-    (*m)[i] = 0;
-  }
-  // Iterator 'old' should still work just fine despite the growth of *m.
-  const IteratorType after_growth = m->find(old->first);
-  TestEqualIterators<IteratorType>(old, after_growth, m->end());
-
-  // Now shrink the number of elements.  Do this with a mix of erases and
-  // inserts to increase the chance that the hashtable will resize to a lower
-  // number of buckets.  (But, in any case, the test is still useful.)
-  for (int i = 0; i < 2 * (target_size - initial_size); i++) {
-    if (i != old->first) {
-      m->erase(i);
-    }
-    if (((i ^ m->begin()->first) & 15) == 0) {
-      (*m)[i * 342] = i;
-    }
-  }
-  // Now, the table has grown and shrunk; test again.
-  TestEqualIterators<IteratorType>(old, m->find(old->first), m->end());
-  TestEqualIterators<IteratorType>(old, after_growth, m->end());
-}
-
-// Create and test an n-element Map, with emphasis on iterator correctness.
-static void StressTestIterators(int n) {
-  GOOGLE_LOG(INFO) << "StressTestIterators " << n;
-  GOOGLE_CHECK_GT(n, 0);
-  // Create a random-looking map of size n.  Use non-negative integer keys.
-  Map<int, int> m;
-  uint32 frog = 123987 + n;
-  int last_key = 0;
-  int counter = 0;
-  while (m.size() < n) {
-    frog *= static_cast<uint32>(k0);
-    frog ^= frog >> 17;
-    frog += counter++;
-    last_key =
-        static_cast<int>(frog) >= 0 ? static_cast<int>(frog) : last_key ^ 1;
-    GOOGLE_DCHECK_GE(last_key, 0);
-    m[last_key] = last_key ^ 1;
-  }
-  // Test it.
-  ASSERT_EQ(n, m.size());
-  // Create maps of pointers and iterators.
-  // These should remain valid even if we modify m.
-  std::unordered_map<int, Map<int, int>::value_type*> mp(n);
-  std::unordered_map<int, Map<int, int>::iterator> mi(n);
-  for (Map<int, int>::iterator it = m.begin(); it != m.end(); ++it) {
-    mp[it->first] = &*it;
-    mi[it->first] = it;
-  }
-  ASSERT_EQ(m.size(), mi.size());
-  ASSERT_EQ(m.size(), mp.size());
-  m.erase(last_key);
-  ASSERT_EQ(n - 1, m.size());
-  TestValidityForAllKeysExcept(last_key, mp, m);
-  TestValidityForAllKeysExcept(last_key, mi, m);
-
-  m[last_key] = 0;
-  ASSERT_EQ(n, m.size());
-  // Test old iterator vs new iterator, with table modification in between.
-  TestOldVersusNewIterator<Map<int, int>::const_iterator>(n % 3, &m);
-  TestOldVersusNewIterator<Map<int, int>::iterator>(n % (1 + (n / 40)), &m);
-  // Finally, ensure erase(iterator) doesn't reorder anything, because that is
-  // what its documentation says.
-  m[last_key] = m[last_key ^ 999] = 0;
-  std::vector<Map<int, int>::iterator> v;
-  v.reserve(m.size());
-  int position_of_last_key = 0;
-  for (Map<int, int>::iterator it = m.begin(); it != m.end(); ++it) {
-    if (it->first == last_key) {
-      position_of_last_key = v.size();
-    }
-    v.push_back(it);
-  }
-  ASSERT_EQ(m.size(), v.size());
-  const Map<int, int>::iterator erase_result = m.erase(m.find(last_key));
-  int index = 0;
-  for (Map<int, int>::iterator it = m.begin(); it != m.end(); ++it, ++index) {
-    if (index == position_of_last_key) {
-      EXPECT_EQ(&*erase_result, &*v[++index]);
-    }
-    ASSERT_EQ(&*it, &*v[index]);
-  }
-}
-
-TEST_F(MapImplTest, IteratorInvalidation) {
-  // Create a set of pseudo-random sizes to test.
-#ifndef NDEBUG
-  const int kMaxSizeToTest = 100 * 1000;
-#else
-  const int kMaxSizeToTest = 1000 * 1000;
-#endif
-  std::set<int> s;
-  int n = kMaxSizeToTest;
-  unsigned int frog = k1 + n;
-  while (n > 1 && s.size() < 25) {
-    s.insert(n);
-    n = static_cast<int>(n * 100 / (101.0 + (frog & 63)));
-    frog *= k2;
-    frog ^= frog >> 17;
-  }
-  // Ensure we test a few small sizes.
-  s.insert(1);
-  s.insert(2);
-  s.insert(3);
-  // Now, the real work.
-  for (std::set<int>::iterator i = s.begin(); i != s.end(); ++i) {
-    StressTestIterators(*i);
-  }
-}
-
-// Test that erase() revalidates iterators.
-TEST_F(MapImplTest, EraseRevalidates) {
-  map_[3] = map_[13] = map_[20] = 0;
-  const int initial_size = map_.size();
-  EXPECT_EQ(3, initial_size);
-  std::vector<Map<int, int>::iterator> v;
-  for (Map<int, int>::iterator it = map_.begin(); it != map_.end(); ++it) {
-    v.push_back(it);
-  }
-  EXPECT_EQ(initial_size, v.size());
-  for (int i = 0; map_.size() <= initial_size * 20; i++) {
-    map_[i] = 0;
-  }
-  const int larger_size = map_.size();
-  // We've greatly increased the size of the map, so it is highly likely that
-  // the following will corrupt m if erase() doesn't properly revalidate
-  // iterators passed to it.  Finishing this routine without crashing indicates
-  // success.
-  for (int i = 0; i < v.size(); i++) {
-    map_.erase(v[i]);
-  }
-  EXPECT_EQ(larger_size - v.size(), map_.size());
-}
-
-template <typename T>
-bool IsConstHelper(T& /*t*/) {  // NOLINT. We want to catch non-const refs here.
-  return false;
-}
-template <typename T>
-bool IsConstHelper(const T& /*t*/) {
-  return true;
-}
-
-TEST_F(MapImplTest, IteratorConstness) {
-  map_[0] = 0;
-  EXPECT_TRUE(IsConstHelper(*map_.cbegin()));
-  EXPECT_TRUE(IsConstHelper(*const_map_.begin()));
-  EXPECT_FALSE(IsConstHelper(*map_.begin()));
-}
-
-bool IsForwardIteratorHelper(std::forward_iterator_tag /*tag*/) { return true; }
-
-TEST_F(MapImplTest, IteratorCategory) {
-  EXPECT_TRUE(IsForwardIteratorHelper(
-      std::iterator_traits<Map<int, int>::iterator>::iterator_category()));
-  EXPECT_TRUE(IsForwardIteratorHelper(
-      std::iterator_traits<
-          Map<int, int>::const_iterator>::iterator_category()));
-}
-
-TEST_F(MapImplTest, InsertSingle) {
-  int32 key = 0;
-  int32 value1 = 100;
-  int32 value2 = 101;
-
-  // Insert a non-existed key.
-  std::pair<Map<int32, int32>::iterator, bool> result1 =
-      map_.insert(Map<int32, int32>::value_type(key, value1));
-  ExpectSingleElement(key, value1);
-
-  Map<int32, int32>::iterator it1 = result1.first;
-  EXPECT_EQ(key, it1->first);
-  EXPECT_EQ(value1, it1->second);
-  EXPECT_TRUE(result1.second);
-
-  // Insert an existed key.
-  std::pair<Map<int32, int32>::iterator, bool> result2 =
-      map_.insert(Map<int32, int32>::value_type(key, value2));
-  ExpectSingleElement(key, value1);
-
-  Map<int32, int32>::iterator it2 = result2.first;
-  EXPECT_TRUE(it1 == it2);
-  EXPECT_FALSE(result2.second);
-}
-
-TEST_F(MapImplTest, InsertByIterator) {
-  int32 key1 = 0;
-  int32 key2 = 1;
-  int32 value1a = 100;
-  int32 value1b = 101;
-  int32 value2a = 200;
-  int32 value2b = 201;
-
-  std::map<int32, int32> map1;
-  map1[key1] = value1a;
-  map1[key2] = value2a;
-
-  map_.insert(map1.begin(), map1.end());
-  ExpectElements(map1);
-
-  std::map<int32, int32> map2;
-  map2[key1] = value1b;
-  map2[key2] = value2b;
-
-  map_.insert(map2.begin(), map2.end());
-  ExpectElements(map1);
-}
-
-TEST_F(MapImplTest, InsertByInitializerList) {
-  map_.insert({{1, 100}, {2, 200}});
-  ExpectElements({{1, 100}, {2, 200}});
-
-  map_.insert({{2, 201}, {3, 301}});
-  ExpectElements({{1, 100}, {2, 200}, {3, 301}});
-}
-
-TEST_F(MapImplTest, EraseSingleByKey) {
-  int32 key = 0;
-  int32 value = 100;
-
-  map_[key] = value;
-  ExpectSingleElement(key, value);
-
-  // Erase an existing key.
-  EXPECT_EQ(1, map_.erase(key));
-  EXPECT_TRUE(map_.empty());
-  EXPECT_EQ(0, map_.size());
-  EXPECT_TRUE(map_.end() == map_.find(key));
-  EXPECT_TRUE(map_.begin() == map_.end());
-
-  // Erase a non-existing key.
-  EXPECT_EQ(0, map_.erase(key));
-}
-
-TEST_F(MapImplTest, EraseMutipleByKey) {
-  // erase in one specific order to trigger corner cases
-  for (int i = 0; i < 5; i++) {
-    map_[i] = i;
-  }
-
-  map_.erase(0);
-  EXPECT_EQ(4, map_.size());
-  EXPECT_TRUE(map_.end() == map_.find(0));
-
-  map_.erase(1);
-  EXPECT_EQ(3, map_.size());
-  EXPECT_TRUE(map_.end() == map_.find(1));
-
-  map_.erase(3);
-  EXPECT_EQ(2, map_.size());
-  EXPECT_TRUE(map_.end() == map_.find(3));
-
-  map_.erase(4);
-  EXPECT_EQ(1, map_.size());
-  EXPECT_TRUE(map_.end() == map_.find(4));
-
-  map_.erase(2);
-  EXPECT_EQ(0, map_.size());
-  EXPECT_TRUE(map_.end() == map_.find(2));
-}
-
-TEST_F(MapImplTest, EraseSingleByIterator) {
-  int32 key = 0;
-  int32 value = 100;
-
-  map_[key] = value;
-  ExpectSingleElement(key, value);
-
-  Map<int32, int32>::iterator it = map_.find(key);
-  map_.erase(it);
-  EXPECT_TRUE(map_.empty());
-  EXPECT_EQ(0, map_.size());
-  EXPECT_TRUE(map_.end() == map_.find(key));
-  EXPECT_TRUE(map_.begin() == map_.end());
-}
-
-TEST_F(MapImplTest, ValidIteratorAfterErase) {
-  for (int i = 0; i < 10; i++) {
-    map_[i] = i;
-  }
-
-  int count = 0;
-
-  for (Map<int32, int32>::iterator it = map_.begin(); it != map_.end();) {
-    count++;
-    if (it->first % 2 == 1) {
-      map_.erase(it++);
-    } else {
-      ++it;
-    }
-  }
-
-  EXPECT_EQ(10, count);
-  EXPECT_EQ(5, map_.size());
-}
-
-TEST_F(MapImplTest, EraseByIterator) {
-  int32 key1 = 0;
-  int32 key2 = 1;
-  int32 value1 = 100;
-  int32 value2 = 101;
-
-  std::map<int32, int32> map;
-  map[key1] = value1;
-  map[key2] = value2;
-
-  map_.insert(map.begin(), map.end());
-  ExpectElements(map);
-
-  map_.erase(map_.begin(), map_.end());
-  EXPECT_TRUE(map_.empty());
-  EXPECT_EQ(0, map_.size());
-  EXPECT_TRUE(map_.end() == map_.find(key1));
-  EXPECT_TRUE(map_.end() == map_.find(key2));
-  EXPECT_TRUE(map_.begin() == map_.end());
-}
-
-TEST_F(MapImplTest, Clear) {
-  int32 key = 0;
-  int32 value = 100;
-
-  map_[key] = value;
-  ExpectSingleElement(key, value);
-
-  map_.clear();
-
-  EXPECT_TRUE(map_.empty());
-  EXPECT_EQ(0, map_.size());
-  EXPECT_TRUE(map_.end() == map_.find(key));
-  EXPECT_TRUE(map_.begin() == map_.end());
-}
-
-static void CopyConstructorHelper(Arena* arena, Map<int32, int32>* m) {
-  int32 key1 = 0;
-  int32 key2 = 1;
-  int32 value1 = 100;
-  int32 value2 = 101;
-
-  std::map<int32, int32> map;
-  map[key1] = value1;
-  map[key2] = value2;
-
-  m->insert(map.begin(), map.end());
-
-  Map<int32, int32> other(*m);
-
-  EXPECT_EQ(2, other.size());
-  EXPECT_EQ(value1, other.at(key1));
-  EXPECT_EQ(value2, other.at(key2));
-}
-
-TEST_F(MapImplTest, CopyConstructorWithArena) {
-  Arena a;
-  CopyConstructorHelper(&a, &map_);
-}
-
-TEST_F(MapImplTest, CopyConstructorWithoutArena) {
-  CopyConstructorHelper(NULL, &map_);
-}
-
-TEST_F(MapImplTest, IterConstructor) {
-  int32 key1 = 0;
-  int32 key2 = 1;
-  int32 value1 = 100;
-  int32 value2 = 101;
-
-  std::map<int32, int32> map;
-  map[key1] = value1;
-  map[key2] = value2;
-
-  Map<int32, int32> new_map(map.begin(), map.end());
-
-  EXPECT_EQ(2, new_map.size());
-  EXPECT_EQ(value1, new_map.at(key1));
-  EXPECT_EQ(value2, new_map.at(key2));
-}
-
-TEST_F(MapImplTest, Assigner) {
-  int32 key1 = 0;
-  int32 key2 = 1;
-  int32 value1 = 100;
-  int32 value2 = 101;
-
-  std::map<int32, int32> map;
-  map[key1] = value1;
-  map[key2] = value2;
-
-  map_.insert(map.begin(), map.end());
-
-  Map<int32, int32> other;
-  int32 key_other = 123;
-  int32 value_other = 321;
-  other[key_other] = value_other;
-  EXPECT_EQ(1, other.size());
-
-  other = map_;
-
-  EXPECT_EQ(2, other.size());
-  EXPECT_EQ(value1, other.at(key1));
-  EXPECT_EQ(value2, other.at(key2));
-  EXPECT_TRUE(other.find(key_other) == other.end());
-
-  // Self assign
-  other = *&other;  // Avoid -Wself-assign.
-  EXPECT_EQ(2, other.size());
-  EXPECT_EQ(value1, other.at(key1));
-  EXPECT_EQ(value2, other.at(key2));
-}
-
-TEST_F(MapImplTest, Rehash) {
-  const int test_size = 50;
-  std::map<int32, int32> reference_map;
-  for (int i = 0; i < test_size; i++) {
-    reference_map[i] = i;
-  }
-  for (int i = 0; i < test_size; i++) {
-    map_[i] = reference_map[i];
-    EXPECT_EQ(reference_map[i], map_[i]);
-  }
-  for (int i = 0; i < test_size; i++) {
-    map_.erase(i);
-    EXPECT_TRUE(map_.end() == map_.find(i));
-  }
-  EXPECT_TRUE(map_.empty());
-}
-
-TEST_F(MapImplTest, EqualRange) {
-  int key = 100, key_missing = 101;
-  map_[key] = 100;
-
-  std::pair<Map<int32, int32>::iterator, Map<int32, int32>::iterator> range =
-      map_.equal_range(key);
-  EXPECT_TRUE(map_.find(key) == range.first);
-  EXPECT_TRUE(++map_.find(key) == range.second);
-
-  range = map_.equal_range(key_missing);
-  EXPECT_TRUE(map_.end() == range.first);
-  EXPECT_TRUE(map_.end() == range.second);
-
-  std::pair<Map<int32, int32>::const_iterator,
-            Map<int32, int32>::const_iterator>
-      const_range = const_map_.equal_range(key);
-  EXPECT_TRUE(const_map_.find(key) == const_range.first);
-  EXPECT_TRUE(++const_map_.find(key) == const_range.second);
-
-  const_range = const_map_.equal_range(key_missing);
-  EXPECT_TRUE(const_map_.end() == const_range.first);
-  EXPECT_TRUE(const_map_.end() == const_range.second);
-}
-
-TEST_F(MapImplTest, ConvertToStdMap) {
-  map_[100] = 101;
-  std::map<int32, int32> std_map(map_.begin(), map_.end());
-  EXPECT_EQ(1, std_map.size());
-  EXPECT_EQ(101, std_map[100]);
-}
-
-TEST_F(MapImplTest, ConvertToStdVectorOfPairs) {
-  map_[100] = 101;
-  std::vector<std::pair<int32, int32> > std_vec(map_.begin(), map_.end());
-  EXPECT_EQ(1, std_vec.size());
-  EXPECT_EQ(100, std_vec[0].first);
-  EXPECT_EQ(101, std_vec[0].second);
-}
-
-TEST_F(MapImplTest, SwapBasic) {
-  Map<int32, int32> another;
-  map_[9398] = 41999;
-  another[9398] = 41999;
-  another[8070] = 42056;
-  another.swap(map_);
-  EXPECT_THAT(another,
-              testing::UnorderedElementsAre(testing::Pair(9398, 41999)));
-  EXPECT_THAT(map_, testing::UnorderedElementsAre(testing::Pair(8070, 42056),
-                                                  testing::Pair(9398, 41999)));
-}
-
-TEST_F(MapImplTest, SwapArena) {
-  Arena arena1, arena2;
-  Map<int32, int32> m1(&arena1);
-  Map<int32, int32> m2(&arena2);
-  map_[9398] = 41999;
-  m1[9398] = 41999;
-  m1[8070] = 42056;
-  m2[10244] = 10247;
-  m2[8070] = 42056;
-  m1.swap(map_);
-  EXPECT_THAT(m1, testing::UnorderedElementsAre(testing::Pair(9398, 41999)));
-  EXPECT_THAT(map_, testing::UnorderedElementsAre(testing::Pair(8070, 42056),
-                                                  testing::Pair(9398, 41999)));
-  m2.swap(m1);
-  EXPECT_THAT(m1, testing::UnorderedElementsAre(testing::Pair(8070, 42056),
-                                                testing::Pair(10244, 10247)));
-  EXPECT_THAT(m2, testing::UnorderedElementsAre(testing::Pair(9398, 41999)));
-}
-
-TEST_F(MapImplTest, CopyAssignMapIterator) {
-  TestMap message;
-  MapReflectionTester reflection_tester(unittest::TestMap::descriptor());
-  reflection_tester.SetMapFieldsViaMapReflection(&message);
-  MapIterator it1 = reflection_tester.MapBegin(&message, "map_int32_int32");
-  MapIterator it2 = reflection_tester.MapEnd(&message, "map_int32_int32");
-  it2 = it1;
-  EXPECT_EQ(it1.GetKey().GetInt32Value(), it2.GetKey().GetInt32Value());
-}
-
-TEST_F(MapImplTest, SpaceUsed) {
-  constexpr size_t kMinCap = 8;
-
-  Map<int32, int32> m;
-  // An newly constructed map should have no space used.
-  EXPECT_EQ(m.SpaceUsedExcludingSelfLong(), 0);
-
-  size_t capacity = kMinCap;
-  for (int i = 0; i < 100; ++i) {
-    m[i];
-    static constexpr double kMaxLoadFactor = .75;
-    if (m.size() >= capacity * kMaxLoadFactor) {
-      capacity *= 2;
-    }
-    EXPECT_EQ(m.SpaceUsedExcludingSelfLong(),
-              sizeof(void*) * capacity +
-                  m.size() * sizeof(std::pair<std::pair<int32, int32>, void*>));
-  }
-
-  // Test string, and non-scalar keys.
-  Map<std::string, int32> m2;
-  std::string str = "Some arbitrarily large string";
-  m2[str] = 1;
-  EXPECT_EQ(m2.SpaceUsedExcludingSelfLong(),
-            sizeof(void*) * kMinCap +
-                sizeof(std::pair<std::pair<std::string, int32>, void*>) +
-                internal::StringSpaceUsedExcludingSelfLong(str));
-
-  // Test messages, and non-scalar values.
-  Map<int32, TestAllTypes> m3;
-  m3[0].set_optional_string(str);
-  EXPECT_EQ(m3.SpaceUsedExcludingSelfLong(),
-            sizeof(void*) * kMinCap +
-                sizeof(std::pair<std::pair<int32, TestAllTypes>, void*>) +
-                m3[0].SpaceUsedLong() - sizeof(m3[0]));
-}
-
-// Attempts to verify that a map with keys a and b has a random ordering. This
-// function returns true if it succeeds in observing both possible orderings.
-bool MapOrderingIsRandom(int a, int b) {
-  bool saw_a_first = false;
-  bool saw_b_first = false;
-
-  for (int i = 0; i < 50; ++i) {
-    Map<int32, int32> m;
-    m[a] = 0;
-    m[b] = 0;
-    int32 first_element = m.begin()->first;
-    if (first_element == a) saw_a_first = true;
-    if (first_element == b) saw_b_first = true;
-    if (saw_a_first && saw_b_first) {
-      return true;
-    }
-  }
-
-  return false;
-}
-
-// This test verifies that the iteration order is reasonably random even for
-// small maps. Currently we only have sufficient randomness for debug builds and
-// builds where we can use the RDTSC instruction, so we only test for those
-// builds.
-#if defined(__x86_64__) && defined(__GNUC__) && \
-    !defined(GOOGLE_PROTOBUF_NO_RDTSC)
-TEST_F(MapImplTest, RandomOrdering) {
-  for (int i = 0; i < 10; ++i) {
-    for (int j = i + 1; j < 10; ++j) {
-      EXPECT_TRUE(MapOrderingIsRandom(i, j))
-          << "Map with keys " << i << " and " << j
-          << " has deterministic ordering";
-    }
-  }
-}
-#endif
-
-template <typename Key>
-void TestTransparent(const Key& key, const Key& miss_key) {
-  Map<std::string, int> m;
-  const auto& cm = m;
-
-  m.insert({"ABC", 1});
-
-  const auto abc_it = m.begin();
-
-  m.insert({"DEF", 2});
-
-  using testing::Pair;
-  using testing::UnorderedElementsAre;
-
-  EXPECT_EQ(m.at(key), 1);
-  EXPECT_EQ(cm.at(key), 1);
-
-#ifdef PROTOBUF_HAS_DEATH_TEST
-  EXPECT_DEATH(m.at(miss_key), "");
-  EXPECT_DEATH(cm.at(miss_key), "");
-#endif  // PROTOBUF_HAS_DEATH_TEST
-
-  EXPECT_EQ(m.count(key), 1);
-  EXPECT_EQ(cm.count(key), 1);
-  EXPECT_EQ(m.count(miss_key), 0);
-  EXPECT_EQ(cm.count(miss_key), 0);
-
-  EXPECT_EQ(m.find(key), abc_it);
-  EXPECT_EQ(cm.find(key), abc_it);
-  EXPECT_EQ(m.find(miss_key), m.end());
-  EXPECT_EQ(cm.find(miss_key), cm.end());
-
-  EXPECT_TRUE(m.contains(key));
-  EXPECT_TRUE(cm.contains(key));
-  EXPECT_FALSE(m.contains(miss_key));
-  EXPECT_FALSE(cm.contains(miss_key));
-
-  EXPECT_THAT(m.equal_range(key), Pair(abc_it, std::next(abc_it)));
-  EXPECT_THAT(cm.equal_range(key), Pair(abc_it, std::next(abc_it)));
-  EXPECT_THAT(m.equal_range(miss_key), Pair(m.end(), m.end()));
-  EXPECT_THAT(cm.equal_range(miss_key), Pair(m.end(), m.end()));
-
-  EXPECT_THAT(m, UnorderedElementsAre(Pair("ABC", 1), Pair("DEF", 2)));
-  EXPECT_EQ(m.erase(key), 1);
-  EXPECT_THAT(m, UnorderedElementsAre(Pair("DEF", 2)));
-  EXPECT_EQ(m.erase(key), 0);
-  EXPECT_EQ(m.erase(miss_key), 0);
-  EXPECT_THAT(m, UnorderedElementsAre(Pair("DEF", 2)));
-
-  m[key];
-  EXPECT_THAT(m, UnorderedElementsAre(Pair("ABC", 0), Pair("DEF", 2)));
-  m[key] = 1;
-  EXPECT_THAT(m, UnorderedElementsAre(Pair("ABC", 1), Pair("DEF", 2)));
-}
-
-TEST_F(MapImplTest, TransparentLookupForString) {
-  TestTransparent("ABC", "LKJ");
-  TestTransparent(std::string("ABC"), std::string("LKJ"));
-#if defined(__cpp_lib_string_view)
-  TestTransparent(std::string_view("ABC"), std::string_view("LKJ"));
-#endif  // defined(__cpp_lib_string_view)
-
-  // std::reference_wrapper
-  std::string abc = "ABC", lkj = "LKJ";
-  TestTransparent(std::ref(abc), std::ref(lkj));
-  TestTransparent(std::cref(abc), std::cref(lkj));
-}
-
-TEST_F(MapImplTest, ConstInit) {
-  PROTOBUF_CONSTINIT static Map<int, int> map;  // NOLINT
-  EXPECT_TRUE(map.empty());
-}
-
-// Map Field Reflection Test ========================================
-
-static int Func(int i, int j) { return i * j; }
-
-static std::string StrFunc(int i, int j) { return StrCat(Func(i, j)); }
-
-static int Int(const std::string& value) {
-  int result = 0;
-  std::istringstream(value) >> result;
-  return result;
-}
-
-}  // namespace
-
-// This class is a friend, so no anonymous namespace.
-class MapFieldReflectionTest : public testing::Test {
- protected:
-  typedef FieldDescriptor FD;
-
-  int MapSize(const Reflection* reflection, const FieldDescriptor* field,
-              const Message& message) {
-    return reflection->MapSize(message, field);
-  }
-};
-
-namespace {
-
-TEST_F(MapFieldReflectionTest, RegularFields) {
-  TestMap message;
-  const Reflection* refl = message.GetReflection();
-  const Descriptor* desc = message.GetDescriptor();
-
-  Map<int32, int32>* map_int32_int32 = message.mutable_map_int32_int32();
-  Map<int32, double>* map_int32_double = message.mutable_map_int32_double();
-  Map<std::string, std::string>* map_string_string =
-      message.mutable_map_string_string();
-  Map<int32, ForeignMessage>* map_int32_foreign_message =
-      message.mutable_map_int32_foreign_message();
-
-  for (int i = 0; i < 10; ++i) {
-    (*map_int32_int32)[i] = Func(i, 1);
-    (*map_int32_double)[i] = Func(i, 2);
-    (*map_string_string)[StrFunc(i, 1)] = StrFunc(i, 5);
-    (*map_int32_foreign_message)[i].set_c(Func(i, 6));
-  }
-
-  // Get FieldDescriptors for all the fields of interest.
-  const FieldDescriptor* fd_map_int32_int32 =
-      desc->FindFieldByName("map_int32_int32");
-  const FieldDescriptor* fd_map_int32_double =
-      desc->FindFieldByName("map_int32_double");
-  const FieldDescriptor* fd_map_string_string =
-      desc->FindFieldByName("map_string_string");
-  const FieldDescriptor* fd_map_int32_foreign_message =
-      desc->FindFieldByName("map_int32_foreign_message");
-
-  const FieldDescriptor* fd_map_int32_in32_key =
-      fd_map_int32_int32->message_type()->FindFieldByName("key");
-  const FieldDescriptor* fd_map_int32_in32_value =
-      fd_map_int32_int32->message_type()->FindFieldByName("value");
-  const FieldDescriptor* fd_map_int32_double_key =
-      fd_map_int32_double->message_type()->FindFieldByName("key");
-  const FieldDescriptor* fd_map_int32_double_value =
-      fd_map_int32_double->message_type()->FindFieldByName("value");
-  const FieldDescriptor* fd_map_string_string_key =
-      fd_map_string_string->message_type()->FindFieldByName("key");
-  const FieldDescriptor* fd_map_string_string_value =
-      fd_map_string_string->message_type()->FindFieldByName("value");
-  const FieldDescriptor* fd_map_int32_foreign_message_key =
-      fd_map_int32_foreign_message->message_type()->FindFieldByName("key");
-  const FieldDescriptor* fd_map_int32_foreign_message_value =
-      fd_map_int32_foreign_message->message_type()->FindFieldByName("value");
-
-  // Get RepeatedPtrField objects for all fields of interest.
-  const RepeatedPtrField<Message>& mf_int32_int32 =
-      refl->GetRepeatedPtrField<Message>(message, fd_map_int32_int32);
-  const RepeatedPtrField<Message>& mf_int32_double =
-      refl->GetRepeatedPtrField<Message>(message, fd_map_int32_double);
-  const RepeatedPtrField<Message>& mf_string_string =
-      refl->GetRepeatedPtrField<Message>(message, fd_map_string_string);
-  const RepeatedPtrField<Message>& mf_int32_foreign_message =
-      refl->GetRepeatedPtrField<Message>(message, fd_map_int32_foreign_message);
-
-  // Get mutable RepeatedPtrField objects for all fields of interest.
-  RepeatedPtrField<Message>* mmf_int32_int32 =
-      refl->MutableRepeatedPtrField<Message>(&message, fd_map_int32_int32);
-  RepeatedPtrField<Message>* mmf_int32_double =
-      refl->MutableRepeatedPtrField<Message>(&message, fd_map_int32_double);
-  RepeatedPtrField<Message>* mmf_string_string =
-      refl->MutableRepeatedPtrField<Message>(&message, fd_map_string_string);
-  RepeatedPtrField<Message>* mmf_int32_foreign_message =
-      refl->MutableRepeatedPtrField<Message>(&message,
-                                             fd_map_int32_foreign_message);
-
-  // Make sure we can do gets through the RepeatedPtrField objects.
-  for (int i = 0; i < 10; ++i) {
-    {
-      // Check gets through const objects.
-      const Message& message_int32_int32 = mf_int32_int32.Get(i);
-      int32 key_int32_int32 = message_int32_int32.GetReflection()->GetInt32(
-          message_int32_int32, fd_map_int32_in32_key);
-      int32 value_int32_int32 = message_int32_int32.GetReflection()->GetInt32(
-          message_int32_int32, fd_map_int32_in32_value);
-      EXPECT_EQ(value_int32_int32, Func(key_int32_int32, 1));
-
-      const Message& message_int32_double = mf_int32_double.Get(i);
-      int32 key_int32_double = message_int32_double.GetReflection()->GetInt32(
-          message_int32_double, fd_map_int32_double_key);
-      double value_int32_double =
-          message_int32_double.GetReflection()->GetDouble(
-              message_int32_double, fd_map_int32_double_value);
-      EXPECT_EQ(value_int32_double, Func(key_int32_double, 2));
-
-      const Message& message_string_string = mf_string_string.Get(i);
-      std::string key_string_string =
-          message_string_string.GetReflection()->GetString(
-              message_string_string, fd_map_string_string_key);
-      std::string value_string_string =
-          message_string_string.GetReflection()->GetString(
-              message_string_string, fd_map_string_string_value);
-      EXPECT_EQ(value_string_string, StrFunc(Int(key_string_string), 5));
-
-      const Message& message_int32_message = mf_int32_foreign_message.Get(i);
-      int32 key_int32_message = message_int32_message.GetReflection()->GetInt32(
-          message_int32_message, fd_map_int32_foreign_message_key);
-      const ForeignMessage& value_int32_message =
-          down_cast<const ForeignMessage&>(
-              message_int32_message.GetReflection()->GetMessage(
-                  message_int32_message, fd_map_int32_foreign_message_value));
-      EXPECT_EQ(value_int32_message.c(), Func(key_int32_message, 6));
-    }
-
-    {
-      // Check gets through mutable objects.
-      const Message& message_int32_int32 = mmf_int32_int32->Get(i);
-      int32 key_int32_int32 = message_int32_int32.GetReflection()->GetInt32(
-          message_int32_int32, fd_map_int32_in32_key);
-      int32 value_int32_int32 = message_int32_int32.GetReflection()->GetInt32(
-          message_int32_int32, fd_map_int32_in32_value);
-      EXPECT_EQ(value_int32_int32, Func(key_int32_int32, 1));
-
-      const Message& message_int32_double = mmf_int32_double->Get(i);
-      int32 key_int32_double = message_int32_double.GetReflection()->GetInt32(
-          message_int32_double, fd_map_int32_double_key);
-      double value_int32_double =
-          message_int32_double.GetReflection()->GetDouble(
-              message_int32_double, fd_map_int32_double_value);
-      EXPECT_EQ(value_int32_double, Func(key_int32_double, 2));
-
-      const Message& message_string_string = mmf_string_string->Get(i);
-      std::string key_string_string =
-          message_string_string.GetReflection()->GetString(
-              message_string_string, fd_map_string_string_key);
-      std::string value_string_string =
-          message_string_string.GetReflection()->GetString(
-              message_string_string, fd_map_string_string_value);
-      EXPECT_EQ(value_string_string, StrFunc(Int(key_string_string), 5));
-
-      const Message& message_int32_message = mmf_int32_foreign_message->Get(i);
-      int32 key_int32_message = message_int32_message.GetReflection()->GetInt32(
-          message_int32_message, fd_map_int32_foreign_message_key);
-      const ForeignMessage& value_int32_message =
-          down_cast<const ForeignMessage&>(
-              message_int32_message.GetReflection()->GetMessage(
-                  message_int32_message, fd_map_int32_foreign_message_value));
-      EXPECT_EQ(value_int32_message.c(), Func(key_int32_message, 6));
-    }
-  }
-
-  // Do sets through the RepeatedPtrField objects.
-  for (int i = 0; i < 10; i++) {
-    {
-      Message* message_int32_int32 = mmf_int32_int32->Mutable(i);
-      int32 key_int32_int32 = message_int32_int32->GetReflection()->GetInt32(
-          *message_int32_int32, fd_map_int32_in32_key);
-      message_int32_int32->GetReflection()->SetInt32(message_int32_int32,
-                                                     fd_map_int32_in32_value,
-                                                     Func(key_int32_int32, -1));
-
-      Message* message_int32_double = mmf_int32_double->Mutable(i);
-      int32 key_int32_double = message_int32_double->GetReflection()->GetInt32(
-          *message_int32_double, fd_map_int32_double_key);
-      message_int32_double->GetReflection()->SetDouble(
-          message_int32_double, fd_map_int32_double_value,
-          Func(key_int32_double, -2));
-
-      Message* message_string_string = mmf_string_string->Mutable(i);
-      std::string key_string_string =
-          message_string_string->GetReflection()->GetString(
-              *message_string_string, fd_map_string_string_key);
-      message_string_string->GetReflection()->SetString(
-          message_string_string, fd_map_string_string_value,
-          StrFunc(Int(key_string_string), -5));
-
-      Message* message_int32_message = mmf_int32_foreign_message->Mutable(i);
-      int32 key_int32_message =
-          message_int32_message->GetReflection()->GetInt32(
-              *message_int32_message, fd_map_int32_foreign_message_key);
-      ForeignMessage* value_int32_message = down_cast<ForeignMessage*>(
-          message_int32_message->GetReflection()->MutableMessage(
-              message_int32_message, fd_map_int32_foreign_message_value));
-      value_int32_message->set_c(Func(key_int32_message, -6));
-    }
-  }
-
-  // Check gets through mutable objects.
-  for (int i = 0; i < 10; i++) {
-    EXPECT_EQ(Func(i, -1), message.map_int32_int32().at(i));
-    EXPECT_EQ(Func(i, -2), message.map_int32_double().at(i));
-    EXPECT_EQ(StrFunc(i, -5), message.map_string_string().at(StrFunc(i, 1)));
-    EXPECT_EQ(Func(i, -6), message.map_int32_foreign_message().at(i).c());
-  }
-}
-
-TEST_F(MapFieldReflectionTest, RepeatedFieldRefForRegularFields) {
-  TestMap message;
-  const Reflection* refl = message.GetReflection();
-  const Descriptor* desc = message.GetDescriptor();
-
-  Map<int32, int32>* map_int32_int32 = message.mutable_map_int32_int32();
-  Map<int32, double>* map_int32_double = message.mutable_map_int32_double();
-  Map<std::string, std::string>* map_string_string =
-      message.mutable_map_string_string();
-  Map<int32, ForeignMessage>* map_int32_foreign_message =
-      message.mutable_map_int32_foreign_message();
-
-  for (int i = 0; i < 10; ++i) {
-    (*map_int32_int32)[i] = Func(i, 1);
-    (*map_int32_double)[i] = Func(i, 2);
-    (*map_string_string)[StrFunc(i, 1)] = StrFunc(i, 5);
-    (*map_int32_foreign_message)[i].set_c(Func(i, 6));
-  }
-
-  // Get FieldDescriptors for all the fields of interest.
-  const FieldDescriptor* fd_map_int32_int32 =
-      desc->FindFieldByName("map_int32_int32");
-  const FieldDescriptor* fd_map_int32_double =
-      desc->FindFieldByName("map_int32_double");
-  const FieldDescriptor* fd_map_string_string =
-      desc->FindFieldByName("map_string_string");
-  const FieldDescriptor* fd_map_int32_foreign_message =
-      desc->FindFieldByName("map_int32_foreign_message");
-
-  const FieldDescriptor* fd_map_int32_in32_key =
-      fd_map_int32_int32->message_type()->FindFieldByName("key");
-  const FieldDescriptor* fd_map_int32_in32_value =
-      fd_map_int32_int32->message_type()->FindFieldByName("value");
-  const FieldDescriptor* fd_map_int32_double_key =
-      fd_map_int32_double->message_type()->FindFieldByName("key");
-  const FieldDescriptor* fd_map_int32_double_value =
-      fd_map_int32_double->message_type()->FindFieldByName("value");
-  const FieldDescriptor* fd_map_string_string_key =
-      fd_map_string_string->message_type()->FindFieldByName("key");
-  const FieldDescriptor* fd_map_string_string_value =
-      fd_map_string_string->message_type()->FindFieldByName("value");
-  const FieldDescriptor* fd_map_int32_foreign_message_key =
-      fd_map_int32_foreign_message->message_type()->FindFieldByName("key");
-  const FieldDescriptor* fd_map_int32_foreign_message_value =
-      fd_map_int32_foreign_message->message_type()->FindFieldByName("value");
-
-  // Get RepeatedFieldRef objects for all fields of interest.
-  const RepeatedFieldRef<Message> mf_int32_int32 =
-      refl->GetRepeatedFieldRef<Message>(message, fd_map_int32_int32);
-  const RepeatedFieldRef<Message> mf_int32_double =
-      refl->GetRepeatedFieldRef<Message>(message, fd_map_int32_double);
-  const RepeatedFieldRef<Message> mf_string_string =
-      refl->GetRepeatedFieldRef<Message>(message, fd_map_string_string);
-  const RepeatedFieldRef<Message> mf_int32_foreign_message =
-      refl->GetRepeatedFieldRef<Message>(message, fd_map_int32_foreign_message);
-
-  // Get mutable RepeatedFieldRef objects for all fields of interest.
-  const MutableRepeatedFieldRef<Message> mmf_int32_int32 =
-      refl->GetMutableRepeatedFieldRef<Message>(&message, fd_map_int32_int32);
-  const MutableRepeatedFieldRef<Message> mmf_int32_double =
-      refl->GetMutableRepeatedFieldRef<Message>(&message, fd_map_int32_double);
-  const MutableRepeatedFieldRef<Message> mmf_string_string =
-      refl->GetMutableRepeatedFieldRef<Message>(&message, fd_map_string_string);
-  const MutableRepeatedFieldRef<Message> mmf_int32_foreign_message =
-      refl->GetMutableRepeatedFieldRef<Message>(&message,
-                                                fd_map_int32_foreign_message);
-
-  // Get entry default instances
-  std::unique_ptr<Message> entry_int32_int32(
-      MessageFactory::generated_factory()
-          ->GetPrototype(fd_map_int32_int32->message_type())
-          ->New(message.GetArena()));
-  std::unique_ptr<Message> entry_int32_double(
-      MessageFactory::generated_factory()
-          ->GetPrototype(fd_map_int32_double->message_type())
-          ->New(message.GetArena()));
-  std::unique_ptr<Message> entry_string_string(
-      MessageFactory::generated_factory()
-          ->GetPrototype(fd_map_string_string->message_type())
-          ->New(message.GetArena()));
-  std::unique_ptr<Message> entry_int32_foreign_message(
-      MessageFactory::generated_factory()
-          ->GetPrototype(fd_map_int32_foreign_message->message_type())
-          ->New(message.GetArena()));
-
-  EXPECT_EQ(10, mf_int32_int32.size());
-  EXPECT_EQ(10, mmf_int32_int32.size());
-  EXPECT_EQ(10, mf_int32_double.size());
-  EXPECT_EQ(10, mmf_int32_double.size());
-  EXPECT_EQ(10, mf_string_string.size());
-  EXPECT_EQ(10, mmf_string_string.size());
-  EXPECT_EQ(10, mf_int32_foreign_message.size());
-  EXPECT_EQ(10, mmf_int32_foreign_message.size());
-
-  EXPECT_FALSE(mf_int32_int32.empty());
-  EXPECT_FALSE(mmf_int32_int32.empty());
-  EXPECT_FALSE(mf_int32_double.empty());
-  EXPECT_FALSE(mmf_int32_double.empty());
-  EXPECT_FALSE(mf_string_string.empty());
-  EXPECT_FALSE(mmf_string_string.empty());
-  EXPECT_FALSE(mf_int32_foreign_message.empty());
-  EXPECT_FALSE(mmf_int32_foreign_message.empty());
-
-  // Make sure we can do gets through the RepeatedFieldRef objects.
-  for (int i = 0; i < 10; ++i) {
-    {
-      // Check gets through const objects.
-      const Message& message_int32_int32 =
-          mf_int32_int32.Get(i, entry_int32_int32.get());
-      int32 key_int32_int32 = message_int32_int32.GetReflection()->GetInt32(
-          message_int32_int32, fd_map_int32_in32_key);
-      int32 value_int32_int32 = message_int32_int32.GetReflection()->GetInt32(
-          message_int32_int32, fd_map_int32_in32_value);
-      EXPECT_EQ(value_int32_int32, Func(key_int32_int32, 1));
-
-      const Message& message_int32_double =
-          mf_int32_double.Get(i, entry_int32_double.get());
-      int32 key_int32_double = message_int32_double.GetReflection()->GetInt32(
-          message_int32_double, fd_map_int32_double_key);
-      double value_int32_double =
-          message_int32_double.GetReflection()->GetDouble(
-              message_int32_double, fd_map_int32_double_value);
-      EXPECT_EQ(value_int32_double, Func(key_int32_double, 2));
-
-      const Message& message_string_string =
-          mf_string_string.Get(i, entry_string_string.get());
-      std::string key_string_string =
-          message_string_string.GetReflection()->GetString(
-              message_string_string, fd_map_string_string_key);
-      std::string value_string_string =
-          message_string_string.GetReflection()->GetString(
-              message_string_string, fd_map_string_string_value);
-      EXPECT_EQ(value_string_string, StrFunc(Int(key_string_string), 5));
-
-      const Message& message_int32_message =
-          mf_int32_foreign_message.Get(i, entry_int32_foreign_message.get());
-      int32 key_int32_message = message_int32_message.GetReflection()->GetInt32(
-          message_int32_message, fd_map_int32_foreign_message_key);
-      const ForeignMessage& value_int32_message =
-          down_cast<const ForeignMessage&>(
-              message_int32_message.GetReflection()->GetMessage(
-                  message_int32_message, fd_map_int32_foreign_message_value));
-      EXPECT_EQ(value_int32_message.c(), Func(key_int32_message, 6));
-    }
-
-    {
-      // Check gets through mutable objects.
-      const Message& message_int32_int32 =
-          mmf_int32_int32.Get(i, entry_int32_int32.get());
-      int32 key_int32_int32 = message_int32_int32.GetReflection()->GetInt32(
-          message_int32_int32, fd_map_int32_in32_key);
-      int32 value_int32_int32 = message_int32_int32.GetReflection()->GetInt32(
-          message_int32_int32, fd_map_int32_in32_value);
-      EXPECT_EQ(value_int32_int32, Func(key_int32_int32, 1));
-
-      const Message& message_int32_double =
-          mmf_int32_double.Get(i, entry_int32_double.get());
-      int32 key_int32_double = message_int32_double.GetReflection()->GetInt32(
-          message_int32_double, fd_map_int32_double_key);
-      double value_int32_double =
-          message_int32_double.GetReflection()->GetDouble(
-              message_int32_double, fd_map_int32_double_value);
-      EXPECT_EQ(value_int32_double, Func(key_int32_double, 2));
-
-      const Message& message_string_string =
-          mmf_string_string.Get(i, entry_string_string.get());
-      std::string key_string_string =
-          message_string_string.GetReflection()->GetString(
-              message_string_string, fd_map_string_string_key);
-      std::string value_string_string =
-          message_string_string.GetReflection()->GetString(
-              message_string_string, fd_map_string_string_value);
-      EXPECT_EQ(value_string_string, StrFunc(Int(key_string_string), 5));
-
-      const Message& message_int32_message =
-          mmf_int32_foreign_message.Get(i, entry_int32_foreign_message.get());
-      int32 key_int32_message = message_int32_message.GetReflection()->GetInt32(
-          message_int32_message, fd_map_int32_foreign_message_key);
-      const ForeignMessage& value_int32_message =
-          down_cast<const ForeignMessage&>(
-              message_int32_message.GetReflection()->GetMessage(
-                  message_int32_message, fd_map_int32_foreign_message_value));
-      EXPECT_EQ(value_int32_message.c(), Func(key_int32_message, 6));
-    }
-  }
-
-  // Make sure we can do sets through the RepeatedFieldRef objects.
-  for (int i = 0; i < 10; i++) {
-    const Message& message_int32_int32 =
-        mmf_int32_int32.Get(i, entry_int32_int32.get());
-    int key = message_int32_int32.GetReflection()->GetInt32(
-        message_int32_int32, fd_map_int32_in32_key);
-
-    entry_int32_int32->GetReflection()->SetInt32(
-        entry_int32_int32.get(), fd_map_int32_int32->message_type()->field(0),
-        key);
-    entry_int32_int32->GetReflection()->SetInt32(
-        entry_int32_int32.get(), fd_map_int32_int32->message_type()->field(1),
-        Func(key, -1));
-    entry_int32_double->GetReflection()->SetInt32(
-        entry_int32_double.get(), fd_map_int32_double->message_type()->field(0),
-        key);
-    entry_int32_double->GetReflection()->SetDouble(
-        entry_int32_double.get(), fd_map_int32_double->message_type()->field(1),
-        Func(key, -2));
-    entry_string_string->GetReflection()->SetString(
-        entry_string_string.get(),
-        fd_map_string_string->message_type()->field(0), StrFunc(key, 1));
-    entry_string_string->GetReflection()->SetString(
-        entry_string_string.get(),
-        fd_map_string_string->message_type()->field(1), StrFunc(key, -5));
-    entry_int32_foreign_message->GetReflection()->SetInt32(
-        entry_int32_foreign_message.get(),
-        fd_map_int32_foreign_message->message_type()->field(0), key);
-    Message* value_message =
-        entry_int32_foreign_message->GetReflection()->MutableMessage(
-            entry_int32_foreign_message.get(),
-            fd_map_int32_foreign_message->message_type()->field(1));
-    value_message->GetReflection()->SetInt32(
-        value_message, value_message->GetDescriptor()->FindFieldByName("c"),
-        Func(key, -6));
-
-    mmf_int32_int32.Set(i, *entry_int32_int32);
-    mmf_int32_double.Set(i, *entry_int32_double);
-    mmf_string_string.Set(i, *entry_string_string);
-    mmf_int32_foreign_message.Set(i, *entry_int32_foreign_message);
-  }
-
-  for (int i = 0; i < 10; i++) {
-    EXPECT_EQ(Func(i, -1), message.map_int32_int32().at(i));
-    EXPECT_EQ(Func(i, -2), message.map_int32_double().at(i));
-    EXPECT_EQ(StrFunc(i, -5), message.map_string_string().at(StrFunc(i, 1)));
-    EXPECT_EQ(Func(i, -6), message.map_int32_foreign_message().at(i).c());
-  }
-
-  // Test iterators.
-  {
-    int index = 0;
-    std::unordered_map<int32, int32> result;
-    for (RepeatedFieldRef<Message>::iterator it = mf_int32_int32.begin();
-         it != mf_int32_int32.end(); ++it) {
-      const Message& message = *it;
-      int32 key =
-          message.GetReflection()->GetInt32(message, fd_map_int32_in32_key);
-      int32 value =
-          message.GetReflection()->GetInt32(message, fd_map_int32_in32_value);
-      result[key] = value;
-      ++index;
-    }
-    EXPECT_EQ(10, index);
-    for (std::unordered_map<int32, int32>::const_iterator it = result.begin();
-         it != result.end(); ++it) {
-      EXPECT_EQ(message.map_int32_int32().at(it->first), it->second);
-    }
-  }
-
-  {
-    int index = 0;
-    std::unordered_map<int32, double> result;
-    for (RepeatedFieldRef<Message>::iterator it = mf_int32_double.begin();
-         it != mf_int32_double.end(); ++it) {
-      const Message& message = *it;
-      int32 key =
-          message.GetReflection()->GetInt32(message, fd_map_int32_double_key);
-      double value = message.GetReflection()->GetDouble(
-          message, fd_map_int32_double_value);
-      result[key] = value;
-      ++index;
-    }
-    EXPECT_EQ(10, index);
-    for (std::unordered_map<int32, double>::const_iterator it = result.begin();
-         it != result.end(); ++it) {
-      EXPECT_EQ(message.map_int32_double().at(it->first), it->second);
-    }
-  }
-
-  {
-    int index = 0;
-    std::unordered_map<std::string, std::string> result;
-    for (RepeatedFieldRef<Message>::iterator it = mf_string_string.begin();
-         it != mf_string_string.end(); ++it) {
-      const Message& message = *it;
-      std::string key =
-          message.GetReflection()->GetString(message, fd_map_string_string_key);
-      std::string value = message.GetReflection()->GetString(
-          message, fd_map_string_string_value);
-      result[key] = value;
-      ++index;
-    }
-    EXPECT_EQ(10, index);
-    for (std::unordered_map<std::string, std::string>::const_iterator it =
-             result.begin();
-         it != result.end(); ++it) {
-      EXPECT_EQ(message.map_string_string().at(it->first), it->second);
-    }
-  }
-
-  {
-    int index = 0;
-    std::map<int32, ForeignMessage> result;
-    for (RepeatedFieldRef<Message>::iterator it =
-             mf_int32_foreign_message.begin();
-         it != mf_int32_foreign_message.end(); ++it) {
-      const Message& message = *it;
-      int32 key = message.GetReflection()->GetInt32(
-          message, fd_map_int32_foreign_message_key);
-      const ForeignMessage& sub_message =
-          down_cast<const ForeignMessage&>(message.GetReflection()->GetMessage(
-              message, fd_map_int32_foreign_message_value));
-      result[key].MergeFrom(sub_message);
-      ++index;
-    }
-    EXPECT_EQ(10, index);
-    for (std::map<int32, ForeignMessage>::const_iterator it = result.begin();
-         it != result.end(); ++it) {
-      EXPECT_EQ(message.map_int32_foreign_message().at(it->first).c(),
-                it->second.c());
-    }
-  }
-
-  // Test MutableRepeatedFieldRef::Add()
-  entry_int32_int32->GetReflection()->SetInt32(
-      entry_int32_int32.get(), fd_map_int32_int32->message_type()->field(0),
-      4321);
-  entry_int32_int32->GetReflection()->SetInt32(
-      entry_int32_int32.get(), fd_map_int32_int32->message_type()->field(1),
-      1234);
-  mmf_int32_int32.Add(*entry_int32_int32);
-  EXPECT_EQ(1234, message.map_int32_int32().at(4321));
-
-  entry_int32_double->GetReflection()->SetInt32(
-      entry_int32_double.get(), fd_map_int32_double->message_type()->field(0),
-      4321);
-  entry_int32_double->GetReflection()->SetDouble(
-      entry_int32_double.get(), fd_map_int32_double->message_type()->field(1),
-      1234.0);
-  mmf_int32_double.Add(*entry_int32_double);
-  EXPECT_EQ(1234.0, message.map_int32_double().at(4321));
-
-  entry_string_string->GetReflection()->SetString(
-      entry_string_string.get(), fd_map_string_string->message_type()->field(0),
-      "4321");
-  entry_string_string->GetReflection()->SetString(
-      entry_string_string.get(), fd_map_string_string->message_type()->field(1),
-      "1234");
-  mmf_string_string.Add(*entry_string_string);
-  EXPECT_EQ("1234", message.map_string_string().at("4321"));
-
-  entry_int32_foreign_message->GetReflection()->SetInt32(
-      entry_int32_foreign_message.get(),
-      fd_map_int32_foreign_message->message_type()->field(0), 4321);
-  Message* value_message =
-      entry_int32_foreign_message->GetReflection()->MutableMessage(
-          entry_int32_foreign_message.get(),
-          fd_map_int32_foreign_message->message_type()->field(1));
-  ForeignMessage foreign_message;
-  foreign_message.set_c(1234);
-  value_message->CopyFrom(foreign_message);
-
-  mmf_int32_foreign_message.Add(*entry_int32_foreign_message);
-  EXPECT_EQ(1234, message.map_int32_foreign_message().at(4321).c());
-
-  // Test Reflection::AddAllocatedMessage
-  Message* free_entry_string_string =
-      MessageFactory::generated_factory()
-          ->GetPrototype(fd_map_string_string->message_type())
-          ->New();
-  entry_string_string->GetReflection()->SetString(
-      free_entry_string_string, fd_map_string_string->message_type()->field(0),
-      "4321");
-  entry_string_string->GetReflection()->SetString(
-      free_entry_string_string, fd_map_string_string->message_type()->field(1),
-      "1234");
-  refl->AddAllocatedMessage(&message, fd_map_string_string,
-                            free_entry_string_string);
-
-  // Test MutableRepeatedFieldRef::RemoveLast()
-  mmf_int32_int32.RemoveLast();
-  mmf_int32_double.RemoveLast();
-  mmf_string_string.RemoveLast();
-  mmf_int32_foreign_message.RemoveLast();
-  EXPECT_EQ(10, message.map_int32_int32().size());
-  EXPECT_EQ(10, message.map_int32_double().size());
-  EXPECT_EQ(11, message.map_string_string().size());
-  EXPECT_EQ(10, message.map_int32_foreign_message().size());
-
-  // Test MutableRepeatedFieldRef::SwapElements()
-  {
-    const Message& message0a = mmf_int32_int32.Get(0, entry_int32_int32.get());
-    int32 int32_value0a =
-        message0a.GetReflection()->GetInt32(message0a, fd_map_int32_in32_value);
-    const Message& message9a = mmf_int32_int32.Get(9, entry_int32_int32.get());
-    int32 int32_value9a =
-        message9a.GetReflection()->GetInt32(message9a, fd_map_int32_in32_value);
-
-    mmf_int32_int32.SwapElements(0, 9);
-
-    const Message& message0b = mmf_int32_int32.Get(0, entry_int32_int32.get());
-    int32 int32_value0b =
-        message0b.GetReflection()->GetInt32(message0b, fd_map_int32_in32_value);
-    const Message& message9b = mmf_int32_int32.Get(9, entry_int32_int32.get());
-    int32 int32_value9b =
-        message9b.GetReflection()->GetInt32(message9b, fd_map_int32_in32_value);
-
-    EXPECT_EQ(int32_value9a, int32_value0b);
-    EXPECT_EQ(int32_value0a, int32_value9b);
-  }
-
-  {
-    const Message& message0a =
-        mmf_int32_double.Get(0, entry_int32_double.get());
-    double double_value0a = message0a.GetReflection()->GetDouble(
-        message0a, fd_map_int32_double_value);
-    const Message& message9a =
-        mmf_int32_double.Get(9, entry_int32_double.get());
-    double double_value9a = message9a.GetReflection()->GetDouble(
-        message9a, fd_map_int32_double_value);
-
-    mmf_int32_double.SwapElements(0, 9);
-
-    const Message& message0b =
-        mmf_int32_double.Get(0, entry_int32_double.get());
-    double double_value0b = message0b.GetReflection()->GetDouble(
-        message0b, fd_map_int32_double_value);
-    const Message& message9b =
-        mmf_int32_double.Get(9, entry_int32_double.get());
-    double double_value9b = message9b.GetReflection()->GetDouble(
-        message9b, fd_map_int32_double_value);
-
-    EXPECT_EQ(double_value9a, double_value0b);
-    EXPECT_EQ(double_value0a, double_value9b);
-  }
-
-  {
-    const Message& message0a =
-        mmf_string_string.Get(0, entry_string_string.get());
-    std::string string_value0a = message0a.GetReflection()->GetString(
-        message0a, fd_map_string_string_value);
-    const Message& message9a =
-        mmf_string_string.Get(9, entry_string_string.get());
-    std::string string_value9a = message9a.GetReflection()->GetString(
-        message9a, fd_map_string_string_value);
-
-    mmf_string_string.SwapElements(0, 9);
-
-    const Message& message0b =
-        mmf_string_string.Get(0, entry_string_string.get());
-    std::string string_value0b = message0b.GetReflection()->GetString(
-        message0b, fd_map_string_string_value);
-    const Message& message9b =
-        mmf_string_string.Get(9, entry_string_string.get());
-    std::string string_value9b = message9b.GetReflection()->GetString(
-        message9b, fd_map_string_string_value);
-
-    EXPECT_EQ(string_value9a, string_value0b);
-    EXPECT_EQ(string_value0a, string_value9b);
-  }
-
-  {
-    const Message& message0a =
-        mmf_int32_foreign_message.Get(0, entry_int32_foreign_message.get());
-    const ForeignMessage& sub_message0a =
-        down_cast<const ForeignMessage&>(message0a.GetReflection()->GetMessage(
-            message0a, fd_map_int32_foreign_message_value));
-    int32 int32_value0a = sub_message0a.c();
-    const Message& message9a =
-        mmf_int32_foreign_message.Get(9, entry_int32_foreign_message.get());
-    const ForeignMessage& sub_message9a =
-        down_cast<const ForeignMessage&>(message9a.GetReflection()->GetMessage(
-            message9a, fd_map_int32_foreign_message_value));
-    int32 int32_value9a = sub_message9a.c();
-
-    mmf_int32_foreign_message.SwapElements(0, 9);
-
-    const Message& message0b =
-        mmf_int32_foreign_message.Get(0, entry_int32_foreign_message.get());
-    const ForeignMessage& sub_message0b =
-        down_cast<const ForeignMessage&>(message0b.GetReflection()->GetMessage(
-            message0b, fd_map_int32_foreign_message_value));
-    int32 int32_value0b = sub_message0b.c();
-    const Message& message9b =
-        mmf_int32_foreign_message.Get(9, entry_int32_foreign_message.get());
-    const ForeignMessage& sub_message9b =
-        down_cast<const ForeignMessage&>(message9b.GetReflection()->GetMessage(
-            message9b, fd_map_int32_foreign_message_value));
-    int32 int32_value9b = sub_message9b.c();
-
-    EXPECT_EQ(int32_value9a, int32_value0b);
-    EXPECT_EQ(int32_value0a, int32_value9b);
-  }
-
-  // TODO(b/181148674): After supporting arena agnostic delete or let map entry
-  // handle heap allocation, this could be removed.
-  if (message.GetArena() != nullptr) {
-    entry_int32_int32.release();
-    entry_int32_double.release();
-    entry_string_string.release();
-    entry_int32_foreign_message.release();
-  }
-}
-
-TEST_F(MapFieldReflectionTest, RepeatedFieldRefMergeFromAndSwap) {
-  // Set-up message content.
-  TestMap m0, m1, m2;
-  for (int i = 0; i < 10; ++i) {
-    (*m0.mutable_map_int32_int32())[i] = Func(i, 1);
-    (*m0.mutable_map_int32_double())[i] = Func(i, 2);
-    (*m0.mutable_map_string_string())[StrFunc(i, 1)] = StrFunc(i, 5);
-    (*m0.mutable_map_int32_foreign_message())[i].set_c(Func(i, 6));
-    (*m1.mutable_map_int32_int32())[i + 10] = Func(i, 11);
-    (*m1.mutable_map_int32_double())[i + 10] = Func(i, 12);
-    (*m1.mutable_map_string_string())[StrFunc(i + 10, 1)] = StrFunc(i, 15);
-    (*m1.mutable_map_int32_foreign_message())[i + 10].set_c(Func(i, 16));
-    (*m2.mutable_map_int32_int32())[i + 20] = Func(i, 21);
-    (*m2.mutable_map_int32_double())[i + 20] = Func(i, 22);
-    (*m2.mutable_map_string_string())[StrFunc(i + 20, 1)] = StrFunc(i, 25);
-    (*m2.mutable_map_int32_foreign_message())[i + 20].set_c(Func(i, 26));
-  }
-
-  const Reflection* refl = m0.GetReflection();
-  const Descriptor* desc = m0.GetDescriptor();
-
-  // Get FieldDescriptors for all the fields of interest.
-  const FieldDescriptor* fd_map_int32_int32 =
-      desc->FindFieldByName("map_int32_int32");
-  const FieldDescriptor* fd_map_int32_double =
-      desc->FindFieldByName("map_int32_double");
-  const FieldDescriptor* fd_map_string_string =
-      desc->FindFieldByName("map_string_string");
-  const FieldDescriptor* fd_map_int32_foreign_message =
-      desc->FindFieldByName("map_int32_foreign_message");
-
-  // Get MutableRepeatedFieldRef objects for all fields of interest.
-  const MutableRepeatedFieldRef<Message> mmf_int32_int32 =
-      refl->GetMutableRepeatedFieldRef<Message>(&m0, fd_map_int32_int32);
-  const MutableRepeatedFieldRef<Message> mmf_int32_double =
-      refl->GetMutableRepeatedFieldRef<Message>(&m0, fd_map_int32_double);
-  const MutableRepeatedFieldRef<Message> mmf_string_string =
-      refl->GetMutableRepeatedFieldRef<Message>(&m0, fd_map_string_string);
-  const MutableRepeatedFieldRef<Message> mmf_int32_foreign_message =
-      refl->GetMutableRepeatedFieldRef<Message>(&m0,
-                                                fd_map_int32_foreign_message);
-
-  // Test MutableRepeatedRef::CopyFrom
-  mmf_int32_int32.CopyFrom(
-      refl->GetRepeatedFieldRef<Message>(m1, fd_map_int32_int32));
-  mmf_int32_double.CopyFrom(
-      refl->GetRepeatedFieldRef<Message>(m1, fd_map_int32_double));
-  mmf_string_string.CopyFrom(
-      refl->GetRepeatedFieldRef<Message>(m1, fd_map_string_string));
-  mmf_int32_foreign_message.CopyFrom(
-      refl->GetRepeatedFieldRef<Message>(m1, fd_map_int32_foreign_message));
-
-  for (int i = 0; i < 10; ++i) {
-    EXPECT_EQ(Func(i, 11), m0.map_int32_int32().at(i + 10));
-    EXPECT_EQ(Func(i, 12), m0.map_int32_double().at(i + 10));
-    EXPECT_EQ(StrFunc(i, 15), m0.map_string_string().at(StrFunc(i + 10, 1)));
-    EXPECT_EQ(Func(i, 16), m0.map_int32_foreign_message().at(i + 10).c());
-  }
-
-  // Test MutableRepeatedRef::MergeFrom
-  mmf_int32_int32.MergeFrom(
-      refl->GetRepeatedFieldRef<Message>(m2, fd_map_int32_int32));
-  mmf_int32_double.MergeFrom(
-      refl->GetRepeatedFieldRef<Message>(m2, fd_map_int32_double));
-  mmf_string_string.MergeFrom(
-      refl->GetRepeatedFieldRef<Message>(m2, fd_map_string_string));
-  mmf_int32_foreign_message.MergeFrom(
-      refl->GetRepeatedFieldRef<Message>(m2, fd_map_int32_foreign_message));
-  for (int i = 0; i < 10; ++i) {
-    EXPECT_EQ(Func(i, 21), m0.map_int32_int32().at(i + 20));
-    EXPECT_EQ(Func(i, 22), m0.map_int32_double().at(i + 20));
-    EXPECT_EQ(StrFunc(i, 25), m0.map_string_string().at(StrFunc(i + 20, 1)));
-    EXPECT_EQ(Func(i, 26), m0.map_int32_foreign_message().at(i + 20).c());
-  }
-
-  // Test MutableRepeatedRef::Swap
-  // Swap between m0 and m2.
-  mmf_int32_int32.Swap(
-      refl->GetMutableRepeatedFieldRef<Message>(&m2, fd_map_int32_int32));
-  mmf_int32_double.Swap(
-      refl->GetMutableRepeatedFieldRef<Message>(&m2, fd_map_int32_double));
-  mmf_string_string.Swap(
-      refl->GetMutableRepeatedFieldRef<Message>(&m2, fd_map_string_string));
-  mmf_int32_foreign_message.Swap(refl->GetMutableRepeatedFieldRef<Message>(
-      &m2, fd_map_int32_foreign_message));
-  for (int i = 0; i < 10; ++i) {
-    // Check the content of m0.
-    EXPECT_EQ(Func(i, 21), m0.map_int32_int32().at(i + 20));
-    EXPECT_EQ(Func(i, 22), m0.map_int32_double().at(i + 20));
-    EXPECT_EQ(StrFunc(i, 25), m0.map_string_string().at(StrFunc(i + 20, 1)));
-    EXPECT_EQ(Func(i, 26), m0.map_int32_foreign_message().at(i + 20).c());
-
-    // Check the content of m2.
-    EXPECT_EQ(Func(i, 11), m2.map_int32_int32().at(i + 10));
-    EXPECT_EQ(Func(i, 12), m2.map_int32_double().at(i + 10));
-    EXPECT_EQ(StrFunc(i, 15), m2.map_string_string().at(StrFunc(i + 10, 1)));
-    EXPECT_EQ(Func(i, 16), m2.map_int32_foreign_message().at(i + 10).c());
-    EXPECT_EQ(Func(i, 21), m2.map_int32_int32().at(i + 20));
-    EXPECT_EQ(Func(i, 22), m2.map_int32_double().at(i + 20));
-    EXPECT_EQ(StrFunc(i, 25), m2.map_string_string().at(StrFunc(i + 20, 1)));
-    EXPECT_EQ(Func(i, 26), m2.map_int32_foreign_message().at(i + 20).c());
-  }
-
-  // TODO(teboring): add test for duplicated key
-}
-
-TEST_F(MapFieldReflectionTest, MapSizeWithDuplicatedKey) {
-  // Dynamic Message
-  {
-    DynamicMessageFactory factory;
-    std::unique_ptr<Message> message(
-        factory.GetPrototype(unittest::TestMap::descriptor())->New());
-    const Reflection* reflection = message->GetReflection();
-    const FieldDescriptor* field =
-        unittest::TestMap::descriptor()->FindFieldByName("map_int32_int32");
-
-    Message* entry1 = reflection->AddMessage(message.get(), field);
-    Message* entry2 = reflection->AddMessage(message.get(), field);
-
-    const Reflection* entry_reflection = entry1->GetReflection();
-    const FieldDescriptor* key_field =
-        entry1->GetDescriptor()->FindFieldByName("key");
-    entry_reflection->SetInt32(entry1, key_field, 1);
-    entry_reflection->SetInt32(entry2, key_field, 1);
-
-    EXPECT_EQ(2, reflection->FieldSize(*message, field));
-    EXPECT_EQ(1, MapSize(reflection, field, *message));
-    EXPECT_EQ(2, reflection->FieldSize(*message, field));
-  }
-
-  // Generated Message
-  {
-    unittest::TestMap message;
-    const Reflection* reflection = message.GetReflection();
-    const FieldDescriptor* field =
-        message.GetDescriptor()->FindFieldByName("map_int32_int32");
-
-    Message* entry1 = reflection->AddMessage(&message, field);
-    Message* entry2 = reflection->AddMessage(&message, field);
-
-    const Reflection* entry_reflection = entry1->GetReflection();
-    const FieldDescriptor* key_field =
-        entry1->GetDescriptor()->FindFieldByName("key");
-    entry_reflection->SetInt32(entry1, key_field, 1);
-    entry_reflection->SetInt32(entry2, key_field, 1);
-
-    EXPECT_EQ(2, reflection->FieldSize(message, field));
-    EXPECT_EQ(1, MapSize(reflection, field, message));
-  }
-}
-
-TEST_F(MapFieldReflectionTest, UninitializedEntry) {
-  unittest::TestRequiredMessageMap message;
-  const Reflection* reflection = message.GetReflection();
-  const FieldDescriptor* field =
-      message.GetDescriptor()->FindFieldByName("map_field");
-  auto entry = reflection->AddMessage(&message, field);
-  EXPECT_FALSE(entry->IsInitialized());
-  EXPECT_FALSE(message.IsInitialized());
-}
-
-class MyMapEntry
-    : public internal::MapEntry<MyMapEntry, ::google::protobuf::int32, ::google::protobuf::int32,
-                                internal::WireFormatLite::TYPE_INT32,
-                                internal::WireFormatLite::TYPE_INT32> {
- public:
-  constexpr MyMapEntry() {}
-  MyMapEntry(Arena*) { std::abort(); }
-  Metadata GetMetadata() const override { std::abort(); }
-  static bool ValidateKey(void*) { return true; }
-  static bool ValidateValue(void*) { return true; }
-};
-
-class MyMapEntryLite
-    : public internal::MapEntryLite<MyMapEntryLite, ::google::protobuf::int32, ::google::protobuf::int32,
-                                    internal::WireFormatLite::TYPE_INT32,
-                                    internal::WireFormatLite::TYPE_INT32> {
- public:
-  constexpr MyMapEntryLite() {}
-  explicit MyMapEntryLite(Arena*) { std::abort(); }
-  static bool ValidateKey(void*) { return true; }
-  static bool ValidateValue(void*) { return true; }
-};
-
-TEST(MapEntryTest, ConstInit) {
-  // This verifies that `MapEntry`, `MapEntryLite` and `MapEntryImpl` can be
-  // constant initialized.
-  PROTOBUF_CONSTINIT static MyMapEntry entry{};
-  EXPECT_NE(entry.SpaceUsed(), 0);
-
-  PROTOBUF_CONSTINIT static MyMapEntryLite entry_lite{};  // NOLINT
-  EXPECT_TRUE(entry_lite.IsInitialized());
-}
-
-// Generated Message Test ===========================================
-
-TEST(GeneratedMapFieldTest, Accessors) {
-  unittest::TestMap message;
-
-  MapTestUtil::SetMapFields(&message);
-  MapTestUtil::ExpectMapFieldsSet(message);
-
-  MapTestUtil::ModifyMapFields(&message);
-  MapTestUtil::ExpectMapFieldsModified(message);
-}
-
-TEST(GeneratedMapFieldTest, SetMapFieldsInitialized) {
-  unittest::TestMap message;
-
-  MapTestUtil::SetMapFieldsInitialized(&message);
-  MapTestUtil::ExpectMapFieldsSetInitialized(message);
-}
-
-TEST(GeneratedMapFieldTest, Proto2SetMapFieldsInitialized) {
-  unittest::TestEnumMap message;
-  EXPECT_EQ(unittest::PROTO2_MAP_ENUM_FOO,
-            (*message.mutable_known_map_field())[0]);
-}
-
-TEST(GeneratedMapFieldTest, Clear) {
-  unittest::TestMap message;
-
-  MapTestUtil::SetMapFields(&message);
-  message.Clear();
-  MapTestUtil::ExpectClear(message);
-}
-
-TEST(GeneratedMapFieldTest, ClearMessageMap) {
-  unittest::TestMessageMap message;
-
-  // Creates a TestAllTypes with default value
-  TestUtil::ExpectClear((*message.mutable_map_int32_message())[0]);
-}
-
-TEST(GeneratedMapFieldTest, CopyFrom) {
-  unittest::TestMap message1, message2;
-
-  MapTestUtil::SetMapFields(&message1);
-  message2.CopyFrom(message1);
-  MapTestUtil::ExpectMapFieldsSet(message2);
-
-  // Copying from self should be a no-op.
-  message2.CopyFrom(message2);
-  MapTestUtil::ExpectMapFieldsSet(message2);
-}
-
-TEST(GeneratedMapFieldTest, CopyFromMessageMap) {
-  unittest::TestMessageMap message1, message2;
-
-  (*message1.mutable_map_int32_message())[0].add_repeated_int32(100);
-  (*message2.mutable_map_int32_message())[0].add_repeated_int32(101);
-
-  message1.CopyFrom(message2);
-
-  // Checks repeated field is overwritten.
-  EXPECT_EQ(1, message1.map_int32_message().at(0).repeated_int32_size());
-  EXPECT_EQ(101, message1.map_int32_message().at(0).repeated_int32(0));
-}
-
-TEST(GeneratedMapFieldTest, SwapWithEmpty) {
-  unittest::TestMap message1, message2;
-
-  MapTestUtil::SetMapFields(&message1);
-  MapTestUtil::ExpectMapFieldsSet(message1);
-  MapTestUtil::ExpectClear(message2);
-
-  message1.Swap(&message2);
-  MapTestUtil::ExpectMapFieldsSet(message2);
-  MapTestUtil::ExpectClear(message1);
-}
-
-TEST(GeneratedMapFieldTest, SwapWithSelf) {
-  unittest::TestMap message;
-
-  MapTestUtil::SetMapFields(&message);
-  MapTestUtil::ExpectMapFieldsSet(message);
-
-  message.Swap(&message);
-  MapTestUtil::ExpectMapFieldsSet(message);
-}
-
-TEST(GeneratedMapFieldTest, SwapWithOther) {
-  unittest::TestMap message1, message2;
-
-  MapTestUtil::SetMapFields(&message1);
-  MapTestUtil::SetMapFields(&message2);
-  MapTestUtil::ModifyMapFields(&message2);
-
-  message1.Swap(&message2);
-  MapTestUtil::ExpectMapFieldsModified(message1);
-  MapTestUtil::ExpectMapFieldsSet(message2);
-}
-
-TEST(GeneratedMapFieldTest, CopyConstructor) {
-  unittest::TestMap message1;
-  MapTestUtil::SetMapFields(&message1);
-
-  unittest::TestMap message2(message1);
-  MapTestUtil::ExpectMapFieldsSet(message2);
-}
-
-TEST(GeneratedMapFieldTest, CopyAssignmentOperator) {
-  unittest::TestMap message1;
-  MapTestUtil::SetMapFields(&message1);
-
-  unittest::TestMap message2;
-  message2 = message1;
-  MapTestUtil::ExpectMapFieldsSet(message2);
-
-  // Make sure that self-assignment does something sane.
-  message2.operator=(message2);
-  MapTestUtil::ExpectMapFieldsSet(message2);
-}
-
-#if !defined(PROTOBUF_TEST_NO_DESCRIPTORS) || PROTOBUF_RTTI
-TEST(GeneratedMapFieldTest, UpcastCopyFrom) {
-  // Test the CopyFrom method that takes in the generic const Message&
-  // parameter.
-  unittest::TestMap message1, message2;
-
-  MapTestUtil::SetMapFields(&message1);
-
-  const Message* source = implicit_cast<const Message*>(&message1);
-  message2.CopyFrom(*source);
-
-  MapTestUtil::ExpectMapFieldsSet(message2);
-}
-#endif
-
-#ifndef PROTOBUF_TEST_NO_DESCRIPTORS
-
-TEST(GeneratedMapFieldTest, CopyFromDynamicMessage) {
-  // Test copying from a DynamicMessage, which must fall back to using
-  // reflection.
-  unittest::TestMap message2;
-
-  // Construct a new version of the dynamic message via the factory.
-  DynamicMessageFactory factory;
-  std::unique_ptr<Message> message1;
-  message1.reset(factory.GetPrototype(unittest::TestMap::descriptor())->New());
-  MapReflectionTester reflection_tester(unittest::TestMap::descriptor());
-  reflection_tester.SetMapFieldsViaReflection(message1.get());
-  reflection_tester.ExpectMapFieldsSetViaReflection(*message1);
-  reflection_tester.ExpectMapFieldsSetViaReflectionIterator(message1.get());
-  message2.CopyFrom(*message1);
-  MapTestUtil::ExpectMapFieldsSet(message2);
-}
-
-TEST(GeneratedMapFieldTest, CopyFromDynamicMessageMapReflection) {
-  unittest::TestMap message2;
-
-  // Construct a new version of the dynamic message via the factory.
-  DynamicMessageFactory factory;
-  std::unique_ptr<Message> message1;
-  message1.reset(factory.GetPrototype(unittest::TestMap::descriptor())->New());
-  MapReflectionTester reflection_tester(unittest::TestMap::descriptor());
-  reflection_tester.SetMapFieldsViaMapReflection(message1.get());
-  reflection_tester.ExpectMapFieldsSetViaReflection(*message1);
-  reflection_tester.ExpectMapFieldsSetViaReflectionIterator(message1.get());
-  message2.CopyFrom(*message1);
-  MapTestUtil::ExpectMapFieldsSet(message2);
-}
-
-TEST(GeneratedMapFieldTest, DynamicMessageMergeFromDynamicMessage) {
-  // Construct two dynamic message and sets via map reflection.
-  DynamicMessageFactory factory;
-  std::unique_ptr<Message> message1;
-  message1.reset(factory.GetPrototype(unittest::TestMap::descriptor())->New());
-  MapReflectionTester reflection_tester(unittest::TestMap::descriptor());
-  reflection_tester.SetMapFieldsViaMapReflection(message1.get());
-
-  // message2 is created by same factory.
-  std::unique_ptr<Message> message2;
-  message2.reset(factory.GetPrototype(unittest::TestMap::descriptor())->New());
-  reflection_tester.SetMapFieldsViaMapReflection(message2.get());
-
-  // message3 is created by different factory.
-  DynamicMessageFactory factory3;
-  std::unique_ptr<Message> message3;
-  message3.reset(factory3.GetPrototype(unittest::TestMap::descriptor())->New());
-  reflection_tester.SetMapFieldsViaMapReflection(message3.get());
-
-  message2->MergeFrom(*message1);
-  message3->MergeFrom(*message1);
-
-  // Test MergeFrom does not sync to repeated fields and
-  // there is no duplicate keys in text format.
-  std::string output1, output2, output3;
-  TextFormat::PrintToString(*message1, &output1);
-  TextFormat::PrintToString(*message2, &output2);
-  TextFormat::PrintToString(*message3, &output3);
-  EXPECT_EQ(output1, output2);
-  EXPECT_EQ(output1, output3);
-}
-
-TEST(GeneratedMapFieldTest, DynamicMessageCopyFrom) {
-  // Test copying to a DynamicMessage, which must fall back to using reflection.
-  unittest::TestMap message2;
-  MapTestUtil::SetMapFields(&message2);
-
-  // Construct a new version of the dynamic message via the factory.
-  DynamicMessageFactory factory;
-  std::unique_ptr<Message> message1;
-  message1.reset(factory.GetPrototype(unittest::TestMap::descriptor())->New());
-
-  MapReflectionTester reflection_tester(unittest::TestMap::descriptor());
-  message1->MergeFrom(message2);
-  reflection_tester.ExpectMapFieldsSetViaReflection(*message1);
-  reflection_tester.ExpectMapFieldsSetViaReflectionIterator(message1.get());
-}
-
-TEST(GeneratedMapFieldTest, DynamicMessageCopyFromMapReflection) {
-  MapReflectionTester reflection_tester(unittest::TestMap::descriptor());
-  unittest::TestMap message2;
-  reflection_tester.SetMapFieldsViaMapReflection(&message2);
-
-  // Construct a dynamic message via the factory.
-  DynamicMessageFactory factory;
-  std::unique_ptr<Message> message1;
-  message1.reset(factory.GetPrototype(unittest::TestMap::descriptor())->New());
-
-  message1->MergeFrom(message2);
-  reflection_tester.ExpectMapFieldsSetViaReflectionIterator(message1.get());
-  reflection_tester.ExpectMapFieldsSetViaReflection(*message1);
-}
-
-TEST(GeneratedMapFieldTest, SyncDynamicMapWithRepeatedField) {
-  // Construct a dynamic message via the factory.
-  MapReflectionTester reflection_tester(unittest::TestMap::descriptor());
-  DynamicMessageFactory factory;
-  std::unique_ptr<Message> message;
-  message.reset(factory.GetPrototype(unittest::TestMap::descriptor())->New());
-  reflection_tester.SetMapFieldsViaReflection(message.get());
-  reflection_tester.ExpectMapFieldsSetViaReflectionIterator(message.get());
-  reflection_tester.ExpectMapFieldsSetViaReflection(*message);
-}
-
-#endif  // !PROTOBUF_TEST_NO_DESCRIPTORS
-
-TEST(GeneratedMapFieldTest, NonEmptyMergeFrom) {
-  unittest::TestMap message1, message2;
-
-  MapTestUtil::SetMapFields(&message1);
-
-  // This field will test merging into an empty spot.
-  (*message2.mutable_map_int32_int32())[1] = 1;
-  message1.mutable_map_int32_int32()->erase(1);
-
-  // This tests overwriting.
-  (*message2.mutable_map_int32_double())[1] = 1;
-  (*message1.mutable_map_int32_double())[1] = 2;
-
-  message1.MergeFrom(message2);
-  MapTestUtil::ExpectMapFieldsSet(message1);
-
-  // Test reflection MergeFrom does not sync to repeated field
-  // and there is no duplicated keys.
-  MapTestUtil::SetMapFields(&message1);
-  MapTestUtil::SetMapFields(&message2);
-
-  message2.MergeFrom(message1);
-
-  std::string output1, output2;
-  TextFormat::PrintToString(message1, &output1);
-  TextFormat::PrintToString(message2, &output2);
-  EXPECT_EQ(output1, output2);
-}
-
-TEST(GeneratedMapFieldTest, MergeFromMessageMap) {
-  unittest::TestMessageMap message1, message2;
-
-  (*message1.mutable_map_int32_message())[0].add_repeated_int32(100);
-  (*message2.mutable_map_int32_message())[0].add_repeated_int32(101);
-
-  message1.MergeFrom(message2);
-
-  // Checks repeated field is overwritten.
-  EXPECT_EQ(1, message1.map_int32_message().at(0).repeated_int32_size());
-  EXPECT_EQ(101, message1.map_int32_message().at(0).repeated_int32(0));
-}
-
-// Test the generated SerializeWithCachedSizesToArray()
-TEST(GeneratedMapFieldTest, SerializationToArray) {
-  unittest::TestMap message1, message2;
-  std::string data;
-  MapTestUtil::SetMapFields(&message1);
-  size_t size = message1.ByteSizeLong();
-  data.resize(size);
-  uint8* start = reinterpret_cast<uint8*>(::google::protobuf::string_as_array(&data));
-  uint8* end = message1.SerializeWithCachedSizesToArray(start);
-  EXPECT_EQ(size, end - start);
-  EXPECT_TRUE(message2.ParseFromString(data));
-  MapTestUtil::ExpectMapFieldsSet(message2);
-}
-
-// Test the generated SerializeWithCachedSizes()
-TEST(GeneratedMapFieldTest, SerializationToStream) {
-  unittest::TestMap message1, message2;
-  MapTestUtil::SetMapFields(&message1);
-  size_t size = message1.ByteSizeLong();
-  std::string data;
-  data.resize(size);
-  {
-    // Allow the output stream to buffer only one byte at a time.
-    io::ArrayOutputStream array_stream(::google::protobuf::string_as_array(&data), size, 1);
-    io::CodedOutputStream output_stream(&array_stream);
-    message1.SerializeWithCachedSizes(&output_stream);
-    EXPECT_FALSE(output_stream.HadError());
-    EXPECT_EQ(size, output_stream.ByteCount());
-  }
-  EXPECT_TRUE(message2.ParseFromString(data));
-  MapTestUtil::ExpectMapFieldsSet(message2);
-}
-
-TEST(GeneratedMapFieldTest, ParseFailsIfMalformed) {
-  unittest::TestMapSubmessage o, p;
-  auto m = o.mutable_test_map()->mutable_map_int32_foreign_message();
-  (*m)[0].set_c(-1);
-  std::string serialized;
-  EXPECT_TRUE(o.SerializeToString(&serialized));
-
-  // Should parse correctly.
-  EXPECT_TRUE(p.ParseFromString(serialized));
-
-  // Overwriting the last byte to 0xFF results in malformed wire.
-  serialized[serialized.size() - 1] = 0xFF;
-  EXPECT_FALSE(p.ParseFromString(serialized));
-}
-
-
-TEST(GeneratedMapFieldTest, SameTypeMaps) {
-  const Descriptor* map1 = unittest::TestSameTypeMap::descriptor()
-                               ->FindFieldByName("map1")
-                               ->message_type();
-  const Descriptor* map2 = unittest::TestSameTypeMap::descriptor()
-                               ->FindFieldByName("map2")
-                               ->message_type();
-
-  const Message* map1_entry =
-      MessageFactory::generated_factory()->GetPrototype(map1);
-  const Message* map2_entry =
-      MessageFactory::generated_factory()->GetPrototype(map2);
-
-  EXPECT_EQ(map1, map1_entry->GetDescriptor());
-  EXPECT_EQ(map2, map2_entry->GetDescriptor());
-}
-
-TEST(GeneratedMapFieldTest, Proto2UnknownEnum) {
-  unittest::TestEnumMapPlusExtra from;
-  (*from.mutable_known_map_field())[0] = unittest::E_PROTO2_MAP_ENUM_FOO;
-  (*from.mutable_unknown_map_field())[0] = unittest::E_PROTO2_MAP_ENUM_EXTRA;
-  std::string data;
-  from.SerializeToString(&data);
-
-  unittest::TestEnumMap to;
-  EXPECT_TRUE(to.ParseFromString(data));
-  EXPECT_EQ(0, to.unknown_map_field().size());
-  const UnknownFieldSet& unknown_field_set =
-      to.GetReflection()->GetUnknownFields(to);
-  EXPECT_EQ(1, unknown_field_set.field_count());
-  EXPECT_EQ(1, to.known_map_field().size());
-  EXPECT_EQ(unittest::PROTO2_MAP_ENUM_FOO, to.known_map_field().at(0));
-
-  data.clear();
-  from.Clear();
-  to.SerializeToString(&data);
-  EXPECT_TRUE(from.ParseFromString(data));
-  EXPECT_EQ(0, from.GetReflection()->GetUnknownFields(from).field_count());
-  EXPECT_EQ(1, from.known_map_field().size());
-  EXPECT_EQ(unittest::E_PROTO2_MAP_ENUM_FOO, from.known_map_field().at(0));
-  EXPECT_EQ(1, from.unknown_map_field().size());
-  EXPECT_EQ(unittest::E_PROTO2_MAP_ENUM_EXTRA, from.unknown_map_field().at(0));
-}
-
-TEST(GeneratedMapFieldTest, StandardWireFormat) {
-  unittest::TestMap message;
-  std::string data = "\x0A\x04\x08\x01\x10\x01";
-
-  EXPECT_TRUE(message.ParseFromString(data));
-  EXPECT_EQ(1, message.map_int32_int32().size());
-  EXPECT_EQ(1, message.map_int32_int32().at(1));
-}
-
-TEST(GeneratedMapFieldTest, UnorderedWireFormat) {
-  unittest::TestMap message;
-
-  // put value before key in wire format
-  std::string data = "\x0A\x04\x10\x01\x08\x02";
-
-  EXPECT_TRUE(message.ParseFromString(data));
-  EXPECT_EQ(1, message.map_int32_int32().size());
-  ASSERT_NE(message.map_int32_int32().find(2), message.map_int32_int32().end());
-  EXPECT_EQ(1, message.map_int32_int32().at(2));
-}
-
-TEST(GeneratedMapFieldTest, DuplicatedKeyWireFormat) {
-  unittest::TestMap message;
-
-  // Two key fields in wire format
-  std::string data = "\x0A\x06\x08\x01\x08\x02\x10\x01";
-
-  EXPECT_TRUE(message.ParseFromString(data));
-  EXPECT_EQ(1, message.map_int32_int32().size());
-  EXPECT_EQ(1, message.map_int32_int32().at(2));
-
-  // A similar test, but with a map from int to a message type.
-  // Again, we want to be sure that the "second one wins" when
-  // there are two separate entries with the same key.
-  const int key = 99;
-  unittest::TestRequiredMessageMap map_message;
-  unittest::TestRequired with_dummy4;
-  with_dummy4.set_a(0);
-  with_dummy4.set_b(0);
-  with_dummy4.set_c(0);
-  with_dummy4.set_dummy4(11);
-  (*map_message.mutable_map_field())[key] = with_dummy4;
-  std::string s = map_message.SerializeAsString();
-  unittest::TestRequired with_dummy5;
-  with_dummy5.set_a(0);
-  with_dummy5.set_b(0);
-  with_dummy5.set_c(0);
-  with_dummy5.set_dummy5(12);
-  (*map_message.mutable_map_field())[key] = with_dummy5;
-  std::string both = s + map_message.SerializeAsString();
-  // We don't expect a merge now.  The "second one wins."
-  ASSERT_TRUE(map_message.ParseFromString(both));
-  ASSERT_EQ(1, map_message.map_field().size());
-  ASSERT_EQ(1, map_message.map_field().count(key));
-  EXPECT_EQ(0, map_message.map_field().find(key)->second.a());
-  EXPECT_EQ(0, map_message.map_field().find(key)->second.b());
-  EXPECT_EQ(0, map_message.map_field().find(key)->second.c());
-  EXPECT_FALSE(map_message.map_field().find(key)->second.has_dummy4());
-  ASSERT_TRUE(map_message.map_field().find(key)->second.has_dummy5());
-  EXPECT_EQ(12, map_message.map_field().find(key)->second.dummy5());
-}
-
-// Exhaustive combinations of keys, values, and junk in any order.
-// This re-tests some of the things tested above, but if it fails
-// it's more work to determine what went wrong, so it isn't necessarily
-// bad that we have the simpler tests too.
-TEST(GeneratedMapFieldTest, KeysValuesUnknownsWireFormat) {
-  unittest::TestMap message;
-  const int kMaxNumKeysAndValuesAndJunk = 4;
-  const char kKeyTag = 0x08;
-  const char kValueTag = 0x10;
-  const char kJunkTag = 0x20;
-  for (int items = 0; items <= kMaxNumKeysAndValuesAndJunk; items++) {
-    std::string data = "\x0A";
-    // Encode length of what will follow.
-    data.push_back(items * 2);
-    static const int kBitsOfIPerItem = 4;
-    static const int mask = (1 << kBitsOfIPerItem) - 1;
-    // Each iteration of the following is a test.  It uses i as bit vector
-    // encoding the keys and values to put in the wire format.
-    for (int i = 0; i < (1 << (items * kBitsOfIPerItem)); i++) {
-      std::string wire_format = data;
-      int expected_key = 0;
-      int expected_value = 0;
-      for (int k = i, j = 0; j < items; j++, k >>= kBitsOfIPerItem) {
-        bool is_key = k & 0x1;
-        bool is_value = !is_key && (k & 0x2);
-        wire_format.push_back(is_key ? kKeyTag
-                                     : is_value ? kValueTag : kJunkTag);
-        char c = static_cast<char>(k & mask) >> 2;  // One char after the tag.
-        wire_format.push_back(c);
-        if (is_key) expected_key = static_cast<int>(c);
-        if (is_value) expected_value = static_cast<int>(c);
-        bool res = message.ParseFromString(wire_format);
-        bool expect_success = true;
-        // Unfortunately the old map parser accepts malformed input, the new
-        // parser accepts only correct input.
-        if (j != items - 1) expect_success = false;
-        if (expect_success) {
-          ASSERT_TRUE(res);
-          ASSERT_EQ(1, message.map_int32_int32().size());
-          ASSERT_EQ(expected_key, message.map_int32_int32().begin()->first);
-          ASSERT_EQ(expected_value, message.map_int32_int32().begin()->second);
-        } else {
-          ASSERT_FALSE(res);
-        }
-      }
-    }
-  }
-}
-
-TEST(GeneratedMapFieldTest, DuplicatedValueWireFormat) {
-  unittest::TestMap message;
-
-  // Two value fields in wire format
-  std::string data = "\x0A\x06\x08\x01\x10\x01\x10\x02";
-
-  EXPECT_TRUE(message.ParseFromString(data));
-  EXPECT_EQ(1, message.map_int32_int32().size());
-  EXPECT_EQ(2, message.map_int32_int32().at(1));
-}
-
-TEST(GeneratedMapFieldTest, MissedKeyWireFormat) {
-  unittest::TestMap message;
-
-  // No key field in wire format
-  std::string data = "\x0A\x02\x10\x01";
-
-  EXPECT_TRUE(message.ParseFromString(data));
-  EXPECT_EQ(1, message.map_int32_int32().size());
-  ASSERT_NE(message.map_int32_int32().find(0), message.map_int32_int32().end());
-  EXPECT_EQ(1, message.map_int32_int32().at(0));
-}
-
-TEST(GeneratedMapFieldTest, MissedValueWireFormat) {
-  unittest::TestMap message;
-
-  // No value field in wire format
-  std::string data = "\x0A\x02\x08\x01";
-
-  EXPECT_TRUE(message.ParseFromString(data));
-  EXPECT_EQ(1, message.map_int32_int32().size());
-  ASSERT_NE(message.map_int32_int32().find(1), message.map_int32_int32().end());
-  EXPECT_EQ(0, message.map_int32_int32().at(1));
-}
-
-TEST(GeneratedMapFieldTest, MissedValueTextFormat) {
-  unittest::TestMap message;
-
-  // No value field in text format
-  std::string text =
-      "map_int32_foreign_message {\n"
-      "  key: 1234567890\n"
-      "}";
-
-  EXPECT_TRUE(TextFormat::ParseFromString(text, &message));
-  EXPECT_EQ(1, message.map_int32_foreign_message().size());
-  EXPECT_EQ(11, message.ByteSizeLong());
-}
-
-TEST(GeneratedMapFieldTest, UnknownFieldWireFormat) {
-  unittest::TestMap message;
-
-  // Unknown field in wire format
-  std::string data = "\x0A\x06\x08\x02\x10\x03\x18\x01";
-
-  EXPECT_TRUE(message.ParseFromString(data));
-  EXPECT_EQ(1, message.map_int32_int32().size());
-  EXPECT_EQ(3, message.map_int32_int32().at(2));
-}
-
-TEST(GeneratedMapFieldTest, CorruptedWireFormat) {
-  unittest::TestMap message;
-
-  // corrupted data in wire format
-  std::string data = "\x0A\x06\x08\x02\x11\x03";
-
-  EXPECT_FALSE(message.ParseFromString(data));
-}
-
-TEST(GeneratedMapFieldTest, IsInitialized) {
-  unittest::TestRequiredMessageMap map_message;
-
-  // Add an uninitialized message.
-  (*map_message.mutable_map_field())[0];
-  EXPECT_FALSE(map_message.IsInitialized());
-
-  // Initialize uninitialized message
-  (*map_message.mutable_map_field())[0].set_a(0);
-  (*map_message.mutable_map_field())[0].set_b(0);
-  (*map_message.mutable_map_field())[0].set_c(0);
-  EXPECT_TRUE(map_message.IsInitialized());
-}
-
-TEST(GeneratedMapFieldTest, SpaceUsed) {
-  unittest::TestRequiredMessageMap map_message;
-  const size_t initial = map_message.SpaceUsed();
-  const size_t space_used_message = unittest::TestRequired().SpaceUsed();
-
-  auto& m = *map_message.mutable_map_field();
-  constexpr int kNumValues = 100;
-  for (int i = 0; i < kNumValues; ++i) {
-    m[i];
-  }
-
-  // The exact value will depend on internal state, like collisions,
-  // so we can't predict it. But we can predict a lower bound.
-  size_t lower_bound =
-      initial + kNumValues * (space_used_message + sizeof(int32) +
-                              /* Node::next */ sizeof(void*) +
-                              /* table entry */ sizeof(void*));
-
-  EXPECT_LE(lower_bound, map_message.SpaceUsed());
-}
-
-TEST(GeneratedMapFieldTest, MessagesMustMerge) {
-  unittest::TestRequiredMessageMap map_message;
-
-  unittest::TestRequired with_dummy4;
-  with_dummy4.set_a(97);
-  with_dummy4.set_b(91);
-  with_dummy4.set_dummy4(98);
-  EXPECT_FALSE(with_dummy4.IsInitialized());
-  (*map_message.mutable_map_field())[0] = with_dummy4;
-  EXPECT_FALSE(map_message.IsInitialized());
-
-  unittest::TestRequired with_dummy5;
-  with_dummy5.set_b(0);
-  with_dummy5.set_c(33);
-  with_dummy5.set_dummy5(99);
-  EXPECT_FALSE(with_dummy5.IsInitialized());
-  (*map_message.mutable_map_field())[0] = with_dummy5;
-  EXPECT_FALSE(map_message.IsInitialized());
-
-  // The wire format of MapEntry is straightforward (*) and can be manually
-  // constructed to force merging of two uninitialized messages that would
-  // result in an initialized message.
-  //
-  // (*) http://google3/net/proto2/internal/map_test.cc?l=2433&rcl=310012028
-  std::string dummy4_s = with_dummy4.SerializePartialAsString();
-  std::string dummy5_s = with_dummy5.SerializePartialAsString();
-  int payload_size = dummy4_s.size() + dummy5_s.size();
-  // Makes sure the payload size fits into one byte.
-  ASSERT_LT(payload_size, 128);
-
-  std::string s(6, 0);
-  char* p = &s[0];
-  *p++ = WireFormatLite::MakeTag(1, WireFormatLite::WIRETYPE_LENGTH_DELIMITED);
-  // Length: 2B for key tag & val and 2B for val tag and length of the following
-  // payload.
-  *p++ = 4 + payload_size;
-  *p++ = WireFormatLite::MakeTag(1, WireFormatLite::WIRETYPE_VARINT);
-  *p++ = 0;
-  *p++ = WireFormatLite::MakeTag(2, WireFormatLite::WIRETYPE_LENGTH_DELIMITED);
-  *p++ = payload_size;
-  StrAppend(&s, dummy4_s, dummy5_s);
-
-  // Test key then value then value.
-  int key = 0;
-  ASSERT_TRUE(map_message.ParseFromString(s));
-  ASSERT_EQ(1, map_message.map_field().size());
-  ASSERT_EQ(1, map_message.map_field().count(key));
-  EXPECT_EQ(97, map_message.map_field().find(key)->second.a());
-  EXPECT_EQ(0, map_message.map_field().find(key)->second.b());
-  EXPECT_EQ(33, map_message.map_field().find(key)->second.c());
-  EXPECT_EQ(98, map_message.map_field().find(key)->second.dummy4());
-  EXPECT_EQ(99, map_message.map_field().find(key)->second.dummy5());
-
-  // Test key then value then value then key.
-  s.push_back(s[2]);  // Copy the key's tag.
-  key = 19;
-  s.push_back(key);  // Second key is 19 instead of 0.
-  s[1] += 2;         // Adjust encoded size.
-  ASSERT_TRUE(map_message.ParseFromString(s));
-  ASSERT_EQ(1, map_message.map_field().size());
-  ASSERT_EQ(1, map_message.map_field().count(key));
-  EXPECT_EQ(97, map_message.map_field().find(key)->second.a());
-  EXPECT_EQ(0, map_message.map_field().find(key)->second.b());
-  EXPECT_EQ(33, map_message.map_field().find(key)->second.c());
-  EXPECT_EQ(98, map_message.map_field().find(key)->second.dummy4());
-  EXPECT_EQ(99, map_message.map_field().find(key)->second.dummy5());
-}
-
-// Generated Message Reflection Test ================================
-
-TEST(GeneratedMapFieldReflectionTest, SpaceUsed) {
-  unittest::TestMap message;
-  MapReflectionTester reflection_tester(unittest::TestMap::descriptor());
-  reflection_tester.SetMapFieldsViaReflection(&message);
-
-  EXPECT_LT(0, message.GetReflection()->SpaceUsedLong(message));
-}
-
-TEST(GeneratedMapFieldReflectionTest, Accessors) {
-  // Set every field to a unique value then go back and check all those
-  // values.
-  unittest::TestMap message;
-  MapReflectionTester reflection_tester(unittest::TestMap::descriptor());
-  reflection_tester.SetMapFieldsViaReflection(&message);
-  MapTestUtil::ExpectMapFieldsSet(message);
-  reflection_tester.ExpectMapFieldsSetViaReflection(message);
-  reflection_tester.ExpectMapFieldsSetViaReflectionIterator(&message);
-
-  reflection_tester.ModifyMapFieldsViaReflection(&message);
-  MapTestUtil::ExpectMapFieldsModified(message);
-}
-
-TEST(GeneratedMapFieldReflectionTest, Swap) {
-  unittest::TestMap message1;
-  unittest::TestMap message2;
-
-  MapTestUtil::SetMapFields(&message1);
-
-  const Reflection* reflection = message1.GetReflection();
-  reflection->Swap(&message1, &message2);
-
-  MapTestUtil::ExpectClear(message1);
-  MapTestUtil::ExpectMapFieldsSet(message2);
-}
-
-TEST(GeneratedMapFieldReflectionTest, SwapWithBothSet) {
-  unittest::TestMap message1;
-  unittest::TestMap message2;
-
-  MapTestUtil::SetMapFields(&message1);
-  MapTestUtil::SetMapFields(&message2);
-  MapTestUtil::ModifyMapFields(&message2);
-
-  const Reflection* reflection = message1.GetReflection();
-  reflection->Swap(&message1, &message2);
-
-  MapTestUtil::ExpectMapFieldsModified(message1);
-  MapTestUtil::ExpectMapFieldsSet(message2);
-}
-
-TEST(GeneratedMapFieldReflectionTest, SwapFields) {
-  unittest::TestMap message1;
-  unittest::TestMap message2;
-
-  MapTestUtil::SetMapFields(&message2);
-
-  std::vector<const FieldDescriptor*> fields;
-  const Reflection* reflection = message1.GetReflection();
-  reflection->ListFields(message2, &fields);
-  reflection->SwapFields(&message1, &message2, fields);
-
-  MapTestUtil::ExpectMapFieldsSet(message1);
-  MapTestUtil::ExpectClear(message2);
-}
-
-TEST(GeneratedMapFieldReflectionTest, ClearField) {
-  unittest::TestMap message;
-  MapTestUtil::SetMapFields(&message);
-  MapTestUtil::ExpectMapFieldsSet(message);
-
-  MapReflectionTester reflection_tester(unittest::TestMap::descriptor());
-  reflection_tester.ClearMapFieldsViaReflection(&message);
-  reflection_tester.ExpectClearViaReflection(message);
-  reflection_tester.ExpectClearViaReflectionIterator(&message);
-}
-
-TEST(GeneratedMapFieldReflectionTest, RemoveLast) {
-  unittest::TestMap message;
-  MapReflectionTester reflection_tester(unittest::TestMap::descriptor());
-
-  MapTestUtil::SetMapFields(&message);
-  MapTestUtil::ExpectMapsSize(message, 2);
-  std::vector<const Message*> expected_entries =
-      MapTestUtil::GetMapEntries(message, 0);
-
-  reflection_tester.RemoveLastMapsViaReflection(&message);
-
-  MapTestUtil::ExpectMapsSize(message, 1);
-  std::vector<const Message*> remained_entries =
-      MapTestUtil::GetMapEntries(message, 0);
-  EXPECT_TRUE(expected_entries == remained_entries);
-}
-
-TEST(GeneratedMapFieldReflectionTest, ReleaseLast) {
-  unittest::TestMap message;
-  const Descriptor* descriptor = message.GetDescriptor();
-  MapReflectionTester reflection_tester(descriptor);
-
-  MapTestUtil::SetMapFields(&message);
-
-  MapTestUtil::ExpectMapsSize(message, 2);
-
-  reflection_tester.ReleaseLastMapsViaReflection(&message);
-
-  MapTestUtil::ExpectMapsSize(message, 1);
-
-  // Now test that we actually release the right message.
-  message.Clear();
-  MapTestUtil::SetMapFields(&message);
-
-  MapTestUtil::ExpectMapsSize(message, 2);
-  std::vector<const Message*> expect_last =
-      MapTestUtil::GetMapEntries(message, 1);
-  std::vector<const Message*> release_last =
-      MapTestUtil::GetMapEntriesFromRelease(&message);
-  MapTestUtil::ExpectMapsSize(message, 1);
-  EXPECT_TRUE(expect_last == release_last);
-  for (std::vector<const Message*>::iterator it = release_last.begin();
-       it != release_last.end(); ++it) {
-    delete *it;
-  }
-}
-
-TEST(GeneratedMapFieldReflectionTest, SwapElements) {
-  unittest::TestMap message;
-  MapReflectionTester reflection_tester(unittest::TestMap::descriptor());
-
-  MapTestUtil::SetMapFields(&message);
-
-  // Get pointers of map entries at their original position
-  std::vector<const Message*> entries0 = MapTestUtil::GetMapEntries(message, 0);
-  std::vector<const Message*> entries1 = MapTestUtil::GetMapEntries(message, 1);
-
-  // Swap the first time.
-  reflection_tester.SwapMapsViaReflection(&message);
-
-  // Get pointer of map entry after swap once.
-  std::vector<const Message*> entries0_once =
-      MapTestUtil::GetMapEntries(message, 0);
-  std::vector<const Message*> entries1_once =
-      MapTestUtil::GetMapEntries(message, 1);
-
-  // Test map entries are swapped.
-  MapTestUtil::ExpectMapsSize(message, 2);
-  EXPECT_TRUE(entries0 == entries1_once);
-  EXPECT_TRUE(entries1 == entries0_once);
-
-  // Swap the second time.
-  reflection_tester.SwapMapsViaReflection(&message);
-
-  // Get pointer of map entry after swap once.
-  std::vector<const Message*> entries0_twice =
-      MapTestUtil::GetMapEntries(message, 0);
-  std::vector<const Message*> entries1_twice =
-      MapTestUtil::GetMapEntries(message, 1);
-
-  // Test map entries are swapped back.
-  MapTestUtil::ExpectMapsSize(message, 2);
-  EXPECT_TRUE(entries0 == entries0_twice);
-  EXPECT_TRUE(entries1 == entries1_twice);
-}
-
-TEST(GeneratedMapFieldReflectionTest, MutableUnknownFields) {
-  unittest::TestMap message;
-  MapReflectionTester reflection_tester(unittest::TestMap::descriptor());
-  reflection_tester.MutableUnknownFieldsOfMapFieldsViaReflection(&message);
-}
-
-TEST(GeneratedMapFieldReflectionTest, EmbedProto2Message) {
-  unittest::TestMessageMap message;
-
-  const FieldDescriptor* map_field =
-      unittest::TestMessageMap::descriptor()->FindFieldByName(
-          "map_int32_message");
-  const FieldDescriptor* value =
-      map_field->message_type()->FindFieldByName("value");
-
-  Message* entry_message =
-      message.GetReflection()->AddMessage(&message, map_field);
-  EXPECT_EQ(
-      &entry_message->GetReflection()->GetMessage(*entry_message, value),
-      reinterpret_cast<const Message*>(&TestAllTypes::default_instance()));
-
-  Message* proto2_message =
-      entry_message->GetReflection()->MutableMessage(entry_message, value);
-  EXPECT_EQ(unittest::TestAllTypes::descriptor(),
-            proto2_message->GetDescriptor());
-  ASSERT_EQ(1, message.map_int32_message().size());
-}
-
-TEST(GeneratedMapFieldReflectionTest, MergeFromClearMapEntry) {
-  unittest::TestMap message;
-  const FieldDescriptor* map_field =
-      unittest::TestMap::descriptor()->FindFieldByName("map_int32_int32");
-  const FieldDescriptor* key =
-      map_field->message_type()->FindFieldByName("key");
-  const FieldDescriptor* value =
-      map_field->message_type()->FindFieldByName("value");
-
-  Message* entry_message1 =
-      message.GetReflection()->AddMessage(&message, map_field);
-  EXPECT_FALSE(entry_message1->GetReflection()->HasField(*entry_message1, key));
-  EXPECT_FALSE(
-      entry_message1->GetReflection()->HasField(*entry_message1, value));
-
-  Message* entry_message2 =
-      message.GetReflection()->AddMessage(&message, map_field);
-  EXPECT_FALSE(entry_message2->GetReflection()->HasField(*entry_message2, key));
-  EXPECT_FALSE(
-      entry_message2->GetReflection()->HasField(*entry_message2, value));
-
-  entry_message1->MergeFrom(*entry_message2);
-  EXPECT_FALSE(entry_message1->GetReflection()->HasField(*entry_message1, key));
-  EXPECT_FALSE(
-      entry_message1->GetReflection()->HasField(*entry_message1, value));
-}
-
-TEST(GeneratedMapFieldReflectionTest, MapEntryClear) {
-  unittest::TestMap message;
-  MapReflectionTester reflection_tester(unittest::TestMap::descriptor());
-  reflection_tester.MutableUnknownFieldsOfMapFieldsViaReflection(&message);
-}
-
-TEST(GeneratedMapFieldReflectionTest, Proto2MapEntryClear) {
-  unittest::TestEnumMap message;
-  const Descriptor* descriptor = message.GetDescriptor();
-  const FieldDescriptor* field_descriptor =
-      descriptor->FindFieldByName("known_map_field");
-  const FieldDescriptor* value_descriptor =
-      field_descriptor->message_type()->FindFieldByName("value");
-  Message* sub_message =
-      message.GetReflection()->AddMessage(&message, field_descriptor);
-  EXPECT_EQ(0, sub_message->GetReflection()->GetEnumValue(*sub_message,
-                                                          value_descriptor));
-}
-
-// Map Reflection API Test =========================================
-
-TEST(GeneratedMapFieldReflectionTest, SetViaMapReflection) {
-  unittest::TestMap message;
-  MapReflectionTester reflection_tester(unittest::TestMap::descriptor());
-  reflection_tester.SetMapFieldsViaMapReflection(&message);
-  reflection_tester.ExpectMapFieldsSetViaReflection(message);
-  reflection_tester.ExpectMapFieldsSetViaReflectionIterator(&message);
-}
-
-// Dynamic Message Test =============================================
-
-class MapFieldInDynamicMessageTest : public testing::Test {
- protected:
-  const DescriptorPool* pool_;
-  DynamicMessageFactory factory_;
-  const Descriptor* map_descriptor_;
-  const Descriptor* recursive_map_descriptor_;
-  const Message* map_prototype_;
-
-  MapFieldInDynamicMessageTest()
-      : pool_(DescriptorPool::generated_pool()), factory_(pool_) {}
-
-  virtual void SetUp() {
-    map_descriptor_ = pool_->FindMessageTypeByName("protobuf_unittest.TestMap");
-    recursive_map_descriptor_ =
-        pool_->FindMessageTypeByName("protobuf_unittest.TestRecursiveMapMessage");
-    ASSERT_TRUE(map_descriptor_ != NULL);
-    ASSERT_TRUE(recursive_map_descriptor_ != NULL);
-    map_prototype_ = factory_.GetPrototype(map_descriptor_);
-  }
-};
-
-TEST_F(MapFieldInDynamicMessageTest, MapIndependentOffsets) {
-  // Check that all fields have independent offsets by setting each
-  // one to a unique value then checking that they all still have those
-  // unique values (i.e. they don't stomp each other).
-  std::unique_ptr<Message> message(map_prototype_->New());
-  MapReflectionTester reflection_tester(map_descriptor_);
-
-  reflection_tester.SetMapFieldsViaReflection(message.get());
-  reflection_tester.ExpectMapFieldsSetViaReflection(*message);
-}
-
-TEST_F(MapFieldInDynamicMessageTest, DynamicMapReflection) {
-  // Check that map fields work properly.
-  std::unique_ptr<Message> message(map_prototype_->New());
-
-  // Check set functions.
-  MapReflectionTester reflection_tester(map_descriptor_);
-  reflection_tester.SetMapFieldsViaMapReflection(message.get());
-  reflection_tester.ExpectMapFieldsSetViaReflection(*message);
-}
-
-TEST_F(MapFieldInDynamicMessageTest, MapSpaceUsed) {
-  // Test that SpaceUsedLong() works properly
-
-  // Since we share the implementation with generated messages, we don't need
-  // to test very much here.  Just make sure it appears to be working.
-
-  std::unique_ptr<Message> message(map_prototype_->New());
-  MapReflectionTester reflection_tester(map_descriptor_);
-
-  int initial_space_used = message->SpaceUsedLong();
-
-  reflection_tester.SetMapFieldsViaReflection(message.get());
-  EXPECT_LT(initial_space_used, message->SpaceUsedLong());
-}
-
-TEST_F(MapFieldInDynamicMessageTest, RecursiveMap) {
-  TestRecursiveMapMessage from;
-  (*from.mutable_a())[""];
-  std::string data = from.SerializeAsString();
-  std::unique_ptr<Message> to(
-      factory_.GetPrototype(recursive_map_descriptor_)->New());
-  ASSERT_TRUE(to->ParseFromString(data));
-}
-
-TEST_F(MapFieldInDynamicMessageTest, MapValueReferernceValidAfterSerialize) {
-  std::unique_ptr<Message> message(map_prototype_->New());
-  MapReflectionTester reflection_tester(map_descriptor_);
-  reflection_tester.SetMapFieldsViaMapReflection(message.get());
-
-  // Get value reference before serialization, so that we know the value is from
-  // map.
-  MapKey map_key;
-  MapValueRef map_val;
-  map_key.SetInt32Value(0);
-  reflection_tester.GetMapValueViaMapReflection(
-      message.get(), "map_int32_foreign_message", map_key, &map_val);
-  Message* submsg = map_val.MutableMessageValue();
-
-  // In previous implementation, calling SerializeToString will cause syncing
-  // from map to repeated field, which will invalidate the submsg we previously
-  // got.
-  std::string data;
-  message->SerializeToString(&data);
-
-  const Reflection* submsg_reflection = submsg->GetReflection();
-  const Descriptor* submsg_desc = submsg->GetDescriptor();
-  const FieldDescriptor* submsg_field = submsg_desc->FindFieldByName("c");
-  submsg_reflection->SetInt32(submsg, submsg_field, 128);
-
-  message->SerializeToString(&data);
-  TestMap to;
-  to.ParseFromString(data);
-  EXPECT_EQ(128, to.map_int32_foreign_message().at(0).c());
-}
-
-TEST_F(MapFieldInDynamicMessageTest, MapEntryReferernceValidAfterSerialize) {
-  std::unique_ptr<Message> message(map_prototype_->New());
-  MapReflectionTester reflection_tester(map_descriptor_);
-  reflection_tester.SetMapFieldsViaReflection(message.get());
-
-  // Get map entry before serialization, so that we know the it is from
-  // repeated field.
-  Message* map_entry = reflection_tester.GetMapEntryViaReflection(
-      message.get(), "map_int32_foreign_message", 0);
-  const Reflection* map_entry_reflection = map_entry->GetReflection();
-  const Descriptor* map_entry_desc = map_entry->GetDescriptor();
-  const FieldDescriptor* value_field = map_entry_desc->FindFieldByName("value");
-  Message* submsg =
-      map_entry_reflection->MutableMessage(map_entry, value_field);
-
-  // In previous implementation, calling SerializeToString will cause syncing
-  // from repeated field to map, which will invalidate the map_entry we
-  // previously got.
-  std::string data;
-  message->SerializeToString(&data);
-
-  const Reflection* submsg_reflection = submsg->GetReflection();
-  const Descriptor* submsg_desc = submsg->GetDescriptor();
-  const FieldDescriptor* submsg_field = submsg_desc->FindFieldByName("c");
-  submsg_reflection->SetInt32(submsg, submsg_field, 128);
-
-  message->SerializeToString(&data);
-  TestMap to;
-  to.ParseFromString(data);
-  EXPECT_EQ(128, to.map_int32_foreign_message().at(0).c());
-}
-
-// ReflectionOps Test ===============================================
-
-TEST(ReflectionOpsForMapFieldTest, MapSanityCheck) {
-  unittest::TestMap message;
-
-  MapTestUtil::SetMapFields(&message);
-  MapTestUtil::ExpectMapFieldsSet(message);
-}
-
-TEST(ReflectionOpsForMapFieldTest, MapCopy) {
-  unittest::TestMap message, message2;
-
-  MapTestUtil::SetMapFields(&message);
-
-  ReflectionOps::Copy(message, &message2);
-
-  MapTestUtil::ExpectMapFieldsSet(message2);
-
-  // Copying from self should be a no-op.
-  ReflectionOps::Copy(message2, &message2);
-  MapTestUtil::ExpectMapFieldsSet(message2);
-}
-
-TEST(ReflectionOpsForMapFieldTest, MergeMap) {
-  // Note:  Copy is implemented in terms of Merge() so technically the Copy
-  //   test already tested most of this.
-
-  unittest::TestMap message, message2;
-
-  MapTestUtil::SetMapFields(&message);
-
-  ReflectionOps::Merge(message2, &message);
-
-  MapTestUtil::ExpectMapFieldsSet(message);
-}
-
-TEST(ReflectionOpsForMapFieldTest, ClearMap) {
-  unittest::TestMap message;
-
-  MapTestUtil::SetMapFields(&message);
-
-  ReflectionOps::Clear(&message);
-
-  MapTestUtil::ExpectClear(message);
-}
-
-TEST(ReflectionOpsForMapFieldTest, MapDiscardUnknownFields) {
-  unittest::TestMap message;
-  MapTestUtil::SetMapFields(&message);
-
-  // Set some unknown fields in message.
-  message.GetReflection()->MutableUnknownFields(&message)->AddVarint(123456,
-                                                                     654321);
-
-  // Discard them.
-  ReflectionOps::DiscardUnknownFields(&message);
-  MapTestUtil::ExpectMapFieldsSet(message);
-
-  EXPECT_EQ(0,
-            message.GetReflection()->GetUnknownFields(message).field_count());
-}
-
-TEST(ReflectionOpsForMapFieldTest, IsInitialized) {
-  unittest::TestRequiredMessageMap map_message;
-
-  // Add an uninitialized message.
-  (*map_message.mutable_map_field())[0];
-  EXPECT_FALSE(ReflectionOps::IsInitialized(map_message));
-
-  // Initialize uninitialized message
-  (*map_message.mutable_map_field())[0].set_a(0);
-  (*map_message.mutable_map_field())[0].set_b(0);
-  (*map_message.mutable_map_field())[0].set_c(0);
-  EXPECT_TRUE(ReflectionOps::IsInitialized(map_message));
-}
-
-// Wire Format Test =================================================
-
-TEST(WireFormatForMapFieldTest, ParseMap) {
-  unittest::TestMap source, dest;
-  std::string data;
-
-  // Serialize using the generated code.
-  MapTestUtil::SetMapFields(&source);
-  source.SerializeToString(&data);
-
-  // Parse using WireFormat.
-  io::ArrayInputStream raw_input(data.data(), data.size());
-  io::CodedInputStream input(&raw_input);
-  WireFormat::ParseAndMergePartial(&input, &dest);
-
-  // Check.
-  MapTestUtil::ExpectMapFieldsSet(dest);
-}
-
-TEST(WireFormatForMapFieldTest, MapByteSize) {
-  unittest::TestMap message;
-  MapTestUtil::SetMapFields(&message);
-
-  EXPECT_EQ(message.ByteSizeLong(), WireFormat::ByteSize(message));
-  message.Clear();
-  EXPECT_EQ(0, message.ByteSizeLong());
-  EXPECT_EQ(0, WireFormat::ByteSize(message));
-}
-
-TEST(WireFormatForMapFieldTest, SerializeMap) {
-  unittest::TestMap message;
-  std::string generated_data;
-  std::string dynamic_data;
-
-  MapTestUtil::SetMapFields(&message);
-
-  // Serialize using the generated code.
-  {
-    message.ByteSizeLong();
-    io::StringOutputStream raw_output(&generated_data);
-    io::CodedOutputStream output(&raw_output);
-    message.SerializeWithCachedSizes(&output);
-    ASSERT_FALSE(output.HadError());
-  }
-
-  // Serialize using WireFormat.
-  {
-    io::StringOutputStream raw_output(&dynamic_data);
-    io::CodedOutputStream output(&raw_output);
-    size_t size = WireFormat::ByteSize(message);
-    WireFormat::SerializeWithCachedSizes(message, size, &output);
-    ASSERT_FALSE(output.HadError());
-  }
-
-  // Should parse to the same message.
-  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, generated_data));
-  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, dynamic_data));
-}
-
-TEST(WireFormatForMapFieldTest, SerializeMapDynamicMessage) {
-  DynamicMessageFactory factory;
-  std::unique_ptr<Message> dynamic_message;
-  dynamic_message.reset(
-      factory.GetPrototype(unittest::TestMap::descriptor())->New());
-  MapReflectionTester reflection_tester(unittest::TestMap::descriptor());
-  reflection_tester.SetMapFieldsViaReflection(dynamic_message.get());
-  reflection_tester.ExpectMapFieldsSetViaReflection(*dynamic_message);
-
-  unittest::TestMap generated_message;
-  MapTestUtil::SetMapFields(&generated_message);
-  MapTestUtil::ExpectMapFieldsSet(generated_message);
-
-  std::string generated_data;
-  std::string dynamic_data;
-
-  // Serialize.
-  generated_message.SerializeToString(&generated_data);
-  dynamic_message->SerializeToString(&dynamic_data);
-
-  // Because map serialization doesn't guarantee order, we just compare
-  // serialized size here. This is enough to tell dynamic message doesn't miss
-  // anything in serialization.
-  EXPECT_TRUE(dynamic_data.size() == generated_data.size());
-}
-
-TEST(WireFormatForMapFieldTest, MapByteSizeDynamicMessage) {
-  DynamicMessageFactory factory;
-  std::unique_ptr<Message> dynamic_message;
-  dynamic_message.reset(
-      factory.GetPrototype(unittest::TestMap::descriptor())->New());
-  MapReflectionTester reflection_tester(unittest::TestMap::descriptor());
-  reflection_tester.SetMapFieldsViaReflection(dynamic_message.get());
-  reflection_tester.ExpectMapFieldsSetViaReflection(*dynamic_message);
-  std::string expected_serialized_data;
-  dynamic_message->SerializeToString(&expected_serialized_data);
-  int expected_size = expected_serialized_data.size();
-  EXPECT_EQ(dynamic_message->ByteSizeLong(), expected_size);
-
-  std::unique_ptr<Message> message2;
-  message2.reset(factory.GetPrototype(unittest::TestMap::descriptor())->New());
-  reflection_tester.SetMapFieldsViaMapReflection(message2.get());
-
-  const FieldDescriptor* field =
-      unittest::TestMap::descriptor()->FindFieldByName("map_int32_int32");
-  const Reflection* reflection = dynamic_message->GetReflection();
-
-  // Force the map field to mark with STATE_MODIFIED_REPEATED
-  reflection->RemoveLast(dynamic_message.get(), field);
-  dynamic_message->MergeFrom(*message2);
-  dynamic_message->MergeFrom(*message2);
-  // The map field is marked as STATE_MODIFIED_REPEATED, ByteSizeLong() will use
-  // repeated field which have duplicate keys to calculate.
-  size_t duplicate_size = dynamic_message->ByteSizeLong();
-  EXPECT_TRUE(duplicate_size > expected_size);
-  std::string duplicate_serialized_data;
-  dynamic_message->SerializeToString(&duplicate_serialized_data);
-  EXPECT_EQ(dynamic_message->ByteSizeLong(), duplicate_serialized_data.size());
-
-  // Force the map field to mark with map CLEAN
-  EXPECT_EQ(reflection_tester.MapSize(*dynamic_message, "map_int32_int32"), 2);
-  // The map field is marked as CLEAN, ByteSizeLong() will use map which do not
-  // have duplicate keys to calculate.
-  int size = dynamic_message->ByteSizeLong();
-  EXPECT_EQ(expected_size, size);
-
-  // Protobuf used to have a bug for serialize when map it marked CLEAN. It used
-  // repeated field to calculate ByteSizeLong but use map to serialize the real
-  // data, thus the ByteSizeLong may bigger than real serialized size. A crash
-  // might be happen at SerializeToString(). Or an "unexpected end group"
-  // warning was raised at parse back if user use SerializeWithCachedSizes()
-  // which avoids size check at serialize.
-  std::string serialized_data;
-  dynamic_message->SerializeToString(&serialized_data);
-  EXPECT_EQ(serialized_data, expected_serialized_data);
-  dynamic_message->ParseFromString(serialized_data);
-}
-
-TEST(WireFormatForMapFieldTest, MapParseHelpers) {
-  std::string data;
-
-  {
-    // Set up.
-    protobuf_unittest::TestMap message;
-    MapTestUtil::SetMapFields(&message);
-    message.SerializeToString(&data);
-  }
-
-  {
-    // Test ParseFromString.
-    protobuf_unittest::TestMap message;
-    EXPECT_TRUE(message.ParseFromString(data));
-    MapTestUtil::ExpectMapFieldsSet(message);
-  }
-
-  {
-    // Test ParseFromIstream.
-    protobuf_unittest::TestMap message;
-    std::stringstream stream(data);
-    EXPECT_TRUE(message.ParseFromIstream(&stream));
-    EXPECT_TRUE(stream.eof());
-    MapTestUtil::ExpectMapFieldsSet(message);
-  }
-
-  {
-    // Test ParseFromBoundedZeroCopyStream.
-    std::string data_with_junk(data);
-    data_with_junk.append("some junk on the end");
-    io::ArrayInputStream stream(data_with_junk.data(), data_with_junk.size());
-    protobuf_unittest::TestMap message;
-    EXPECT_TRUE(message.ParseFromBoundedZeroCopyStream(&stream, data.size()));
-    MapTestUtil::ExpectMapFieldsSet(message);
-  }
-
-  {
-    // Test that ParseFromBoundedZeroCopyStream fails (but doesn't crash) if
-    // EOF is reached before the expected number of bytes.
-    io::ArrayInputStream stream(data.data(), data.size());
-    protobuf_unittest::TestAllTypes message;
-    EXPECT_FALSE(
-        message.ParseFromBoundedZeroCopyStream(&stream, data.size() + 1));
-  }
-}
-
-// Deterministic Serialization Test ==========================================
-
-template <typename T>
-static std::string DeterministicSerializationWithSerializePartialToCodedStream(
-    const T& t) {
-  const size_t size = t.ByteSizeLong();
-  std::string result(size, '\0');
-  io::ArrayOutputStream array_stream(::google::protobuf::string_as_array(&result), size);
-  io::CodedOutputStream output_stream(&array_stream);
-  output_stream.SetSerializationDeterministic(true);
-  t.SerializePartialToCodedStream(&output_stream);
-  EXPECT_FALSE(output_stream.HadError());
-  EXPECT_EQ(size, output_stream.ByteCount());
-  return result;
-}
-
-template <typename T>
-static std::string DeterministicSerializationWithSerializeToCodedStream(
-    const T& t) {
-  const size_t size = t.ByteSizeLong();
-  std::string result(size, '\0');
-  io::ArrayOutputStream array_stream(::google::protobuf::string_as_array(&result), size);
-  io::CodedOutputStream output_stream(&array_stream);
-  output_stream.SetSerializationDeterministic(true);
-  t.SerializeToCodedStream(&output_stream);
-  EXPECT_FALSE(output_stream.HadError());
-  EXPECT_EQ(size, output_stream.ByteCount());
-  return result;
-}
-
-template <typename T>
-static std::string DeterministicSerialization(const T& t) {
-  const size_t size = t.ByteSizeLong();
-  std::string result(size, '\0');
-  io::ArrayOutputStream array_stream(::google::protobuf::string_as_array(&result), size);
-  {
-    io::CodedOutputStream output_stream(&array_stream);
-    output_stream.SetSerializationDeterministic(true);
-    t.SerializeWithCachedSizes(&output_stream);
-    EXPECT_FALSE(output_stream.HadError());
-    EXPECT_EQ(size, output_stream.ByteCount());
-  }
-  EXPECT_EQ(result, DeterministicSerializationWithSerializeToCodedStream(t));
-  EXPECT_EQ(result,
-            DeterministicSerializationWithSerializePartialToCodedStream(t));
-  return result;
-}
-
-// Helper for MapSerializationTest.  Return a 7-bit ASCII string.
-static std::string ConstructKey(uint64 n) {
-  std::string s(n % static_cast<uint64>(9), '\0');
-  if (s.empty()) {
-    return StrCat(n);
-  } else {
-    while (n != 0) {
-      s[n % s.size()] = (n >> 10) & 0x7f;
-      n /= 888;
-    }
-    return s;
-  }
-}
-
-TEST(MapSerializationTest, Deterministic) {
-  const int kIters = 25;
-  protobuf_unittest::TestMaps t;
-  protobuf_unittest::TestIntIntMap inner;
-  (*inner.mutable_m())[0] = (*inner.mutable_m())[10] =
-      (*inner.mutable_m())[-200] = 0;
-  uint64 frog = 9;
-  const uint64 multiplier = 0xa29cd16f;
-  for (int i = 0; i < kIters; i++) {
-    const int32 i32 = static_cast<int32>(frog & 0xffffffff);
-    const uint32 u32 = static_cast<uint32>(i32) * 91919;
-    const int64 i64 = static_cast<int64>(frog);
-    const uint64 u64 = frog * static_cast<uint64>(187321);
-    const bool b = i32 > 0;
-    const std::string s = ConstructKey(frog);
-    (*inner.mutable_m())[i] = i32;
-    (*t.mutable_m_int32())[i32] = (*t.mutable_m_sint32())[i32] =
-        (*t.mutable_m_sfixed32())[i32] = inner;
-    (*t.mutable_m_uint32())[u32] = (*t.mutable_m_fixed32())[u32] = inner;
-    (*t.mutable_m_int64())[i64] = (*t.mutable_m_sint64())[i64] =
-        (*t.mutable_m_sfixed64())[i64] = inner;
-    (*t.mutable_m_uint64())[u64] = (*t.mutable_m_fixed64())[u64] = inner;
-    (*t.mutable_m_bool())[b] = inner;
-    (*t.mutable_m_string())[s] = inner;
-    (*t.mutable_m_string())[s + std::string(1 << (u32 % static_cast<uint32>(9)),
-                                            b)] = inner;
-    inner.mutable_m()->erase(i);
-    frog = frog * multiplier + i;
-    frog ^= (frog >> 41);
-  }
-
-  // Verifies if two consecutive calls to deterministic serialization produce
-  // the same bytes. Deterministic serialization means the same serialization
-  // bytes in the same binary.
-  const std::string s1 = DeterministicSerialization(t);
-  const std::string s2 = DeterministicSerialization(t);
-  EXPECT_EQ(s1, s2);
-
-  protobuf_unittest::TestMaps u;
-  EXPECT_TRUE(u.ParseFromString(s1));
-  EXPECT_TRUE(util::MessageDifferencer::Equals(u, t));
-}
-
-TEST(MapSerializationTest, DeterministicSubmessage) {
-  protobuf_unittest::TestSubmessageMaps p;
-  protobuf_unittest::TestMaps t;
-  const std::string filename = "golden_message_maps";
-  std::string golden;
-  GOOGLE_CHECK_OK(File::GetContents(
-      TestUtil::GetTestDataPath("net/proto2/internal/testdata/" + filename),
-      &golden, true));
-  t.ParseFromString(golden);
-  *(p.mutable_m()) = t;
-  std::vector<std::string> v;
-  // Use multiple attempts to increase the chance of a failure if something is
-  // buggy.  For example, each separate copy of a map might use a different
-  // randomly-chosen hash function.
-  const int kAttempts = 10;
-  for (int i = 0; i < kAttempts; i++) {
-    protobuf_unittest::TestSubmessageMaps q(p);
-    ASSERT_EQ(DeterministicSerialization(q), DeterministicSerialization(p));
-  }
-}
-
-// Text Format Test =================================================
-
-TEST(TextFormatMapTest, SerializeAndParse) {
-  unittest::TestMap source;
-  unittest::TestMap dest;
-  MapTestUtil::SetMapFields(&source);
-  std::string output;
-
-  // Test compact ASCII
-  TextFormat::Printer printer;
-  printer.PrintToString(source, &output);
-  TextFormat::Parser parser;
-  EXPECT_TRUE(parser.ParseFromString(output, &dest));
-  MapTestUtil::ExpectMapFieldsSet(dest);
-}
-
-TEST(TextFormatMapTest, DynamicMessage) {
-  TestMap prototype;
-  DynamicMessageFactory factory;
-  std::unique_ptr<Message> message(
-      factory.GetPrototype(prototype.GetDescriptor())->New());
-  MapReflectionTester tester(message->GetDescriptor());
-  tester.SetMapFieldsViaReflection(message.get());
-
-  std::string expected_text;
-  GOOGLE_CHECK_OK(
-      File::GetContents(TestUtil::GetTestDataPath("net/proto2/internal/"
-                                                  "testdata/map_test_data.txt"),
-                        &expected_text, true));
-
-  CleanStringLineEndings(&expected_text, false);
-  EXPECT_EQ(message->DebugString(), expected_text);
-}
-
-TEST(TextFormatMapTest, Sorted) {
-  unittest::TestMap message;
-  MapReflectionTester tester(message.GetDescriptor());
-  tester.SetMapFieldsViaReflection(&message);
-
-  std::string expected_text;
-  GOOGLE_CHECK_OK(
-      File::GetContents(TestUtil::GetTestDataPath("net/proto2/internal/"
-                                                  "testdata/map_test_data.txt"),
-                        &expected_text, true));
-
-  CleanStringLineEndings(&expected_text, false);
-  EXPECT_EQ(message.DebugString(), expected_text);
-
-  // Test again on the reverse order.
-  unittest::TestMap message2;
-  tester.SetMapFieldsViaReflection(&message2);
-  tester.SwapMapsViaReflection(&message2);
-  EXPECT_EQ(message2.DebugString(), expected_text);
-}
-
-TEST(TextFormatMapTest, ParseCorruptedString) {
-  std::string serialized_message;
-  GOOGLE_CHECK_OK(
-      File::GetContents(TestUtil::GetTestDataPath(
-                            "net/proto2/internal/testdata/golden_message_maps"),
-                        &serialized_message, true));
-  protobuf_unittest::TestMaps message;
-  GOOGLE_CHECK(message.ParseFromString(serialized_message));
-  TestParseCorruptedString<protobuf_unittest::TestMaps, true>(message);
-  TestParseCorruptedString<protobuf_unittest::TestMaps, false>(message);
-}
-
-// Previously, serializing to text format will disable iterator from generated
-// API. Now, the iterator can be still used even after serializing to text
-// format.
-TEST(TextFormatMapTest, NoDisableIterator) {
-  unittest::TestMap source;
-  (*source.mutable_map_int32_int32())[1] = 1;
-
-  // Get iterator.
-  Map<int32, int32>::iterator iter = source.mutable_map_int32_int32()->find(1);
-
-  // Serialize message to text format, which will invalidate the previous
-  // iterator previously.
-  std::string output;
-  TextFormat::Printer printer;
-  printer.PrintToString(source, &output);
-
-  // Modify map via the iterator (invalidated in previous implementation.).
-  iter->second = 2;
-
-  // In previous implementation, the new change won't be reflected in text
-  // format, because the previous iterator has been invalidated.
-  output.clear();
-  printer.PrintToString(source, &output);
-  std::string expected =
-      "map_int32_int32 {\n"
-      "  key: 1\n"
-      "  value: 2\n"
-      "}\n";
-  EXPECT_EQ(output, expected);
-}
-
-// Previously, serializing to text format will disable iterator from reflection
-// API.
-TEST(TextFormatMapTest, NoDisableReflectionIterator) {
-  unittest::TestMap source;
-  (*source.mutable_map_int32_int32())[1] = 1;
-
-  // Get iterator. This will also sync internal repeated field with map inside
-  // of MapField.
-  const Reflection* reflection = source.GetReflection();
-  const FieldDescriptor* field_desc =
-      source.GetDescriptor()->FindFieldByName("map_int32_int32");
-  RepeatedPtrField<Message>* map_field =
-      reflection->MutableRepeatedPtrField<Message>(&source, field_desc);
-  RepeatedPtrField<Message>::iterator iter = map_field->begin();
-
-  // Serialize message to text format, which will invalidate the previous
-  // iterator previously.
-  std::string output;
-  TextFormat::Printer printer;
-  printer.PrintToString(source, &output);
-
-  // Modify map via the iterator (invalidated in previous implementation.).
-  const Reflection* map_entry_reflection = iter->GetReflection();
-  const FieldDescriptor* value_field_desc =
-      iter->GetDescriptor()->FindFieldByName("value");
-  map_entry_reflection->SetInt32(&(*iter), value_field_desc, 2);
-  GOOGLE_LOG(INFO) << iter->DebugString();
-
-  // In previous implementation, the new change won't be reflected in text
-  // format, because the previous iterator has been invalidated.
-  output.clear();
-  printer.PrintToString(source, &output);
-  std::string expected =
-      "map_int32_int32 {\n"
-      "  key: 1\n"
-      "  value: 2\n"
-      "}\n";
-  EXPECT_EQ(output, expected);
-}
-
-
-// arena support =================================================
-TEST(ArenaTest, ParsingAndSerializingNoHeapAllocation) {
-  // Allocate a large initial block to avoid mallocs during hooked test.
-  std::vector<char> arena_block(128 * 1024);
-  ArenaOptions options;
-  options.initial_block = &arena_block[0];
-  options.initial_block_size = arena_block.size();
-  Arena arena(options);
-  std::string data;
-  data.reserve(128 * 1024);
-
-  {
-    // TODO(teboring): Enable no heap check when ArenaStringPtr is used in map.
-    // NoHeapChecker no_heap;
-
-    unittest::TestArenaMap* from =
-        Arena::CreateMessage<unittest::TestArenaMap>(&arena);
-    MapTestUtil::SetArenaMapFields(from);
-    from->SerializeToString(&data);
-
-    unittest::TestArenaMap* to =
-        Arena::CreateMessage<unittest::TestArenaMap>(&arena);
-    to->ParseFromString(data);
-    MapTestUtil::ExpectArenaMapFieldsSet(*to);
-  }
-}
-
-// Use text format parsing and serializing to test reflection api.
-TEST(ArenaTest, ReflectionInTextFormat) {
-  Arena arena;
-  std::string data;
-
-  TextFormat::Printer printer;
-  TextFormat::Parser parser;
-
-  unittest::TestArenaMap* from =
-      Arena::CreateMessage<unittest::TestArenaMap>(&arena);
-  unittest::TestArenaMap* to =
-      Arena::CreateMessage<unittest::TestArenaMap>(&arena);
-
-  MapTestUtil::SetArenaMapFields(from);
-  printer.PrintToString(*from, &data);
-
-  EXPECT_TRUE(parser.ParseFromString(data, to));
-  MapTestUtil::ExpectArenaMapFieldsSet(*to);
-}
-
-// Make sure the memory allocated for string in map is deallocated.
-TEST(ArenaTest, StringMapNoLeak) {
-  Arena arena;
-  unittest::TestArenaMap* message =
-      Arena::CreateMessage<unittest::TestArenaMap>(&arena);
-  std::string data;
-  // String with length less than 16 will not be allocated from heap.
-  int original_capacity = data.capacity();
-  while (data.capacity() <= original_capacity) {
-    data.append("a");
-  }
-  (*message->mutable_map_string_string())[data] = data;
-  // We rely on heap checkers to detect memory leak for us.
-  ASSERT_FALSE(message == NULL);
-}
-
-TEST(ArenaTest, IsInitialized) {
-  // Allocate a large initial polluted block.
-  std::vector<char> arena_block(128 * 1024);
-  std::fill(arena_block.begin(), arena_block.end(), '\xff');
-
-  ArenaOptions options;
-  options.initial_block = &arena_block[0];
-  options.initial_block_size = arena_block.size();
-  Arena arena(options);
-
-  unittest::TestArenaMap* message =
-      Arena::CreateMessage<unittest::TestArenaMap>(&arena);
-  EXPECT_EQ(0, (*message->mutable_map_int32_int32())[0]);
-}
-
-TEST(ArenaTest, DynamicMapFieldOnArena) {
-  Arena arena;
-  unittest::TestMap message2;
-
-  DynamicMessageFactory factory;
-  Message* message1 =
-      factory.GetPrototype(unittest::TestMap::descriptor())->New(&arena);
-  MapReflectionTester reflection_tester(unittest::TestMap::descriptor());
-  reflection_tester.SetMapFieldsViaReflection(message1);
-  reflection_tester.ExpectMapFieldsSetViaReflection(*message1);
-  reflection_tester.ExpectMapFieldsSetViaReflectionIterator(message1);
-  message2.CopyFrom(*message1);
-  MapTestUtil::ExpectMapFieldsSet(message2);
-}
-
-TEST(ArenaTest, DynamicMapFieldOnArenaMemoryLeak) {
-  auto* desc = unittest::TestMap::descriptor();
-  auto* field = desc->FindFieldByName("map_int32_int32");
-
-  Arena arena;
-  DynamicMessageFactory factory;
-  auto* message = factory.GetPrototype(desc)->New(&arena);
-  auto* reflection = message->GetReflection();
-  reflection->AddMessage(message, field);
-
-  // Force internal syncing, which initializes the mutex.
-  MapReflectionTester reflection_tester(unittest::TestMap::descriptor());
-  int size = reflection_tester.MapSize(*message, "map_int32_int32");
-  EXPECT_EQ(size, 1);
-}
-
-TEST(MoveTest, MoveConstructorWorks) {
-  Map<int32, TestAllTypes> original_map;
-  original_map[42].mutable_optional_nested_message()->set_bb(42);
-  original_map[43].mutable_optional_nested_message()->set_bb(43);
-  const auto* nested_msg42_ptr = &original_map[42].optional_nested_message();
-  const auto* nested_msg43_ptr = &original_map[43].optional_nested_message();
-
-  Map<int32, TestAllTypes> moved_to_map(std::move(original_map));
-  EXPECT_TRUE(original_map.empty());
-  EXPECT_EQ(2, moved_to_map.size());
-  EXPECT_EQ(42, moved_to_map[42].optional_nested_message().bb());
-  EXPECT_EQ(43, moved_to_map[43].optional_nested_message().bb());
-  // This test takes advantage of the fact that pointers are swapped, so there
-  // should be pointer stability.
-  EXPECT_EQ(nested_msg42_ptr, &moved_to_map[42].optional_nested_message());
-  EXPECT_EQ(nested_msg43_ptr, &moved_to_map[43].optional_nested_message());
-}
-
-TEST(MoveTest, MoveAssignmentWorks) {
-  Map<int32, TestAllTypes> original_map;
-  original_map[42].mutable_optional_nested_message()->set_bb(42);
-  original_map[43].mutable_optional_nested_message()->set_bb(43);
-  const auto* nested_msg42_ptr = &original_map[42].optional_nested_message();
-  const auto* nested_msg43_ptr = &original_map[43].optional_nested_message();
-
-  Map<int32, TestAllTypes> moved_to_map = std::move(original_map);
-  EXPECT_TRUE(original_map.empty());
-  EXPECT_EQ(2, moved_to_map.size());
-  EXPECT_EQ(42, moved_to_map[42].optional_nested_message().bb());
-  EXPECT_EQ(43, moved_to_map[43].optional_nested_message().bb());
-  // This test takes advantage of the fact that pointers are swapped, so there
-  // should be pointer stability.
-  EXPECT_EQ(nested_msg42_ptr, &moved_to_map[42].optional_nested_message());
-  EXPECT_EQ(nested_msg43_ptr, &moved_to_map[43].optional_nested_message());
-}
+  constexpr size_t align_mask = alignof(Aligned) - 1;
+  Map<int, Aligned> map(on_arena ? &arena : nullptr);
+  map.insert({1, Aligned{}});
+  auto it = map.find(1);
+  ASSERT_NE(it, map.end());
+  ASSERT_EQ(reinterpret_cast<intptr_t>(&it->second) & align_mask, 0);
+  map.clear();
+}
+
+TEST(MapTest, Aligned) { MapTest_Aligned<AlignedAsDefault>(); }
+TEST(MapTest, AlignedOnArena) { MapTest_Aligned<AlignedAsDefault, true>(); }
+TEST(MapTest, Aligned8) { MapTest_Aligned<AlignedAs8>(); }
+TEST(MapTest, Aligned8OnArena) { MapTest_Aligned<AlignedAs8, true>(); }
 
 
 }  // namespace
diff --git protobuf-3.17.3protobuf-3.17.3-patched/src/google/protobuf/map_test.inc protobuf-3.17.3-patchedprotobuf-3.17.3-patched/src/google/protobuf/map_test.inc
new file mode 100644
index 0000000..1f13106
--- /dev/null
+++ protobuf-3.17.3-patchedprotobuf-3.17.3-patched/src/google/protobuf/map_test.inc
@@ -0,0 +1,3879 @@
+// Protocol Buffers - Google's data interchange format
+// Copyright 2008 Google Inc.  All rights reserved.
+// https://developers.google.com/protocol-buffers/
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// A hack to include windows.h first, which ensures the GetMessage macro can
+// be undefined when we include <google/protobuf/stubs/common.h>
+#if defined(_MSC_VER)
+#define _WINSOCKAPI_  // to avoid re-definition in WinSock2.h
+#define NOMINMAX      // to avoid defining min/max macros
+#include <windows.h>
+#endif  // _WIN32
+
+#include <algorithm>
+#include <map>
+#include <memory>
+#include <random>
+#include <set>
+#include <sstream>
+#include <unordered_map>
+#include <unordered_set>
+#include <vector>
+
+#include <google/protobuf/stubs/logging.h>
+#include <google/protobuf/stubs/common.h>
+#include <google/protobuf/testing/file.h>
+#include <google/protobuf/arena_test_util.h>
+#include <google/protobuf/test_util2.h>
+#include <google/protobuf/io/coded_stream.h>
+#include <google/protobuf/io/tokenizer.h>
+#include <google/protobuf/io/zero_copy_stream_impl.h>
+#include <google/protobuf/descriptor.pb.h>
+#include <google/protobuf/descriptor.h>
+#include <google/protobuf/descriptor_database.h>
+#include <google/protobuf/dynamic_message.h>
+#include <google/protobuf/map.h>
+#include <google/protobuf/map_field_inl.h>
+#include <google/protobuf/message.h>
+#include <google/protobuf/reflection.h>
+#include <google/protobuf/reflection_ops.h>
+#include <google/protobuf/text_format.h>
+#include <google/protobuf/wire_format.h>
+#include <google/protobuf/util/message_differencer.h>
+#include <google/protobuf/util/time_util.h>
+#include <gmock/gmock.h>
+#include <google/protobuf/testing/googletest.h>
+#include <gtest/gtest.h>
+#include <google/protobuf/stubs/casts.h>
+#include <google/protobuf/stubs/substitute.h>
+
+
+// Must be included last.
+#include <google/protobuf/port_def.inc>
+
+namespace google {
+namespace protobuf {
+
+using UNITTEST::ForeignMessage;
+using UNITTEST::TestAllTypes;
+using UNITTEST::TestMap;
+using UNITTEST::TestRecursiveMapMessage;
+
+namespace internal {
+
+void MapTestForceDeterministic() {
+  io::CodedOutputStream::SetDefaultSerializationDeterministic();
+}
+
+namespace {
+
+// Map API Test =====================================================
+
+class MapImplTest : public ::testing::Test {
+ protected:
+  MapImplTest()
+      : map_ptr_(new Map<int32_t, int32_t>()),
+        map_(*map_ptr_),
+        const_map_(*map_ptr_) {
+    EXPECT_TRUE(map_.empty());
+    EXPECT_EQ(0, map_.size());
+  }
+
+  void ExpectSingleElement(int32_t key, int32_t value) {
+    EXPECT_FALSE(map_.empty());
+    EXPECT_EQ(1, map_.size());
+    ExpectElement(key, value);
+  }
+
+  void ExpectElements(const std::map<int32_t, int32_t>& map) {
+    EXPECT_FALSE(map_.empty());
+    EXPECT_EQ(map.size(), map_.size());
+    for (std::map<int32_t, int32_t>::const_iterator it = map.begin();
+         it != map.end(); ++it) {
+      ExpectElement(it->first, it->second);
+    }
+  }
+
+  void ExpectElement(int32_t key, int32_t value) {
+    // Test map size is correct.
+    EXPECT_EQ(value, map_[key]);
+    EXPECT_EQ(1, map_.count(key));
+    EXPECT_TRUE(map_.contains(key));
+
+    // Check mutable at and find work correctly.
+    EXPECT_EQ(value, map_.at(key));
+    Map<int32_t, int32_t>::iterator it = map_.find(key);
+
+    // iterator dereferenceable
+    EXPECT_EQ(key, (*it).first);
+    EXPECT_EQ(value, (*it).second);
+    EXPECT_EQ(key, it->first);
+    EXPECT_EQ(value, it->second);
+
+    // iterator mutable
+    ((*it).second) = value + 1;
+    EXPECT_EQ(value + 1, map_[key]);
+    ((*it).second) = value;
+    EXPECT_EQ(value, map_[key]);
+
+    it->second = value + 1;
+    EXPECT_EQ(value + 1, map_[key]);
+    it->second = value;
+    EXPECT_EQ(value, map_[key]);
+
+    // copy constructor
+    Map<int32_t, int32_t>::iterator it_copy = it;
+    EXPECT_EQ(key, it_copy->first);
+    EXPECT_EQ(value, it_copy->second);
+
+    // Immutable API ================================================
+
+    // Check immutable at and find work correctly.
+    EXPECT_EQ(value, const_map_.at(key));
+    Map<int32_t, int32_t>::const_iterator const_it = const_map_.find(key);
+
+    // iterator dereferenceable
+    EXPECT_EQ(key, (*const_it).first);
+    EXPECT_EQ(value, (*const_it).second);
+    EXPECT_EQ(key, const_it->first);
+    EXPECT_EQ(value, const_it->second);
+
+    // copy constructor
+    Map<int32_t, int32_t>::const_iterator const_it_copy = const_it;
+    EXPECT_EQ(key, const_it_copy->first);
+    EXPECT_EQ(value, const_it_copy->second);
+  }
+
+  std::unique_ptr<Map<int32_t, int32_t>> map_ptr_;
+  Map<int32_t, int32_t>& map_;
+  const Map<int32_t, int32_t>& const_map_;
+};
+
+TEST_F(MapImplTest, OperatorBracket) {
+  int32_t key = 0;
+  int32_t value1 = 100;
+  int32_t value2 = 101;
+
+  EXPECT_EQ(0, map_[key]);
+
+  map_[key] = value1;
+  ExpectSingleElement(key, value1);
+
+  map_[key] = value2;
+  ExpectSingleElement(key, value2);
+}
+
+struct MoveTestKey {
+  MoveTestKey(int data, int* copies) : data(data), copies(copies) {}
+
+  MoveTestKey(const MoveTestKey& other)
+      : data(other.data), copies(other.copies) {
+    ++*copies;
+  }
+
+  MoveTestKey(MoveTestKey&& other) noexcept
+      : data(other.data), copies(other.copies) {}
+
+  friend bool operator==(const MoveTestKey& lhs, const MoveTestKey& rhs) {
+    return lhs.data == rhs.data;
+  }
+  friend bool operator<(const MoveTestKey& lhs, const MoveTestKey& rhs) {
+    return lhs.data < rhs.data;
+  }
+
+  int data;
+  int* copies;
+};
+
+}  // namespace
+}  // namespace internal
+}  // namespace protobuf
+}  // namespace google
+
+namespace std {
+
+template <>  // NOLINT
+struct hash<google::protobuf::internal::MoveTestKey> {
+  size_t operator()(const google::protobuf::internal::MoveTestKey& key) const {
+    return hash<int>{}(key.data);
+  }
+};
+}  // namespace std
+
+namespace google {
+namespace protobuf {
+namespace internal {
+namespace {
+
+TEST_F(MapImplTest, OperatorBracketRValue) {
+  Arena arena;
+  for (Arena* arena_to_use : {&arena, static_cast<Arena*>(nullptr)}) {
+    int copies = 0;
+    Map<MoveTestKey, int> map(arena_to_use);
+    MoveTestKey key1(1, &copies);
+    EXPECT_EQ(copies, 0);
+    map[key1] = 0;
+    EXPECT_EQ(copies, 1);
+    map[MoveTestKey(2, &copies)] = 2;
+    EXPECT_EQ(copies, 1);
+  }
+}
+
+TEST_F(MapImplTest, OperatorBracketNonExist) {
+  int32_t key = 0;
+  int32_t default_value = 0;
+
+  EXPECT_EQ(default_value, map_[key]);
+  ExpectSingleElement(key, default_value);
+}
+
+TEST_F(MapImplTest, MutableAt) {
+  int32_t key = 0;
+  int32_t value1 = 100;
+  int32_t value2 = 101;
+
+  map_[key] = value1;
+  ExpectSingleElement(key, value1);
+
+  map_.at(key) = value2;
+  ExpectSingleElement(key, value2);
+}
+
+#ifdef PROTOBUF_HAS_DEATH_TEST
+
+TEST_F(MapImplTest, MutableAtNonExistDeathTest) {
+  EXPECT_DEATH(map_.at(0), "");
+}
+
+TEST_F(MapImplTest, ImmutableAtNonExistDeathTest) {
+  EXPECT_DEATH(const_map_.at(0), "");
+}
+
+TEST_F(MapImplTest, UsageErrors) {
+  MapKey key;
+  key.SetInt64Value(1);
+  EXPECT_DEATH(key.GetUInt64Value(),
+               "Protocol Buffer map usage error:\n"
+               "MapKey::GetUInt64Value type does not match\n"
+               "  Expected : uint64\n"
+               "  Actual   : int64");
+
+  MapValueRef value;
+  EXPECT_DEATH(
+      value.SetFloatValue(0.1),
+      "Protocol Buffer map usage error:\n"
+      "MapValue[Const]*Ref::type MapValue[Const]*Ref is not initialized.");
+}
+
+#endif  // PROTOBUF_HAS_DEATH_TEST
+
+TEST_F(MapImplTest, MapKeyAssignment) {
+  MapKey from, to;
+  from.SetStringValue("abc");
+  to = from;
+  EXPECT_EQ("abc", to.GetStringValue());
+}
+
+TEST_F(MapImplTest, CountNonExist) { EXPECT_EQ(0, map_.count(0)); }
+
+TEST_F(MapImplTest, ContainNotExist) { EXPECT_FALSE(map_.contains(0)); }
+
+TEST_F(MapImplTest, ImmutableContainNotExist) {
+  EXPECT_FALSE(const_map_.contains(0));
+}
+
+TEST_F(MapImplTest, MutableFindNonExist) {
+  EXPECT_TRUE(map_.end() == map_.find(0));
+}
+
+TEST_F(MapImplTest, ImmutableFindNonExist) {
+  EXPECT_TRUE(const_map_.end() == const_map_.find(0));
+}
+
+TEST_F(MapImplTest, ConstEnd) {
+  EXPECT_TRUE(const_map_.end() == const_map_.cend());
+}
+
+TEST_F(MapImplTest, GetReferenceFromIterator) {
+  for (int i = 0; i < 10; i++) {
+    map_[i] = i;
+  }
+
+  for (Map<int32_t, int32_t>::const_iterator it = map_.cbegin();
+       it != map_.cend();) {
+    Map<int32_t, int32_t>::const_reference entry = *it++;
+    EXPECT_EQ(entry.first, entry.second);
+  }
+
+  for (Map<int32_t, int32_t>::const_iterator it = const_map_.begin();
+       it != const_map_.end();) {
+    Map<int32_t, int32_t>::const_reference entry = *it++;
+    EXPECT_EQ(entry.first, entry.second);
+  }
+
+  for (Map<int32_t, int32_t>::iterator it = map_.begin(); it != map_.end();) {
+    Map<int32_t, int32_t>::reference entry = *it++;
+    EXPECT_EQ(entry.first + 1, ++entry.second);
+  }
+}
+
+TEST_F(MapImplTest, IteratorBasic) {
+  map_[0] = 0;
+
+  // Default constructible (per forward iterator requirements).
+  Map<int, int>::const_iterator cit;
+  Map<int, int>::iterator it;
+
+  it = map_.begin();
+  cit = it;  // Converts to const_iterator
+
+  // Can compare between them.
+  EXPECT_TRUE(it == cit);
+  EXPECT_FALSE(cit != it);
+
+  // Pre increment.
+  EXPECT_FALSE(it == ++cit);
+
+  // Post increment.
+  EXPECT_FALSE(it++ == cit);
+  EXPECT_TRUE(it == cit);
+}
+
+template <typename Iterator>
+static int64_t median(Iterator i0, Iterator i1) {
+  std::vector<int64_t> v(i0, i1);
+  std::nth_element(v.begin(), v.begin() + v.size() / 2, v.end());
+  return v[v.size() / 2];
+}
+
+static int64_t Now() {
+  return util::TimeUtil::TimestampToNanoseconds(
+      util::TimeUtil::GetCurrentTime());
+}
+
+// Arbitrary odd integers for creating test data.
+static int k0 = 812398771;
+static int k1 = 1312938717;
+static int k2 = 1321555333;
+
+// A naive begin() implementation will cause begin() to get slower and slower
+// if one erases elements at the "front" of the hash map, and we'd like to
+// avoid that, as std::unordered_map does.
+TEST_F(MapImplTest, BeginIsFast) {
+  if (true) return;  // TODO(gpike): make this less flaky and re-enable it.
+  Map<int32_t, int32_t> map;
+  const int kTestSize = 250000;
+  // Create a random-looking map of size n.  Use non-negative integer keys.
+  uint32_t frog = 123983;
+  int last_key = 0;
+  int counter = 0;
+  while (map.size() < kTestSize) {
+    frog *= static_cast<uint32_t>(k0);
+    frog ^= frog >> 17;
+    frog += counter++;
+    last_key =
+        static_cast<int>(frog) >= 0 ? static_cast<int>(frog) : last_key ^ 1;
+    GOOGLE_DCHECK_GE(last_key, 0);
+    map[last_key] = last_key ^ 1;
+  }
+  std::vector<int64_t> times;
+  // We're going to do map.erase(map.begin()) over and over again.  But,
+  // just in case one iteration is fast compared to the granularity of
+  // our time keeping, we measure kChunkSize iterations per outer-loop iter.
+  const int kChunkSize = 1000;
+  GOOGLE_CHECK_EQ(kTestSize % kChunkSize, 0);
+  do {
+    const int64_t start = Now();
+    for (int i = 0; i < kChunkSize; i++) {
+      map.erase(map.begin());
+    }
+    const int64_t end = Now();
+    if (end > start) {
+      times.push_back(end - start);
+    }
+  } while (!map.empty());
+  if (times.size() < .99 * kTestSize / kChunkSize) {
+    GOOGLE_LOG(WARNING) << "Now() isn't helping us measure time";
+    return;
+  }
+  int64_t x0 = median(times.begin(), times.begin() + 9);
+  int64_t x1 = median(times.begin() + times.size() - 9, times.end());
+  GOOGLE_LOG(INFO) << "x0=" << x0 << ", x1=" << x1;
+  // x1 will greatly exceed x0 if the code we just executed took O(n^2) time.
+  // And we'll probably time out and never get here.  So, this test is
+  // intentionally loose: we check that x0 and x1 are within a factor of 8.
+  EXPECT_GE(x1, x0 / 8);
+  EXPECT_GE(x0, x1 / 8);
+}
+
+// Try to create kTestSize keys that will land in just a few buckets, and
+// time the insertions, to get a rough estimate of whether an O(n^2) worst case
+// was triggered.  This test is a hacky, but probably better than nothing.
+TEST_F(MapImplTest, HashFlood) {
+  const int kTestSize = 1024;  // must be a power of 2
+  std::set<int> s;
+  for (int i = 0; s.size() < kTestSize; i++) {
+    if ((map_.hash_function()(i) & (kTestSize - 1)) < 3) {
+      s.insert(i);
+    }
+  }
+  // Create hash table with kTestSize entries that hash flood a table with
+  // 1024 (or 512 or 2048 or ...) entries.  This assumes that map_ uses powers
+  // of 2 for table sizes, and that it's sufficient to "flood" with respect to
+  // the low bits of the output of map_.hash_function().
+  std::vector<int64_t> times;
+  std::set<int>::iterator it = s.begin();
+  int count = 0;
+  do {
+    const int64_t start = Now();
+    map_[*it] = 0;
+    const int64_t end = Now();
+    if (end > start) {
+      times.push_back(end - start);
+    }
+    ++count;
+    ++it;
+  } while (it != s.end());
+  if (times.size() < .99 * count) return;
+  int64_t x0 = median(times.begin(), times.begin() + 9);
+  int64_t x1 = median(times.begin() + times.size() - 9, times.end());
+  // x1 will greatly exceed x0 if the code we just executed took O(n^2) time.
+  // But we want to allow O(n log n).  A factor of 20 should be generous enough.
+  EXPECT_LE(x1, x0 * 20);
+}
+
+TEST_F(MapImplTest, CopyIteratorStressTest) {
+  std::vector<Map<int32_t, int32_t>::iterator> v;
+  const int kIters = 1e5;
+  for (uint32_t i = 0; i < kIters; i++) {
+    int32_t key = (3 + i * (5 + i * (-8 + i * (62 + i)))) & 0x77777777;
+    map_[key] = i;
+    v.push_back(map_.find(key));
+  }
+  for (std::vector<Map<int32_t, int32_t>::iterator>::const_iterator it =
+           v.begin();
+       it != v.end(); it++) {
+    Map<int32_t, int32_t>::iterator i = *it;
+    ASSERT_EQ(i->first, (*it)->first);
+    ASSERT_EQ(i->second, (*it)->second);
+  }
+}
+
+template <typename T, typename U>
+static void TestValidityForAllKeysExcept(int key_to_avoid, const T& check_map,
+                                         const U& map) {
+  typedef typename U::value_type value_type;  // a key-value pair
+  for (typename U::const_iterator it = map.begin(); it != map.end(); ++it) {
+    const int key = it->first;
+    if (key == key_to_avoid) continue;
+    // All iterators relevant to this key, whether old (from check_map) or new,
+    // must point to the same memory.  So, test pointer equality here.
+    const value_type* check_val = &*check_map.find(key)->second;
+    EXPECT_EQ(check_val, &*it);
+    EXPECT_EQ(check_val, &*map.find(key));
+  }
+}
+
+// EXPECT i0 and i1 to be the same.  Advancing them should have the same effect,
+// too.
+template <typename Iter>
+static void TestEqualIterators(Iter i0, Iter i1, Iter end) {
+  const int kMaxAdvance = 10;
+  for (int i = 0; i < kMaxAdvance; i++) {
+    EXPECT_EQ(i0 == end, i1 == end);
+    if (i0 == end) return;
+    EXPECT_EQ(&*i0, &*i1) << "iter " << i;
+    ++i0;
+    ++i1;
+  }
+}
+
+template <typename IteratorType>
+static void TestOldVersusNewIterator(int skip, Map<int, int>* m) {
+  const int initial_size = m->size();
+  IteratorType it = m->begin();
+  for (int i = 0; i < skip && it != m->end(); it++, i++) {
+  }
+  if (it == m->end()) return;
+  const IteratorType old = it;
+  GOOGLE_LOG(INFO) << "skip=" << skip << ", old->first=" << old->first;
+  const int target_size =
+      initial_size < 100 ? initial_size * 5 : initial_size * 5 / 4;
+  for (int i = 0; m->size() <= target_size; i++) {
+    (*m)[i] = 0;
+  }
+  // Iterator 'old' should still work just fine despite the growth of *m.
+  const IteratorType after_growth = m->find(old->first);
+  TestEqualIterators<IteratorType>(old, after_growth, m->end());
+
+  // Now shrink the number of elements.  Do this with a mix of erases and
+  // inserts to increase the chance that the hashtable will resize to a lower
+  // number of buckets.  (But, in any case, the test is still useful.)
+  for (int i = 0; i < 2 * (target_size - initial_size); i++) {
+    if (i != old->first) {
+      m->erase(i);
+    }
+    if (((i ^ m->begin()->first) & 15) == 0) {
+      (*m)[i * 342] = i;
+    }
+  }
+  // Now, the table has grown and shrunk; test again.
+  TestEqualIterators<IteratorType>(old, m->find(old->first), m->end());
+  TestEqualIterators<IteratorType>(old, after_growth, m->end());
+}
+
+// Create and test an n-element Map, with emphasis on iterator correctness.
+static void StressTestIterators(int n) {
+  GOOGLE_LOG(INFO) << "StressTestIterators " << n;
+  GOOGLE_CHECK_GT(n, 0);
+  // Create a random-looking map of size n.  Use non-negative integer keys.
+  Map<int, int> m;
+  uint32_t frog = 123987 + n;
+  int last_key = 0;
+  int counter = 0;
+  while (m.size() < n) {
+    frog *= static_cast<uint32_t>(k0);
+    frog ^= frog >> 17;
+    frog += counter++;
+    last_key =
+        static_cast<int>(frog) >= 0 ? static_cast<int>(frog) : last_key ^ 1;
+    GOOGLE_DCHECK_GE(last_key, 0);
+    m[last_key] = last_key ^ 1;
+  }
+  // Test it.
+  ASSERT_EQ(n, m.size());
+  // Create maps of pointers and iterators.
+  // These should remain valid even if we modify m.
+  std::unordered_map<int, Map<int, int>::value_type*> mp(n);
+  std::unordered_map<int, Map<int, int>::iterator> mi(n);
+  for (Map<int, int>::iterator it = m.begin(); it != m.end(); ++it) {
+    mp[it->first] = &*it;
+    mi[it->first] = it;
+  }
+  ASSERT_EQ(m.size(), mi.size());
+  ASSERT_EQ(m.size(), mp.size());
+  m.erase(last_key);
+  ASSERT_EQ(n - 1, m.size());
+  TestValidityForAllKeysExcept(last_key, mp, m);
+  TestValidityForAllKeysExcept(last_key, mi, m);
+
+  m[last_key] = 0;
+  ASSERT_EQ(n, m.size());
+  // Test old iterator vs new iterator, with table modification in between.
+  TestOldVersusNewIterator<Map<int, int>::const_iterator>(n % 3, &m);
+  TestOldVersusNewIterator<Map<int, int>::iterator>(n % (1 + (n / 40)), &m);
+  // Finally, ensure erase(iterator) doesn't reorder anything, because that is
+  // what its documentation says.
+  m[last_key] = m[last_key ^ 999] = 0;
+  std::vector<Map<int, int>::iterator> v;
+  v.reserve(m.size());
+  int position_of_last_key = 0;
+  for (Map<int, int>::iterator it = m.begin(); it != m.end(); ++it) {
+    if (it->first == last_key) {
+      position_of_last_key = v.size();
+    }
+    v.push_back(it);
+  }
+  ASSERT_EQ(m.size(), v.size());
+  const Map<int, int>::iterator erase_result = m.erase(m.find(last_key));
+  int index = 0;
+  for (Map<int, int>::iterator it = m.begin(); it != m.end(); ++it, ++index) {
+    if (index == position_of_last_key) {
+      EXPECT_EQ(&*erase_result, &*v[++index]);
+    }
+    ASSERT_EQ(&*it, &*v[index]);
+  }
+}
+
+TEST_F(MapImplTest, IteratorInvalidation) {
+  // Create a set of pseudo-random sizes to test.
+#ifndef NDEBUG
+  const int kMaxSizeToTest = 100 * 1000;
+#else
+  const int kMaxSizeToTest = 1000 * 1000;
+#endif
+  std::set<int> s;
+  int n = kMaxSizeToTest;
+  unsigned int frog = k1 + n;
+  while (n > 1 && s.size() < 25) {
+    s.insert(n);
+    n = static_cast<int>(n * 100 / (101.0 + (frog & 63)));
+    frog *= k2;
+    frog ^= frog >> 17;
+  }
+  // Ensure we test a few small sizes.
+  s.insert(1);
+  s.insert(2);
+  s.insert(3);
+  // Now, the real work.
+  for (std::set<int>::iterator i = s.begin(); i != s.end(); ++i) {
+    StressTestIterators(*i);
+  }
+}
+
+// Test that erase() revalidates iterators.
+TEST_F(MapImplTest, EraseRevalidates) {
+  map_[3] = map_[13] = map_[20] = 0;
+  const int initial_size = map_.size();
+  EXPECT_EQ(3, initial_size);
+  std::vector<Map<int, int>::iterator> v;
+  for (Map<int, int>::iterator it = map_.begin(); it != map_.end(); ++it) {
+    v.push_back(it);
+  }
+  EXPECT_EQ(initial_size, v.size());
+  for (int i = 0; map_.size() <= initial_size * 20; i++) {
+    map_[i] = 0;
+  }
+  const int larger_size = map_.size();
+  // We've greatly increased the size of the map, so it is highly likely that
+  // the following will corrupt m if erase() doesn't properly revalidate
+  // iterators passed to it.  Finishing this routine without crashing indicates
+  // success.
+  for (int i = 0; i < v.size(); i++) {
+    map_.erase(v[i]);
+  }
+  EXPECT_EQ(larger_size - v.size(), map_.size());
+}
+
+template <typename T>
+bool IsConstHelper(T& /*t*/) {  // NOLINT. We want to catch non-const refs here.
+  return false;
+}
+template <typename T>
+bool IsConstHelper(const T& /*t*/) {
+  return true;
+}
+
+TEST_F(MapImplTest, IteratorConstness) {
+  map_[0] = 0;
+  EXPECT_TRUE(IsConstHelper(*map_.cbegin()));
+  EXPECT_TRUE(IsConstHelper(*const_map_.begin()));
+  EXPECT_FALSE(IsConstHelper(*map_.begin()));
+}
+
+bool IsForwardIteratorHelper(std::forward_iterator_tag /*tag*/) { return true; }
+
+TEST_F(MapImplTest, IteratorCategory) {
+  EXPECT_TRUE(IsForwardIteratorHelper(
+      std::iterator_traits<Map<int, int>::iterator>::iterator_category()));
+  EXPECT_TRUE(IsForwardIteratorHelper(
+      std::iterator_traits<
+          Map<int, int>::const_iterator>::iterator_category()));
+}
+
+TEST_F(MapImplTest, InsertSingle) {
+  int32_t key = 0;
+  int32_t value1 = 100;
+  int32_t value2 = 101;
+
+  // Insert a non-existed key.
+  std::pair<Map<int32_t, int32_t>::iterator, bool> result1 =
+      map_.insert(Map<int32_t, int32_t>::value_type(key, value1));
+  ExpectSingleElement(key, value1);
+
+  Map<int32_t, int32_t>::iterator it1 = result1.first;
+  EXPECT_EQ(key, it1->first);
+  EXPECT_EQ(value1, it1->second);
+  EXPECT_TRUE(result1.second);
+
+  // Insert an existed key.
+  std::pair<Map<int32_t, int32_t>::iterator, bool> result2 =
+      map_.insert(Map<int32_t, int32_t>::value_type(key, value2));
+  ExpectSingleElement(key, value1);
+
+  Map<int32_t, int32_t>::iterator it2 = result2.first;
+  EXPECT_TRUE(it1 == it2);
+  EXPECT_FALSE(result2.second);
+}
+
+TEST_F(MapImplTest, InsertByIterator) {
+  int32_t key1 = 0;
+  int32_t key2 = 1;
+  int32_t value1a = 100;
+  int32_t value1b = 101;
+  int32_t value2a = 200;
+  int32_t value2b = 201;
+
+  std::map<int32_t, int32_t> map1;
+  map1[key1] = value1a;
+  map1[key2] = value2a;
+
+  map_.insert(map1.begin(), map1.end());
+  ExpectElements(map1);
+
+  std::map<int32_t, int32_t> map2;
+  map2[key1] = value1b;
+  map2[key2] = value2b;
+
+  map_.insert(map2.begin(), map2.end());
+  ExpectElements(map1);
+}
+
+TEST_F(MapImplTest, InsertByInitializerList) {
+  map_.insert({{1, 100}, {2, 200}});
+  ExpectElements({{1, 100}, {2, 200}});
+
+  map_.insert({{2, 201}, {3, 301}});
+  ExpectElements({{1, 100}, {2, 200}, {3, 301}});
+}
+
+TEST_F(MapImplTest, EraseSingleByKey) {
+  int32_t key = 0;
+  int32_t value = 100;
+
+  map_[key] = value;
+  ExpectSingleElement(key, value);
+
+  // Erase an existing key.
+  EXPECT_EQ(1, map_.erase(key));
+  EXPECT_TRUE(map_.empty());
+  EXPECT_EQ(0, map_.size());
+  EXPECT_TRUE(map_.end() == map_.find(key));
+  EXPECT_TRUE(map_.begin() == map_.end());
+
+  // Erase a non-existing key.
+  EXPECT_EQ(0, map_.erase(key));
+}
+
+TEST_F(MapImplTest, EraseMutipleByKey) {
+  // erase in one specific order to trigger corner cases
+  for (int i = 0; i < 5; i++) {
+    map_[i] = i;
+  }
+
+  map_.erase(0);
+  EXPECT_EQ(4, map_.size());
+  EXPECT_TRUE(map_.end() == map_.find(0));
+
+  map_.erase(1);
+  EXPECT_EQ(3, map_.size());
+  EXPECT_TRUE(map_.end() == map_.find(1));
+
+  map_.erase(3);
+  EXPECT_EQ(2, map_.size());
+  EXPECT_TRUE(map_.end() == map_.find(3));
+
+  map_.erase(4);
+  EXPECT_EQ(1, map_.size());
+  EXPECT_TRUE(map_.end() == map_.find(4));
+
+  map_.erase(2);
+  EXPECT_EQ(0, map_.size());
+  EXPECT_TRUE(map_.end() == map_.find(2));
+}
+
+TEST_F(MapImplTest, EraseSingleByIterator) {
+  int32_t key = 0;
+  int32_t value = 100;
+
+  map_[key] = value;
+  ExpectSingleElement(key, value);
+
+  Map<int32_t, int32_t>::iterator it = map_.find(key);
+  map_.erase(it);
+  EXPECT_TRUE(map_.empty());
+  EXPECT_EQ(0, map_.size());
+  EXPECT_TRUE(map_.end() == map_.find(key));
+  EXPECT_TRUE(map_.begin() == map_.end());
+}
+
+TEST_F(MapImplTest, ValidIteratorAfterErase) {
+  for (int i = 0; i < 10; i++) {
+    map_[i] = i;
+  }
+
+  int count = 0;
+
+  for (Map<int32_t, int32_t>::iterator it = map_.begin(); it != map_.end();) {
+    count++;
+    if (it->first % 2 == 1) {
+      map_.erase(it++);
+    } else {
+      ++it;
+    }
+  }
+
+  EXPECT_EQ(10, count);
+  EXPECT_EQ(5, map_.size());
+}
+
+TEST_F(MapImplTest, EraseByIterator) {
+  int32_t key1 = 0;
+  int32_t key2 = 1;
+  int32_t value1 = 100;
+  int32_t value2 = 101;
+
+  std::map<int32_t, int32_t> map;
+  map[key1] = value1;
+  map[key2] = value2;
+
+  map_.insert(map.begin(), map.end());
+  ExpectElements(map);
+
+  map_.erase(map_.begin(), map_.end());
+  EXPECT_TRUE(map_.empty());
+  EXPECT_EQ(0, map_.size());
+  EXPECT_TRUE(map_.end() == map_.find(key1));
+  EXPECT_TRUE(map_.end() == map_.find(key2));
+  EXPECT_TRUE(map_.begin() == map_.end());
+}
+
+TEST_F(MapImplTest, Clear) {
+  int32_t key = 0;
+  int32_t value = 100;
+
+  map_[key] = value;
+  ExpectSingleElement(key, value);
+
+  map_.clear();
+
+  EXPECT_TRUE(map_.empty());
+  EXPECT_EQ(0, map_.size());
+  EXPECT_TRUE(map_.end() == map_.find(key));
+  EXPECT_TRUE(map_.begin() == map_.end());
+}
+
+static void CopyConstructorHelper(Arena* arena, Map<int32_t, int32_t>* m) {
+  int32_t key1 = 0;
+  int32_t key2 = 1;
+  int32_t value1 = 100;
+  int32_t value2 = 101;
+
+  std::map<int32_t, int32_t> map;
+  map[key1] = value1;
+  map[key2] = value2;
+
+  m->insert(map.begin(), map.end());
+
+  Map<int32_t, int32_t> other(*m);
+
+  EXPECT_EQ(2, other.size());
+  EXPECT_EQ(value1, other.at(key1));
+  EXPECT_EQ(value2, other.at(key2));
+}
+
+TEST_F(MapImplTest, CopyConstructorWithArena) {
+  Arena a;
+  CopyConstructorHelper(&a, &map_);
+}
+
+TEST_F(MapImplTest, CopyConstructorWithoutArena) {
+  CopyConstructorHelper(nullptr, &map_);
+}
+
+TEST_F(MapImplTest, IterConstructor) {
+  int32_t key1 = 0;
+  int32_t key2 = 1;
+  int32_t value1 = 100;
+  int32_t value2 = 101;
+
+  std::map<int32_t, int32_t> map;
+  map[key1] = value1;
+  map[key2] = value2;
+
+  Map<int32_t, int32_t> new_map(map.begin(), map.end());
+
+  EXPECT_EQ(2, new_map.size());
+  EXPECT_EQ(value1, new_map.at(key1));
+  EXPECT_EQ(value2, new_map.at(key2));
+}
+
+TEST_F(MapImplTest, Assigner) {
+  int32_t key1 = 0;
+  int32_t key2 = 1;
+  int32_t value1 = 100;
+  int32_t value2 = 101;
+
+  std::map<int32_t, int32_t> map;
+  map[key1] = value1;
+  map[key2] = value2;
+
+  map_.insert(map.begin(), map.end());
+
+  Map<int32_t, int32_t> other;
+  int32_t key_other = 123;
+  int32_t value_other = 321;
+  other[key_other] = value_other;
+  EXPECT_EQ(1, other.size());
+
+  other = map_;
+
+  EXPECT_EQ(2, other.size());
+  EXPECT_EQ(value1, other.at(key1));
+  EXPECT_EQ(value2, other.at(key2));
+  EXPECT_TRUE(other.find(key_other) == other.end());
+
+  // Self assign
+  other = *&other;  // Avoid -Wself-assign.
+  EXPECT_EQ(2, other.size());
+  EXPECT_EQ(value1, other.at(key1));
+  EXPECT_EQ(value2, other.at(key2));
+}
+
+TEST_F(MapImplTest, Rehash) {
+  const int test_size = 50;
+  std::map<int32_t, int32_t> reference_map;
+  for (int i = 0; i < test_size; i++) {
+    reference_map[i] = i;
+  }
+  for (int i = 0; i < test_size; i++) {
+    map_[i] = reference_map[i];
+    EXPECT_EQ(reference_map[i], map_[i]);
+  }
+  for (int i = 0; i < test_size; i++) {
+    map_.erase(i);
+    EXPECT_TRUE(map_.end() == map_.find(i));
+  }
+  EXPECT_TRUE(map_.empty());
+}
+
+TEST_F(MapImplTest, EqualRange) {
+  int key = 100, key_missing = 101;
+  map_[key] = 100;
+
+  std::pair<Map<int32_t, int32_t>::iterator, Map<int32_t, int32_t>::iterator>
+      range = map_.equal_range(key);
+  EXPECT_TRUE(map_.find(key) == range.first);
+  EXPECT_TRUE(++map_.find(key) == range.second);
+
+  range = map_.equal_range(key_missing);
+  EXPECT_TRUE(map_.end() == range.first);
+  EXPECT_TRUE(map_.end() == range.second);
+
+  std::pair<Map<int32_t, int32_t>::const_iterator,
+            Map<int32_t, int32_t>::const_iterator>
+      const_range = const_map_.equal_range(key);
+  EXPECT_TRUE(const_map_.find(key) == const_range.first);
+  EXPECT_TRUE(++const_map_.find(key) == const_range.second);
+
+  const_range = const_map_.equal_range(key_missing);
+  EXPECT_TRUE(const_map_.end() == const_range.first);
+  EXPECT_TRUE(const_map_.end() == const_range.second);
+}
+
+TEST_F(MapImplTest, ConvertToStdMap) {
+  map_[100] = 101;
+  std::map<int32_t, int32_t> std_map(map_.begin(), map_.end());
+  EXPECT_EQ(1, std_map.size());
+  EXPECT_EQ(101, std_map[100]);
+}
+
+TEST_F(MapImplTest, ConvertToStdVectorOfPairs) {
+  map_[100] = 101;
+  std::vector<std::pair<int32_t, int32_t>> std_vec(map_.begin(), map_.end());
+  EXPECT_EQ(1, std_vec.size());
+  EXPECT_EQ(100, std_vec[0].first);
+  EXPECT_EQ(101, std_vec[0].second);
+}
+
+TEST_F(MapImplTest, SwapBasic) {
+  Map<int32_t, int32_t> another;
+  map_[9398] = 41999;
+  another[9398] = 41999;
+  another[8070] = 42056;
+  another.swap(map_);
+  EXPECT_THAT(another,
+              testing::UnorderedElementsAre(testing::Pair(9398, 41999)));
+  EXPECT_THAT(map_, testing::UnorderedElementsAre(testing::Pair(8070, 42056),
+                                                  testing::Pair(9398, 41999)));
+}
+
+TEST_F(MapImplTest, SwapArena) {
+  Arena arena1, arena2;
+  Map<int32_t, int32_t> m1(&arena1);
+  Map<int32_t, int32_t> m2(&arena2);
+  map_[9398] = 41999;
+  m1[9398] = 41999;
+  m1[8070] = 42056;
+  m2[10244] = 10247;
+  m2[8070] = 42056;
+  m1.swap(map_);
+  EXPECT_THAT(m1, testing::UnorderedElementsAre(testing::Pair(9398, 41999)));
+  EXPECT_THAT(map_, testing::UnorderedElementsAre(testing::Pair(8070, 42056),
+                                                  testing::Pair(9398, 41999)));
+  m2.swap(m1);
+  EXPECT_THAT(m1, testing::UnorderedElementsAre(testing::Pair(8070, 42056),
+                                                testing::Pair(10244, 10247)));
+  EXPECT_THAT(m2, testing::UnorderedElementsAre(testing::Pair(9398, 41999)));
+}
+
+TEST_F(MapImplTest, SwapFieldArenaReflection) {
+  MapReflectionTester reflection_tester(UNITTEST::TestMap::descriptor());
+  Arena arena;
+
+  {
+    // Tests filled lfs and empty rhs.
+    TestMap rhs;
+
+    {
+      // Use local_arena to allocate lhs to trigger use-after-free error.
+      Arena local_arena;
+      auto* lhs = Arena::CreateMessage<TestMap>(&local_arena);
+      const auto* reflection = lhs->GetReflection();
+      std::vector<const FieldDescriptor*> fields;
+
+      reflection_tester.SetMapFieldsViaReflection(lhs);
+      reflection->ListFields(*lhs, &fields);
+
+      reflection->SwapFields(lhs, &rhs, fields);
+
+      reflection_tester.ExpectClearViaReflection(*lhs);
+    }
+
+    reflection_tester.ExpectMapFieldsSetViaReflection(rhs);
+  }
+}
+
+TEST_F(MapImplTest, CopyAssignMapIterator) {
+  TestMap message;
+  MapReflectionTester reflection_tester(UNITTEST::TestMap::descriptor());
+  reflection_tester.SetMapFieldsViaMapReflection(&message);
+  MapIterator it1 = reflection_tester.MapBegin(&message, "map_int32_int32");
+  MapIterator it2 = reflection_tester.MapEnd(&message, "map_int32_int32");
+  it2 = it1;
+  EXPECT_EQ(it1.GetKey().GetInt32Value(), it2.GetKey().GetInt32Value());
+}
+
+TEST_F(MapImplTest, SpaceUsed) {
+  constexpr size_t kMinCap = 8;
+
+  Map<int32_t, int32_t> m;
+  // An newly constructed map should have no space used.
+  EXPECT_EQ(m.SpaceUsedExcludingSelfLong(), 0);
+
+  size_t capacity = kMinCap;
+  for (int i = 0; i < 100; ++i) {
+    m[i];
+    static constexpr double kMaxLoadFactor = .75;
+    if (m.size() >= capacity * kMaxLoadFactor) {
+      capacity *= 2;
+    }
+    EXPECT_EQ(
+        m.SpaceUsedExcludingSelfLong(),
+        sizeof(void*) * capacity +
+            m.size() * sizeof(std::pair<std::pair<int32_t, int32_t>, void*>));
+  }
+
+  // Test string, and non-scalar keys.
+  Map<std::string, int32_t> m2;
+  std::string str = "Some arbitrarily large string";
+  m2[str] = 1;
+  EXPECT_EQ(m2.SpaceUsedExcludingSelfLong(),
+            sizeof(void*) * kMinCap +
+                sizeof(std::pair<std::pair<std::string, int32_t>, void*>) +
+                internal::StringSpaceUsedExcludingSelfLong(str));
+
+  // Test messages, and non-scalar values.
+  Map<int32_t, TestAllTypes> m3;
+  m3[0].set_optional_string(str);
+  EXPECT_EQ(m3.SpaceUsedExcludingSelfLong(),
+            sizeof(void*) * kMinCap +
+                sizeof(std::pair<std::pair<int32_t, TestAllTypes>, void*>) +
+                m3[0].SpaceUsedLong() - sizeof(m3[0]));
+}
+
+// Attempts to verify that a map with keys a and b has a random ordering. This
+// function returns true if it succeeds in observing both possible orderings.
+bool MapOrderingIsRandom(int a, int b) {
+  bool saw_a_first = false;
+  bool saw_b_first = false;
+  std::vector<Map<int32_t, int32_t>> v(50);
+  for (int i = 0; i < 50; ++i) {
+    Map<int32_t, int32_t>& m = v[i];
+    m[a] = 0;
+    m[b] = 0;
+    int32_t first_element = m.begin()->first;
+    if (first_element == a) saw_a_first = true;
+    if (first_element == b) saw_b_first = true;
+    if (saw_a_first && saw_b_first) {
+      return true;
+    }
+  }
+  return false;
+}
+
+// This test verifies that the iteration order is reasonably random even for
+// small maps.
+TEST_F(MapImplTest, RandomOrdering) {
+  for (int i = 0; i < 10; ++i) {
+    for (int j = i + 1; j < 10; ++j) {
+      EXPECT_TRUE(MapOrderingIsRandom(i, j))
+          << "Map with keys " << i << " and " << j
+          << " has deterministic ordering";
+    }
+  }
+}
+
+template <typename Key>
+void TestTransparent(const Key& key, const Key& miss_key) {
+  Map<std::string, int> m;
+  const auto& cm = m;
+
+  m.insert({"ABC", 1});
+
+  const auto abc_it = m.begin();
+
+  m.insert({"DEF", 2});
+
+  using testing::Pair;
+  using testing::UnorderedElementsAre;
+
+  EXPECT_EQ(m.at(key), 1);
+  EXPECT_EQ(cm.at(key), 1);
+
+#ifdef PROTOBUF_HAS_DEATH_TEST
+  EXPECT_DEATH(m.at(miss_key), "");
+  EXPECT_DEATH(cm.at(miss_key), "");
+#endif  // PROTOBUF_HAS_DEATH_TEST
+
+  EXPECT_EQ(m.count(key), 1);
+  EXPECT_EQ(cm.count(key), 1);
+  EXPECT_EQ(m.count(miss_key), 0);
+  EXPECT_EQ(cm.count(miss_key), 0);
+
+  EXPECT_EQ(m.find(key), abc_it);
+  EXPECT_EQ(cm.find(key), abc_it);
+  EXPECT_EQ(m.find(miss_key), m.end());
+  EXPECT_EQ(cm.find(miss_key), cm.end());
+
+  EXPECT_TRUE(m.contains(key));
+  EXPECT_TRUE(cm.contains(key));
+  EXPECT_FALSE(m.contains(miss_key));
+  EXPECT_FALSE(cm.contains(miss_key));
+
+  EXPECT_THAT(m.equal_range(key), Pair(abc_it, std::next(abc_it)));
+  EXPECT_THAT(cm.equal_range(key), Pair(abc_it, std::next(abc_it)));
+  EXPECT_THAT(m.equal_range(miss_key), Pair(m.end(), m.end()));
+  EXPECT_THAT(cm.equal_range(miss_key), Pair(m.end(), m.end()));
+
+  EXPECT_THAT(m, UnorderedElementsAre(Pair("ABC", 1), Pair("DEF", 2)));
+  EXPECT_EQ(m.erase(key), 1);
+  EXPECT_THAT(m, UnorderedElementsAre(Pair("DEF", 2)));
+  EXPECT_EQ(m.erase(key), 0);
+  EXPECT_EQ(m.erase(miss_key), 0);
+  EXPECT_THAT(m, UnorderedElementsAre(Pair("DEF", 2)));
+
+  m[key];
+  EXPECT_THAT(m, UnorderedElementsAre(Pair("ABC", 0), Pair("DEF", 2)));
+  m[key] = 1;
+  EXPECT_THAT(m, UnorderedElementsAre(Pair("ABC", 1), Pair("DEF", 2)));
+}
+
+TEST_F(MapImplTest, TransparentLookupForString) {
+  TestTransparent("ABC", "LKJ");
+  TestTransparent(std::string("ABC"), std::string("LKJ"));
+#if defined(__cpp_lib_string_view)
+  TestTransparent(std::string_view("ABC"), std::string_view("LKJ"));
+#endif  // defined(__cpp_lib_string_view)
+
+  // std::reference_wrapper
+  std::string abc = "ABC", lkj = "LKJ";
+  TestTransparent(std::ref(abc), std::ref(lkj));
+  TestTransparent(std::cref(abc), std::cref(lkj));
+}
+
+TEST_F(MapImplTest, ConstInit) {
+  PROTOBUF_CONSTINIT static Map<int, int> map;  // NOLINT
+  EXPECT_TRUE(map.empty());
+}
+
+// Map Field Reflection Test ========================================
+
+static int Func(int i, int j) { return i * j; }
+
+static std::string StrFunc(int i, int j) { return StrCat(Func(i, j)); }
+
+static int Int(const std::string& value) {
+  int result = 0;
+  std::istringstream(value) >> result;
+  return result;
+}
+
+}  // namespace
+
+// This class is a friend, so no anonymous namespace.
+class MapFieldReflectionTest : public testing::Test {
+ protected:
+  typedef FieldDescriptor FD;
+
+  int MapSize(const Reflection* reflection, const FieldDescriptor* field,
+              const Message& message) {
+    return reflection->MapSize(message, field);
+  }
+};
+
+namespace {
+
+TEST_F(MapFieldReflectionTest, RegularFields) {
+  TestMap message;
+  const Reflection* refl = message.GetReflection();
+  const Descriptor* desc = message.GetDescriptor();
+
+  Map<int32_t, int32_t>* map_int32_int32 = message.mutable_map_int32_int32();
+  Map<int32_t, double>* map_int32_double = message.mutable_map_int32_double();
+  Map<std::string, std::string>* map_string_string =
+      message.mutable_map_string_string();
+  Map<int32_t, ForeignMessage>* map_int32_foreign_message =
+      message.mutable_map_int32_foreign_message();
+
+  for (int i = 0; i < 10; ++i) {
+    (*map_int32_int32)[i] = Func(i, 1);
+    (*map_int32_double)[i] = Func(i, 2);
+    (*map_string_string)[StrFunc(i, 1)] = StrFunc(i, 5);
+    (*map_int32_foreign_message)[i].set_c(Func(i, 6));
+  }
+
+  // Get FieldDescriptors for all the fields of interest.
+  const FieldDescriptor* fd_map_int32_int32 =
+      desc->FindFieldByName("map_int32_int32");
+  const FieldDescriptor* fd_map_int32_double =
+      desc->FindFieldByName("map_int32_double");
+  const FieldDescriptor* fd_map_string_string =
+      desc->FindFieldByName("map_string_string");
+  const FieldDescriptor* fd_map_int32_foreign_message =
+      desc->FindFieldByName("map_int32_foreign_message");
+
+  const FieldDescriptor* fd_map_int32_in32_key =
+      fd_map_int32_int32->message_type()->map_key();
+  const FieldDescriptor* fd_map_int32_in32_value =
+      fd_map_int32_int32->message_type()->map_value();
+  const FieldDescriptor* fd_map_int32_double_key =
+      fd_map_int32_double->message_type()->map_key();
+  const FieldDescriptor* fd_map_int32_double_value =
+      fd_map_int32_double->message_type()->map_value();
+  const FieldDescriptor* fd_map_string_string_key =
+      fd_map_string_string->message_type()->map_key();
+  const FieldDescriptor* fd_map_string_string_value =
+      fd_map_string_string->message_type()->map_value();
+  const FieldDescriptor* fd_map_int32_foreign_message_key =
+      fd_map_int32_foreign_message->message_type()->map_key();
+  const FieldDescriptor* fd_map_int32_foreign_message_value =
+      fd_map_int32_foreign_message->message_type()->map_value();
+
+  // Get RepeatedPtrField objects for all fields of interest.
+  const RepeatedPtrField<Message>& mf_int32_int32 =
+      refl->GetRepeatedPtrField<Message>(message, fd_map_int32_int32);
+  const RepeatedPtrField<Message>& mf_int32_double =
+      refl->GetRepeatedPtrField<Message>(message, fd_map_int32_double);
+  const RepeatedPtrField<Message>& mf_string_string =
+      refl->GetRepeatedPtrField<Message>(message, fd_map_string_string);
+  const RepeatedPtrField<Message>& mf_int32_foreign_message =
+      refl->GetRepeatedPtrField<Message>(message, fd_map_int32_foreign_message);
+
+  // Get mutable RepeatedPtrField objects for all fields of interest.
+  RepeatedPtrField<Message>* mmf_int32_int32 =
+      refl->MutableRepeatedPtrField<Message>(&message, fd_map_int32_int32);
+  RepeatedPtrField<Message>* mmf_int32_double =
+      refl->MutableRepeatedPtrField<Message>(&message, fd_map_int32_double);
+  RepeatedPtrField<Message>* mmf_string_string =
+      refl->MutableRepeatedPtrField<Message>(&message, fd_map_string_string);
+  RepeatedPtrField<Message>* mmf_int32_foreign_message =
+      refl->MutableRepeatedPtrField<Message>(&message,
+                                             fd_map_int32_foreign_message);
+
+  // Make sure we can do gets through the RepeatedPtrField objects.
+  for (int i = 0; i < 10; ++i) {
+    {
+      // Check gets through const objects.
+      const Message& message_int32_int32 = mf_int32_int32.Get(i);
+      int32_t key_int32_int32 = message_int32_int32.GetReflection()->GetInt32(
+          message_int32_int32, fd_map_int32_in32_key);
+      int32_t value_int32_int32 = message_int32_int32.GetReflection()->GetInt32(
+          message_int32_int32, fd_map_int32_in32_value);
+      EXPECT_EQ(value_int32_int32, Func(key_int32_int32, 1));
+
+      const Message& message_int32_double = mf_int32_double.Get(i);
+      int32_t key_int32_double = message_int32_double.GetReflection()->GetInt32(
+          message_int32_double, fd_map_int32_double_key);
+      double value_int32_double =
+          message_int32_double.GetReflection()->GetDouble(
+              message_int32_double, fd_map_int32_double_value);
+      EXPECT_EQ(value_int32_double, Func(key_int32_double, 2));
+
+      const Message& message_string_string = mf_string_string.Get(i);
+      std::string key_string_string =
+          message_string_string.GetReflection()->GetString(
+              message_string_string, fd_map_string_string_key);
+      std::string value_string_string =
+          message_string_string.GetReflection()->GetString(
+              message_string_string, fd_map_string_string_value);
+      EXPECT_EQ(value_string_string, StrFunc(Int(key_string_string), 5));
+
+      const Message& message_int32_message = mf_int32_foreign_message.Get(i);
+      int32_t key_int32_message =
+          message_int32_message.GetReflection()->GetInt32(
+              message_int32_message, fd_map_int32_foreign_message_key);
+      const ForeignMessage& value_int32_message =
+          down_cast<const ForeignMessage&>(
+              message_int32_message.GetReflection()->GetMessage(
+                  message_int32_message, fd_map_int32_foreign_message_value));
+      EXPECT_EQ(value_int32_message.c(), Func(key_int32_message, 6));
+    }
+
+    {
+      // Check gets through mutable objects.
+      const Message& message_int32_int32 = mmf_int32_int32->Get(i);
+      int32_t key_int32_int32 = message_int32_int32.GetReflection()->GetInt32(
+          message_int32_int32, fd_map_int32_in32_key);
+      int32_t value_int32_int32 = message_int32_int32.GetReflection()->GetInt32(
+          message_int32_int32, fd_map_int32_in32_value);
+      EXPECT_EQ(value_int32_int32, Func(key_int32_int32, 1));
+
+      const Message& message_int32_double = mmf_int32_double->Get(i);
+      int32_t key_int32_double = message_int32_double.GetReflection()->GetInt32(
+          message_int32_double, fd_map_int32_double_key);
+      double value_int32_double =
+          message_int32_double.GetReflection()->GetDouble(
+              message_int32_double, fd_map_int32_double_value);
+      EXPECT_EQ(value_int32_double, Func(key_int32_double, 2));
+
+      const Message& message_string_string = mmf_string_string->Get(i);
+      std::string key_string_string =
+          message_string_string.GetReflection()->GetString(
+              message_string_string, fd_map_string_string_key);
+      std::string value_string_string =
+          message_string_string.GetReflection()->GetString(
+              message_string_string, fd_map_string_string_value);
+      EXPECT_EQ(value_string_string, StrFunc(Int(key_string_string), 5));
+
+      const Message& message_int32_message = mmf_int32_foreign_message->Get(i);
+      int32_t key_int32_message =
+          message_int32_message.GetReflection()->GetInt32(
+              message_int32_message, fd_map_int32_foreign_message_key);
+      const ForeignMessage& value_int32_message =
+          down_cast<const ForeignMessage&>(
+              message_int32_message.GetReflection()->GetMessage(
+                  message_int32_message, fd_map_int32_foreign_message_value));
+      EXPECT_EQ(value_int32_message.c(), Func(key_int32_message, 6));
+    }
+  }
+
+  // Do sets through the RepeatedPtrField objects.
+  for (int i = 0; i < 10; i++) {
+    {
+      Message* message_int32_int32 = mmf_int32_int32->Mutable(i);
+      int32_t key_int32_int32 = message_int32_int32->GetReflection()->GetInt32(
+          *message_int32_int32, fd_map_int32_in32_key);
+      message_int32_int32->GetReflection()->SetInt32(message_int32_int32,
+                                                     fd_map_int32_in32_value,
+                                                     Func(key_int32_int32, -1));
+
+      Message* message_int32_double = mmf_int32_double->Mutable(i);
+      int32_t key_int32_double =
+          message_int32_double->GetReflection()->GetInt32(
+              *message_int32_double, fd_map_int32_double_key);
+      message_int32_double->GetReflection()->SetDouble(
+          message_int32_double, fd_map_int32_double_value,
+          Func(key_int32_double, -2));
+
+      Message* message_string_string = mmf_string_string->Mutable(i);
+      std::string key_string_string =
+          message_string_string->GetReflection()->GetString(
+              *message_string_string, fd_map_string_string_key);
+      message_string_string->GetReflection()->SetString(
+          message_string_string, fd_map_string_string_value,
+          StrFunc(Int(key_string_string), -5));
+
+      Message* message_int32_message = mmf_int32_foreign_message->Mutable(i);
+      int32_t key_int32_message =
+          message_int32_message->GetReflection()->GetInt32(
+              *message_int32_message, fd_map_int32_foreign_message_key);
+      ForeignMessage* value_int32_message = down_cast<ForeignMessage*>(
+          message_int32_message->GetReflection()->MutableMessage(
+              message_int32_message, fd_map_int32_foreign_message_value));
+      value_int32_message->set_c(Func(key_int32_message, -6));
+    }
+  }
+
+  // Check gets through mutable objects.
+  for (int i = 0; i < 10; i++) {
+    EXPECT_EQ(Func(i, -1), message.map_int32_int32().at(i));
+    EXPECT_EQ(Func(i, -2), message.map_int32_double().at(i));
+    EXPECT_EQ(StrFunc(i, -5), message.map_string_string().at(StrFunc(i, 1)));
+    EXPECT_EQ(Func(i, -6), message.map_int32_foreign_message().at(i).c());
+  }
+}
+
+TEST_F(MapFieldReflectionTest, RepeatedFieldRefForRegularFields) {
+  TestMap message;
+  const Reflection* refl = message.GetReflection();
+  const Descriptor* desc = message.GetDescriptor();
+
+  Map<int32_t, int32_t>* map_int32_int32 = message.mutable_map_int32_int32();
+  Map<int32_t, double>* map_int32_double = message.mutable_map_int32_double();
+  Map<std::string, std::string>* map_string_string =
+      message.mutable_map_string_string();
+  Map<int32_t, ForeignMessage>* map_int32_foreign_message =
+      message.mutable_map_int32_foreign_message();
+
+  for (int i = 0; i < 10; ++i) {
+    (*map_int32_int32)[i] = Func(i, 1);
+    (*map_int32_double)[i] = Func(i, 2);
+    (*map_string_string)[StrFunc(i, 1)] = StrFunc(i, 5);
+    (*map_int32_foreign_message)[i].set_c(Func(i, 6));
+  }
+
+  // Get FieldDescriptors for all the fields of interest.
+  const FieldDescriptor* fd_map_int32_int32 =
+      desc->FindFieldByName("map_int32_int32");
+  const FieldDescriptor* fd_map_int32_double =
+      desc->FindFieldByName("map_int32_double");
+  const FieldDescriptor* fd_map_string_string =
+      desc->FindFieldByName("map_string_string");
+  const FieldDescriptor* fd_map_int32_foreign_message =
+      desc->FindFieldByName("map_int32_foreign_message");
+
+  const FieldDescriptor* fd_map_int32_in32_key =
+      fd_map_int32_int32->message_type()->map_key();
+  const FieldDescriptor* fd_map_int32_in32_value =
+      fd_map_int32_int32->message_type()->map_value();
+  const FieldDescriptor* fd_map_int32_double_key =
+      fd_map_int32_double->message_type()->map_key();
+  const FieldDescriptor* fd_map_int32_double_value =
+      fd_map_int32_double->message_type()->map_value();
+  const FieldDescriptor* fd_map_string_string_key =
+      fd_map_string_string->message_type()->map_key();
+  const FieldDescriptor* fd_map_string_string_value =
+      fd_map_string_string->message_type()->map_value();
+  const FieldDescriptor* fd_map_int32_foreign_message_key =
+      fd_map_int32_foreign_message->message_type()->map_key();
+  const FieldDescriptor* fd_map_int32_foreign_message_value =
+      fd_map_int32_foreign_message->message_type()->map_value();
+
+  // Get RepeatedFieldRef objects for all fields of interest.
+  const RepeatedFieldRef<Message> mf_int32_int32 =
+      refl->GetRepeatedFieldRef<Message>(message, fd_map_int32_int32);
+  const RepeatedFieldRef<Message> mf_int32_double =
+      refl->GetRepeatedFieldRef<Message>(message, fd_map_int32_double);
+  const RepeatedFieldRef<Message> mf_string_string =
+      refl->GetRepeatedFieldRef<Message>(message, fd_map_string_string);
+  const RepeatedFieldRef<Message> mf_int32_foreign_message =
+      refl->GetRepeatedFieldRef<Message>(message, fd_map_int32_foreign_message);
+
+  // Get mutable RepeatedFieldRef objects for all fields of interest.
+  const MutableRepeatedFieldRef<Message> mmf_int32_int32 =
+      refl->GetMutableRepeatedFieldRef<Message>(&message, fd_map_int32_int32);
+  const MutableRepeatedFieldRef<Message> mmf_int32_double =
+      refl->GetMutableRepeatedFieldRef<Message>(&message, fd_map_int32_double);
+  const MutableRepeatedFieldRef<Message> mmf_string_string =
+      refl->GetMutableRepeatedFieldRef<Message>(&message, fd_map_string_string);
+  const MutableRepeatedFieldRef<Message> mmf_int32_foreign_message =
+      refl->GetMutableRepeatedFieldRef<Message>(&message,
+                                                fd_map_int32_foreign_message);
+
+  // Get entry default instances
+  std::unique_ptr<Message> entry_int32_int32(
+      MessageFactory::generated_factory()
+          ->GetPrototype(fd_map_int32_int32->message_type())
+          ->New(message.GetArena()));
+  std::unique_ptr<Message> entry_int32_double(
+      MessageFactory::generated_factory()
+          ->GetPrototype(fd_map_int32_double->message_type())
+          ->New(message.GetArena()));
+  std::unique_ptr<Message> entry_string_string(
+      MessageFactory::generated_factory()
+          ->GetPrototype(fd_map_string_string->message_type())
+          ->New(message.GetArena()));
+  std::unique_ptr<Message> entry_int32_foreign_message(
+      MessageFactory::generated_factory()
+          ->GetPrototype(fd_map_int32_foreign_message->message_type())
+          ->New(message.GetArena()));
+
+  EXPECT_EQ(10, mf_int32_int32.size());
+  EXPECT_EQ(10, mmf_int32_int32.size());
+  EXPECT_EQ(10, mf_int32_double.size());
+  EXPECT_EQ(10, mmf_int32_double.size());
+  EXPECT_EQ(10, mf_string_string.size());
+  EXPECT_EQ(10, mmf_string_string.size());
+  EXPECT_EQ(10, mf_int32_foreign_message.size());
+  EXPECT_EQ(10, mmf_int32_foreign_message.size());
+
+  EXPECT_FALSE(mf_int32_int32.empty());
+  EXPECT_FALSE(mmf_int32_int32.empty());
+  EXPECT_FALSE(mf_int32_double.empty());
+  EXPECT_FALSE(mmf_int32_double.empty());
+  EXPECT_FALSE(mf_string_string.empty());
+  EXPECT_FALSE(mmf_string_string.empty());
+  EXPECT_FALSE(mf_int32_foreign_message.empty());
+  EXPECT_FALSE(mmf_int32_foreign_message.empty());
+
+  // Make sure we can do gets through the RepeatedFieldRef objects.
+  for (int i = 0; i < 10; ++i) {
+    {
+      // Check gets through const objects.
+      const Message& message_int32_int32 =
+          mf_int32_int32.Get(i, entry_int32_int32.get());
+      int32_t key_int32_int32 = message_int32_int32.GetReflection()->GetInt32(
+          message_int32_int32, fd_map_int32_in32_key);
+      int32_t value_int32_int32 = message_int32_int32.GetReflection()->GetInt32(
+          message_int32_int32, fd_map_int32_in32_value);
+      EXPECT_EQ(value_int32_int32, Func(key_int32_int32, 1));
+
+      const Message& message_int32_double =
+          mf_int32_double.Get(i, entry_int32_double.get());
+      int32_t key_int32_double = message_int32_double.GetReflection()->GetInt32(
+          message_int32_double, fd_map_int32_double_key);
+      double value_int32_double =
+          message_int32_double.GetReflection()->GetDouble(
+              message_int32_double, fd_map_int32_double_value);
+      EXPECT_EQ(value_int32_double, Func(key_int32_double, 2));
+
+      const Message& message_string_string =
+          mf_string_string.Get(i, entry_string_string.get());
+      std::string key_string_string =
+          message_string_string.GetReflection()->GetString(
+              message_string_string, fd_map_string_string_key);
+      std::string value_string_string =
+          message_string_string.GetReflection()->GetString(
+              message_string_string, fd_map_string_string_value);
+      EXPECT_EQ(value_string_string, StrFunc(Int(key_string_string), 5));
+
+      const Message& message_int32_message =
+          mf_int32_foreign_message.Get(i, entry_int32_foreign_message.get());
+      int32_t key_int32_message =
+          message_int32_message.GetReflection()->GetInt32(
+              message_int32_message, fd_map_int32_foreign_message_key);
+      const ForeignMessage& value_int32_message =
+          down_cast<const ForeignMessage&>(
+              message_int32_message.GetReflection()->GetMessage(
+                  message_int32_message, fd_map_int32_foreign_message_value));
+      EXPECT_EQ(value_int32_message.c(), Func(key_int32_message, 6));
+    }
+
+    {
+      // Check gets through mutable objects.
+      const Message& message_int32_int32 =
+          mmf_int32_int32.Get(i, entry_int32_int32.get());
+      int32_t key_int32_int32 = message_int32_int32.GetReflection()->GetInt32(
+          message_int32_int32, fd_map_int32_in32_key);
+      int32_t value_int32_int32 = message_int32_int32.GetReflection()->GetInt32(
+          message_int32_int32, fd_map_int32_in32_value);
+      EXPECT_EQ(value_int32_int32, Func(key_int32_int32, 1));
+
+      const Message& message_int32_double =
+          mmf_int32_double.Get(i, entry_int32_double.get());
+      int32_t key_int32_double = message_int32_double.GetReflection()->GetInt32(
+          message_int32_double, fd_map_int32_double_key);
+      double value_int32_double =
+          message_int32_double.GetReflection()->GetDouble(
+              message_int32_double, fd_map_int32_double_value);
+      EXPECT_EQ(value_int32_double, Func(key_int32_double, 2));
+
+      const Message& message_string_string =
+          mmf_string_string.Get(i, entry_string_string.get());
+      std::string key_string_string =
+          message_string_string.GetReflection()->GetString(
+              message_string_string, fd_map_string_string_key);
+      std::string value_string_string =
+          message_string_string.GetReflection()->GetString(
+              message_string_string, fd_map_string_string_value);
+      EXPECT_EQ(value_string_string, StrFunc(Int(key_string_string), 5));
+
+      const Message& message_int32_message =
+          mmf_int32_foreign_message.Get(i, entry_int32_foreign_message.get());
+      int32_t key_int32_message =
+          message_int32_message.GetReflection()->GetInt32(
+              message_int32_message, fd_map_int32_foreign_message_key);
+      const ForeignMessage& value_int32_message =
+          down_cast<const ForeignMessage&>(
+              message_int32_message.GetReflection()->GetMessage(
+                  message_int32_message, fd_map_int32_foreign_message_value));
+      EXPECT_EQ(value_int32_message.c(), Func(key_int32_message, 6));
+    }
+  }
+
+  // Make sure we can do sets through the RepeatedFieldRef objects.
+  for (int i = 0; i < 10; i++) {
+    const Message& message_int32_int32 =
+        mmf_int32_int32.Get(i, entry_int32_int32.get());
+    int key = message_int32_int32.GetReflection()->GetInt32(
+        message_int32_int32, fd_map_int32_in32_key);
+
+    entry_int32_int32->GetReflection()->SetInt32(
+        entry_int32_int32.get(), fd_map_int32_int32->message_type()->field(0),
+        key);
+    entry_int32_int32->GetReflection()->SetInt32(
+        entry_int32_int32.get(), fd_map_int32_int32->message_type()->field(1),
+        Func(key, -1));
+    entry_int32_double->GetReflection()->SetInt32(
+        entry_int32_double.get(), fd_map_int32_double->message_type()->field(0),
+        key);
+    entry_int32_double->GetReflection()->SetDouble(
+        entry_int32_double.get(), fd_map_int32_double->message_type()->field(1),
+        Func(key, -2));
+    entry_string_string->GetReflection()->SetString(
+        entry_string_string.get(),
+        fd_map_string_string->message_type()->field(0), StrFunc(key, 1));
+    entry_string_string->GetReflection()->SetString(
+        entry_string_string.get(),
+        fd_map_string_string->message_type()->field(1), StrFunc(key, -5));
+    entry_int32_foreign_message->GetReflection()->SetInt32(
+        entry_int32_foreign_message.get(),
+        fd_map_int32_foreign_message->message_type()->field(0), key);
+    Message* value_message =
+        entry_int32_foreign_message->GetReflection()->MutableMessage(
+            entry_int32_foreign_message.get(),
+            fd_map_int32_foreign_message->message_type()->field(1));
+    value_message->GetReflection()->SetInt32(
+        value_message, value_message->GetDescriptor()->FindFieldByName("c"),
+        Func(key, -6));
+
+    mmf_int32_int32.Set(i, *entry_int32_int32);
+    mmf_int32_double.Set(i, *entry_int32_double);
+    mmf_string_string.Set(i, *entry_string_string);
+    mmf_int32_foreign_message.Set(i, *entry_int32_foreign_message);
+  }
+
+  for (int i = 0; i < 10; i++) {
+    EXPECT_EQ(Func(i, -1), message.map_int32_int32().at(i));
+    EXPECT_EQ(Func(i, -2), message.map_int32_double().at(i));
+    EXPECT_EQ(StrFunc(i, -5), message.map_string_string().at(StrFunc(i, 1)));
+    EXPECT_EQ(Func(i, -6), message.map_int32_foreign_message().at(i).c());
+  }
+
+  // Test iterators.
+  {
+    int index = 0;
+    std::unordered_map<int32_t, int32_t> result;
+    for (RepeatedFieldRef<Message>::iterator it = mf_int32_int32.begin();
+         it != mf_int32_int32.end(); ++it) {
+      const Message& message = *it;
+      int32_t key =
+          message.GetReflection()->GetInt32(message, fd_map_int32_in32_key);
+      int32_t value =
+          message.GetReflection()->GetInt32(message, fd_map_int32_in32_value);
+      result[key] = value;
+      ++index;
+    }
+    EXPECT_EQ(10, index);
+    for (std::unordered_map<int32_t, int32_t>::const_iterator it =
+             result.begin();
+         it != result.end(); ++it) {
+      EXPECT_EQ(message.map_int32_int32().at(it->first), it->second);
+    }
+  }
+
+  {
+    int index = 0;
+    std::unordered_map<int32_t, double> result;
+    for (RepeatedFieldRef<Message>::iterator it = mf_int32_double.begin();
+         it != mf_int32_double.end(); ++it) {
+      const Message& message = *it;
+      int32_t key =
+          message.GetReflection()->GetInt32(message, fd_map_int32_double_key);
+      double value = message.GetReflection()->GetDouble(
+          message, fd_map_int32_double_value);
+      result[key] = value;
+      ++index;
+    }
+    EXPECT_EQ(10, index);
+    for (std::unordered_map<int32_t, double>::const_iterator it =
+             result.begin();
+         it != result.end(); ++it) {
+      EXPECT_EQ(message.map_int32_double().at(it->first), it->second);
+    }
+  }
+
+  {
+    int index = 0;
+    std::unordered_map<std::string, std::string> result;
+    for (RepeatedFieldRef<Message>::iterator it = mf_string_string.begin();
+         it != mf_string_string.end(); ++it) {
+      const Message& message = *it;
+      std::string key =
+          message.GetReflection()->GetString(message, fd_map_string_string_key);
+      std::string value = message.GetReflection()->GetString(
+          message, fd_map_string_string_value);
+      result[key] = value;
+      ++index;
+    }
+    EXPECT_EQ(10, index);
+    for (std::unordered_map<std::string, std::string>::const_iterator it =
+             result.begin();
+         it != result.end(); ++it) {
+      EXPECT_EQ(message.map_string_string().at(it->first), it->second);
+    }
+  }
+
+  {
+    int index = 0;
+    std::map<int32_t, ForeignMessage> result;
+    for (RepeatedFieldRef<Message>::iterator it =
+             mf_int32_foreign_message.begin();
+         it != mf_int32_foreign_message.end(); ++it) {
+      const Message& message = *it;
+      int32_t key = message.GetReflection()->GetInt32(
+          message, fd_map_int32_foreign_message_key);
+      const ForeignMessage& sub_message =
+          down_cast<const ForeignMessage&>(message.GetReflection()->GetMessage(
+              message, fd_map_int32_foreign_message_value));
+      result[key].MergeFrom(sub_message);
+      ++index;
+    }
+    EXPECT_EQ(10, index);
+    for (std::map<int32_t, ForeignMessage>::const_iterator it = result.begin();
+         it != result.end(); ++it) {
+      EXPECT_EQ(message.map_int32_foreign_message().at(it->first).c(),
+                it->second.c());
+    }
+  }
+
+  // Test MutableRepeatedFieldRef::Add()
+  entry_int32_int32->GetReflection()->SetInt32(
+      entry_int32_int32.get(), fd_map_int32_int32->message_type()->field(0),
+      4321);
+  entry_int32_int32->GetReflection()->SetInt32(
+      entry_int32_int32.get(), fd_map_int32_int32->message_type()->field(1),
+      1234);
+  mmf_int32_int32.Add(*entry_int32_int32);
+  EXPECT_EQ(1234, message.map_int32_int32().at(4321));
+
+  entry_int32_double->GetReflection()->SetInt32(
+      entry_int32_double.get(), fd_map_int32_double->message_type()->field(0),
+      4321);
+  entry_int32_double->GetReflection()->SetDouble(
+      entry_int32_double.get(), fd_map_int32_double->message_type()->field(1),
+      1234.0);
+  mmf_int32_double.Add(*entry_int32_double);
+  EXPECT_EQ(1234.0, message.map_int32_double().at(4321));
+
+  entry_string_string->GetReflection()->SetString(
+      entry_string_string.get(), fd_map_string_string->message_type()->field(0),
+      "4321");
+  entry_string_string->GetReflection()->SetString(
+      entry_string_string.get(), fd_map_string_string->message_type()->field(1),
+      "1234");
+  mmf_string_string.Add(*entry_string_string);
+  EXPECT_EQ("1234", message.map_string_string().at("4321"));
+
+  entry_int32_foreign_message->GetReflection()->SetInt32(
+      entry_int32_foreign_message.get(),
+      fd_map_int32_foreign_message->message_type()->field(0), 4321);
+  Message* value_message =
+      entry_int32_foreign_message->GetReflection()->MutableMessage(
+          entry_int32_foreign_message.get(),
+          fd_map_int32_foreign_message->message_type()->field(1));
+  ForeignMessage foreign_message;
+  foreign_message.set_c(1234);
+  value_message->CopyFrom(foreign_message);
+
+  mmf_int32_foreign_message.Add(*entry_int32_foreign_message);
+  EXPECT_EQ(1234, message.map_int32_foreign_message().at(4321).c());
+
+  // Test Reflection::AddAllocatedMessage
+  Message* free_entry_string_string =
+      MessageFactory::generated_factory()
+          ->GetPrototype(fd_map_string_string->message_type())
+          ->New();
+  entry_string_string->GetReflection()->SetString(
+      free_entry_string_string, fd_map_string_string->message_type()->field(0),
+      "4321");
+  entry_string_string->GetReflection()->SetString(
+      free_entry_string_string, fd_map_string_string->message_type()->field(1),
+      "1234");
+  refl->AddAllocatedMessage(&message, fd_map_string_string,
+                            free_entry_string_string);
+
+  // Test MutableRepeatedFieldRef::RemoveLast()
+  mmf_int32_int32.RemoveLast();
+  mmf_int32_double.RemoveLast();
+  mmf_string_string.RemoveLast();
+  mmf_int32_foreign_message.RemoveLast();
+  EXPECT_EQ(10, message.map_int32_int32().size());
+  EXPECT_EQ(10, message.map_int32_double().size());
+  EXPECT_EQ(11, message.map_string_string().size());
+  EXPECT_EQ(10, message.map_int32_foreign_message().size());
+
+  // Test MutableRepeatedFieldRef::SwapElements()
+  {
+    const Message& message0a = mmf_int32_int32.Get(0, entry_int32_int32.get());
+    int32_t int32_value0a =
+        message0a.GetReflection()->GetInt32(message0a, fd_map_int32_in32_value);
+    const Message& message9a = mmf_int32_int32.Get(9, entry_int32_int32.get());
+    int32_t int32_value9a =
+        message9a.GetReflection()->GetInt32(message9a, fd_map_int32_in32_value);
+
+    mmf_int32_int32.SwapElements(0, 9);
+
+    const Message& message0b = mmf_int32_int32.Get(0, entry_int32_int32.get());
+    int32_t int32_value0b =
+        message0b.GetReflection()->GetInt32(message0b, fd_map_int32_in32_value);
+    const Message& message9b = mmf_int32_int32.Get(9, entry_int32_int32.get());
+    int32_t int32_value9b =
+        message9b.GetReflection()->GetInt32(message9b, fd_map_int32_in32_value);
+
+    EXPECT_EQ(int32_value9a, int32_value0b);
+    EXPECT_EQ(int32_value0a, int32_value9b);
+  }
+
+  {
+    const Message& message0a =
+        mmf_int32_double.Get(0, entry_int32_double.get());
+    double double_value0a = message0a.GetReflection()->GetDouble(
+        message0a, fd_map_int32_double_value);
+    const Message& message9a =
+        mmf_int32_double.Get(9, entry_int32_double.get());
+    double double_value9a = message9a.GetReflection()->GetDouble(
+        message9a, fd_map_int32_double_value);
+
+    mmf_int32_double.SwapElements(0, 9);
+
+    const Message& message0b =
+        mmf_int32_double.Get(0, entry_int32_double.get());
+    double double_value0b = message0b.GetReflection()->GetDouble(
+        message0b, fd_map_int32_double_value);
+    const Message& message9b =
+        mmf_int32_double.Get(9, entry_int32_double.get());
+    double double_value9b = message9b.GetReflection()->GetDouble(
+        message9b, fd_map_int32_double_value);
+
+    EXPECT_EQ(double_value9a, double_value0b);
+    EXPECT_EQ(double_value0a, double_value9b);
+  }
+
+  {
+    const Message& message0a =
+        mmf_string_string.Get(0, entry_string_string.get());
+    std::string string_value0a = message0a.GetReflection()->GetString(
+        message0a, fd_map_string_string_value);
+    const Message& message9a =
+        mmf_string_string.Get(9, entry_string_string.get());
+    std::string string_value9a = message9a.GetReflection()->GetString(
+        message9a, fd_map_string_string_value);
+
+    mmf_string_string.SwapElements(0, 9);
+
+    const Message& message0b =
+        mmf_string_string.Get(0, entry_string_string.get());
+    std::string string_value0b = message0b.GetReflection()->GetString(
+        message0b, fd_map_string_string_value);
+    const Message& message9b =
+        mmf_string_string.Get(9, entry_string_string.get());
+    std::string string_value9b = message9b.GetReflection()->GetString(
+        message9b, fd_map_string_string_value);
+
+    EXPECT_EQ(string_value9a, string_value0b);
+    EXPECT_EQ(string_value0a, string_value9b);
+  }
+
+  {
+    const Message& message0a =
+        mmf_int32_foreign_message.Get(0, entry_int32_foreign_message.get());
+    const ForeignMessage& sub_message0a =
+        down_cast<const ForeignMessage&>(message0a.GetReflection()->GetMessage(
+            message0a, fd_map_int32_foreign_message_value));
+    int32_t int32_value0a = sub_message0a.c();
+    const Message& message9a =
+        mmf_int32_foreign_message.Get(9, entry_int32_foreign_message.get());
+    const ForeignMessage& sub_message9a =
+        down_cast<const ForeignMessage&>(message9a.GetReflection()->GetMessage(
+            message9a, fd_map_int32_foreign_message_value));
+    int32_t int32_value9a = sub_message9a.c();
+
+    mmf_int32_foreign_message.SwapElements(0, 9);
+
+    const Message& message0b =
+        mmf_int32_foreign_message.Get(0, entry_int32_foreign_message.get());
+    const ForeignMessage& sub_message0b =
+        down_cast<const ForeignMessage&>(message0b.GetReflection()->GetMessage(
+            message0b, fd_map_int32_foreign_message_value));
+    int32_t int32_value0b = sub_message0b.c();
+    const Message& message9b =
+        mmf_int32_foreign_message.Get(9, entry_int32_foreign_message.get());
+    const ForeignMessage& sub_message9b =
+        down_cast<const ForeignMessage&>(message9b.GetReflection()->GetMessage(
+            message9b, fd_map_int32_foreign_message_value));
+    int32_t int32_value9b = sub_message9b.c();
+
+    EXPECT_EQ(int32_value9a, int32_value0b);
+    EXPECT_EQ(int32_value0a, int32_value9b);
+  }
+
+  // TODO(b/181148674): After supporting arena agnostic delete or let map entry
+  // handle heap allocation, this could be removed.
+  if (message.GetArena() != nullptr) {
+    entry_int32_int32.release();
+    entry_int32_double.release();
+    entry_string_string.release();
+    entry_int32_foreign_message.release();
+  }
+}
+
+TEST_F(MapFieldReflectionTest, RepeatedFieldRefMergeFromAndSwap) {
+  // Set-up message content.
+  TestMap m0, m1, m2;
+  for (int i = 0; i < 10; ++i) {
+    (*m0.mutable_map_int32_int32())[i] = Func(i, 1);
+    (*m0.mutable_map_int32_double())[i] = Func(i, 2);
+    (*m0.mutable_map_string_string())[StrFunc(i, 1)] = StrFunc(i, 5);
+    (*m0.mutable_map_int32_foreign_message())[i].set_c(Func(i, 6));
+    (*m1.mutable_map_int32_int32())[i + 10] = Func(i, 11);
+    (*m1.mutable_map_int32_double())[i + 10] = Func(i, 12);
+    (*m1.mutable_map_string_string())[StrFunc(i + 10, 1)] = StrFunc(i, 15);
+    (*m1.mutable_map_int32_foreign_message())[i + 10].set_c(Func(i, 16));
+    (*m2.mutable_map_int32_int32())[i + 20] = Func(i, 21);
+    (*m2.mutable_map_int32_double())[i + 20] = Func(i, 22);
+    (*m2.mutable_map_string_string())[StrFunc(i + 20, 1)] = StrFunc(i, 25);
+    (*m2.mutable_map_int32_foreign_message())[i + 20].set_c(Func(i, 26));
+  }
+
+  const Reflection* refl = m0.GetReflection();
+  const Descriptor* desc = m0.GetDescriptor();
+
+  // Get FieldDescriptors for all the fields of interest.
+  const FieldDescriptor* fd_map_int32_int32 =
+      desc->FindFieldByName("map_int32_int32");
+  const FieldDescriptor* fd_map_int32_double =
+      desc->FindFieldByName("map_int32_double");
+  const FieldDescriptor* fd_map_string_string =
+      desc->FindFieldByName("map_string_string");
+  const FieldDescriptor* fd_map_int32_foreign_message =
+      desc->FindFieldByName("map_int32_foreign_message");
+
+  // Get MutableRepeatedFieldRef objects for all fields of interest.
+  const MutableRepeatedFieldRef<Message> mmf_int32_int32 =
+      refl->GetMutableRepeatedFieldRef<Message>(&m0, fd_map_int32_int32);
+  const MutableRepeatedFieldRef<Message> mmf_int32_double =
+      refl->GetMutableRepeatedFieldRef<Message>(&m0, fd_map_int32_double);
+  const MutableRepeatedFieldRef<Message> mmf_string_string =
+      refl->GetMutableRepeatedFieldRef<Message>(&m0, fd_map_string_string);
+  const MutableRepeatedFieldRef<Message> mmf_int32_foreign_message =
+      refl->GetMutableRepeatedFieldRef<Message>(&m0,
+                                                fd_map_int32_foreign_message);
+
+  // Test MutableRepeatedRef::CopyFrom
+  mmf_int32_int32.CopyFrom(
+      refl->GetRepeatedFieldRef<Message>(m1, fd_map_int32_int32));
+  mmf_int32_double.CopyFrom(
+      refl->GetRepeatedFieldRef<Message>(m1, fd_map_int32_double));
+  mmf_string_string.CopyFrom(
+      refl->GetRepeatedFieldRef<Message>(m1, fd_map_string_string));
+  mmf_int32_foreign_message.CopyFrom(
+      refl->GetRepeatedFieldRef<Message>(m1, fd_map_int32_foreign_message));
+
+  for (int i = 0; i < 10; ++i) {
+    EXPECT_EQ(Func(i, 11), m0.map_int32_int32().at(i + 10));
+    EXPECT_EQ(Func(i, 12), m0.map_int32_double().at(i + 10));
+    EXPECT_EQ(StrFunc(i, 15), m0.map_string_string().at(StrFunc(i + 10, 1)));
+    EXPECT_EQ(Func(i, 16), m0.map_int32_foreign_message().at(i + 10).c());
+  }
+
+  // Test MutableRepeatedRef::MergeFrom
+  mmf_int32_int32.MergeFrom(
+      refl->GetRepeatedFieldRef<Message>(m2, fd_map_int32_int32));
+  mmf_int32_double.MergeFrom(
+      refl->GetRepeatedFieldRef<Message>(m2, fd_map_int32_double));
+  mmf_string_string.MergeFrom(
+      refl->GetRepeatedFieldRef<Message>(m2, fd_map_string_string));
+  mmf_int32_foreign_message.MergeFrom(
+      refl->GetRepeatedFieldRef<Message>(m2, fd_map_int32_foreign_message));
+  for (int i = 0; i < 10; ++i) {
+    EXPECT_EQ(Func(i, 21), m0.map_int32_int32().at(i + 20));
+    EXPECT_EQ(Func(i, 22), m0.map_int32_double().at(i + 20));
+    EXPECT_EQ(StrFunc(i, 25), m0.map_string_string().at(StrFunc(i + 20, 1)));
+    EXPECT_EQ(Func(i, 26), m0.map_int32_foreign_message().at(i + 20).c());
+  }
+
+  // Test MutableRepeatedRef::Swap
+  // Swap between m0 and m2.
+  mmf_int32_int32.Swap(
+      refl->GetMutableRepeatedFieldRef<Message>(&m2, fd_map_int32_int32));
+  mmf_int32_double.Swap(
+      refl->GetMutableRepeatedFieldRef<Message>(&m2, fd_map_int32_double));
+  mmf_string_string.Swap(
+      refl->GetMutableRepeatedFieldRef<Message>(&m2, fd_map_string_string));
+  mmf_int32_foreign_message.Swap(refl->GetMutableRepeatedFieldRef<Message>(
+      &m2, fd_map_int32_foreign_message));
+  for (int i = 0; i < 10; ++i) {
+    // Check the content of m0.
+    EXPECT_EQ(Func(i, 21), m0.map_int32_int32().at(i + 20));
+    EXPECT_EQ(Func(i, 22), m0.map_int32_double().at(i + 20));
+    EXPECT_EQ(StrFunc(i, 25), m0.map_string_string().at(StrFunc(i + 20, 1)));
+    EXPECT_EQ(Func(i, 26), m0.map_int32_foreign_message().at(i + 20).c());
+
+    // Check the content of m2.
+    EXPECT_EQ(Func(i, 11), m2.map_int32_int32().at(i + 10));
+    EXPECT_EQ(Func(i, 12), m2.map_int32_double().at(i + 10));
+    EXPECT_EQ(StrFunc(i, 15), m2.map_string_string().at(StrFunc(i + 10, 1)));
+    EXPECT_EQ(Func(i, 16), m2.map_int32_foreign_message().at(i + 10).c());
+    EXPECT_EQ(Func(i, 21), m2.map_int32_int32().at(i + 20));
+    EXPECT_EQ(Func(i, 22), m2.map_int32_double().at(i + 20));
+    EXPECT_EQ(StrFunc(i, 25), m2.map_string_string().at(StrFunc(i + 20, 1)));
+    EXPECT_EQ(Func(i, 26), m2.map_int32_foreign_message().at(i + 20).c());
+  }
+
+  // TODO(teboring): add test for duplicated key
+}
+
+TEST_F(MapFieldReflectionTest, MapSizeWithDuplicatedKey) {
+  // Dynamic Message
+  {
+    DynamicMessageFactory factory;
+    std::unique_ptr<Message> message(
+        factory.GetPrototype(UNITTEST::TestMap::descriptor())->New());
+    const Reflection* reflection = message->GetReflection();
+    const FieldDescriptor* field =
+        UNITTEST::TestMap::descriptor()->FindFieldByName("map_int32_int32");
+
+    Message* entry1 = reflection->AddMessage(message.get(), field);
+    Message* entry2 = reflection->AddMessage(message.get(), field);
+
+    const Reflection* entry_reflection = entry1->GetReflection();
+    const FieldDescriptor* key_field = entry1->GetDescriptor()->map_key();
+    entry_reflection->SetInt32(entry1, key_field, 1);
+    entry_reflection->SetInt32(entry2, key_field, 1);
+
+    EXPECT_EQ(2, reflection->FieldSize(*message, field));
+    EXPECT_EQ(1, MapSize(reflection, field, *message));
+    EXPECT_EQ(2, reflection->FieldSize(*message, field));
+  }
+
+  // Generated Message
+  {
+    UNITTEST::TestMap message;
+    const Reflection* reflection = message.GetReflection();
+    const FieldDescriptor* field =
+        message.GetDescriptor()->FindFieldByName("map_int32_int32");
+
+    Message* entry1 = reflection->AddMessage(&message, field);
+    Message* entry2 = reflection->AddMessage(&message, field);
+
+    const Reflection* entry_reflection = entry1->GetReflection();
+    const FieldDescriptor* key_field = entry1->GetDescriptor()->map_key();
+    entry_reflection->SetInt32(entry1, key_field, 1);
+    entry_reflection->SetInt32(entry2, key_field, 1);
+
+    EXPECT_EQ(2, reflection->FieldSize(message, field));
+    EXPECT_EQ(1, MapSize(reflection, field, message));
+  }
+}
+
+TEST_F(MapFieldReflectionTest, UninitializedEntry) {
+  UNITTEST::TestRequiredMessageMap message;
+  const Reflection* reflection = message.GetReflection();
+  const FieldDescriptor* field =
+      message.GetDescriptor()->FindFieldByName("map_field");
+  auto entry = reflection->AddMessage(&message, field);
+  EXPECT_FALSE(entry->IsInitialized());
+  EXPECT_FALSE(message.IsInitialized());
+}
+
+class MyMapEntry
+    : public internal::MapEntry<MyMapEntry, ::int32_t, ::int32_t,
+                                internal::WireFormatLite::TYPE_INT32,
+                                internal::WireFormatLite::TYPE_INT32> {
+ public:
+  constexpr MyMapEntry() {}
+  MyMapEntry(Arena*) { std::abort(); }
+  Metadata GetMetadata() const override { std::abort(); }
+  static bool ValidateKey(void*) { return true; }
+  static bool ValidateValue(void*) { return true; }
+};
+
+class MyMapEntryLite
+    : public internal::MapEntryLite<MyMapEntryLite, ::int32_t, ::int32_t,
+                                    internal::WireFormatLite::TYPE_INT32,
+                                    internal::WireFormatLite::TYPE_INT32> {
+ public:
+  constexpr MyMapEntryLite() {}
+  explicit MyMapEntryLite(Arena*) { std::abort(); }
+  static bool ValidateKey(void*) { return true; }
+  static bool ValidateValue(void*) { return true; }
+};
+
+TEST(MapEntryTest, ConstInit) {
+  // This verifies that `MapEntry`, `MapEntryLite` and `MapEntryImpl` can be
+  // constant initialized.
+  PROTOBUF_CONSTINIT static MyMapEntry entry{};
+  EXPECT_NE(entry.SpaceUsed(), 0);
+
+  PROTOBUF_CONSTINIT static MyMapEntryLite entry_lite{};  // NOLINT
+  EXPECT_TRUE(entry_lite.IsInitialized());
+}
+
+// Generated Message Test ===========================================
+
+TEST(GeneratedMapFieldTest, Accessors) {
+  UNITTEST::TestMap message;
+
+  MapTestUtil::SetMapFields(&message);
+  MapTestUtil::ExpectMapFieldsSet(message);
+
+  MapTestUtil::ModifyMapFields(&message);
+  MapTestUtil::ExpectMapFieldsModified(message);
+}
+
+TEST(GeneratedMapFieldTest, SetMapFieldsInitialized) {
+  UNITTEST::TestMap message;
+
+  MapTestUtil::SetMapFieldsInitialized(&message);
+  MapTestUtil::ExpectMapFieldsSetInitialized(message);
+}
+
+TEST(GeneratedMapFieldTest, Proto2SetMapFieldsInitialized) {
+  UNITTEST::TestEnumMap message;
+  EXPECT_EQ(UNITTEST::PROTO2_MAP_ENUM_FOO,
+            (*message.mutable_known_map_field())[0]);
+}
+
+TEST(GeneratedMapFieldTest, Clear) {
+  UNITTEST::TestMap message;
+
+  MapTestUtil::SetMapFields(&message);
+  message.Clear();
+  MapTestUtil::ExpectClear(message);
+}
+
+TEST(GeneratedMapFieldTest, ClearMessageMap) {
+  UNITTEST::TestMessageMap message;
+
+  // Creates a TestAllTypes with default value
+  TestUtil::ExpectClear((*message.mutable_map_int32_message())[0]);
+}
+
+TEST(GeneratedMapFieldTest, CopyFrom) {
+  UNITTEST::TestMap message1, message2;
+
+  MapTestUtil::SetMapFields(&message1);
+  message2.CopyFrom(message1);
+  MapTestUtil::ExpectMapFieldsSet(message2);
+
+  // Copying from self should be a no-op.
+  message2.CopyFrom(message2);
+  MapTestUtil::ExpectMapFieldsSet(message2);
+}
+
+TEST(GeneratedMapFieldTest, CopyFromMessageMap) {
+  UNITTEST::TestMessageMap message1, message2;
+
+  (*message1.mutable_map_int32_message())[0].add_repeated_int32(100);
+  (*message2.mutable_map_int32_message())[0].add_repeated_int32(101);
+
+  message1.CopyFrom(message2);
+
+  // Checks repeated field is overwritten.
+  EXPECT_EQ(1, message1.map_int32_message().at(0).repeated_int32_size());
+  EXPECT_EQ(101, message1.map_int32_message().at(0).repeated_int32(0));
+}
+
+TEST(GeneratedMapFieldTest, SwapWithEmpty) {
+  UNITTEST::TestMap message1, message2;
+
+  MapTestUtil::SetMapFields(&message1);
+  MapTestUtil::ExpectMapFieldsSet(message1);
+  MapTestUtil::ExpectClear(message2);
+
+  message1.Swap(&message2);
+  MapTestUtil::ExpectMapFieldsSet(message2);
+  MapTestUtil::ExpectClear(message1);
+}
+
+TEST(GeneratedMapFieldTest, SwapWithSelf) {
+  UNITTEST::TestMap message;
+
+  MapTestUtil::SetMapFields(&message);
+  MapTestUtil::ExpectMapFieldsSet(message);
+
+  message.Swap(&message);
+  MapTestUtil::ExpectMapFieldsSet(message);
+}
+
+TEST(GeneratedMapFieldTest, SwapWithOther) {
+  UNITTEST::TestMap message1, message2;
+
+  MapTestUtil::SetMapFields(&message1);
+  MapTestUtil::SetMapFields(&message2);
+  MapTestUtil::ModifyMapFields(&message2);
+
+  message1.Swap(&message2);
+  MapTestUtil::ExpectMapFieldsModified(message1);
+  MapTestUtil::ExpectMapFieldsSet(message2);
+}
+
+TEST(GeneratedMapFieldTest, CopyConstructor) {
+  UNITTEST::TestMap message1;
+  MapTestUtil::SetMapFields(&message1);
+
+  UNITTEST::TestMap message2(message1);
+  MapTestUtil::ExpectMapFieldsSet(message2);
+}
+
+TEST(GeneratedMapFieldTest, CopyAssignmentOperator) {
+  UNITTEST::TestMap message1;
+  MapTestUtil::SetMapFields(&message1);
+
+  UNITTEST::TestMap message2;
+  message2 = message1;
+  MapTestUtil::ExpectMapFieldsSet(message2);
+
+  // Make sure that self-assignment does something sane.
+  message2.operator=(message2);
+  MapTestUtil::ExpectMapFieldsSet(message2);
+}
+
+#if !defined(PROTOBUF_TEST_NO_DESCRIPTORS) || PROTOBUF_RTTI
+TEST(GeneratedMapFieldTest, UpcastCopyFrom) {
+  // Test the CopyFrom method that takes in the generic const Message&
+  // parameter.
+  UNITTEST::TestMap message1, message2;
+
+  MapTestUtil::SetMapFields(&message1);
+
+  const Message* source = implicit_cast<const Message*>(&message1);
+  message2.CopyFrom(*source);
+
+  MapTestUtil::ExpectMapFieldsSet(message2);
+}
+#endif
+
+#ifndef PROTOBUF_TEST_NO_DESCRIPTORS
+
+TEST(GeneratedMapFieldTest, CopyFromDynamicMessage) {
+  // Test copying from a DynamicMessage, which must fall back to using
+  // reflection.
+  UNITTEST::TestMap message2;
+
+  // Construct a new version of the dynamic message via the factory.
+  DynamicMessageFactory factory;
+  std::unique_ptr<Message> message1;
+  message1.reset(factory.GetPrototype(UNITTEST::TestMap::descriptor())->New());
+  MapReflectionTester reflection_tester(UNITTEST::TestMap::descriptor());
+  reflection_tester.SetMapFieldsViaReflection(message1.get());
+  reflection_tester.ExpectMapFieldsSetViaReflection(*message1);
+  reflection_tester.ExpectMapFieldsSetViaReflectionIterator(message1.get());
+  message2.CopyFrom(*message1);
+  MapTestUtil::ExpectMapFieldsSet(message2);
+}
+
+TEST(GeneratedMapFieldTest, CopyFromDynamicMessageMapReflection) {
+  UNITTEST::TestMap message2;
+
+  // Construct a new version of the dynamic message via the factory.
+  DynamicMessageFactory factory;
+  std::unique_ptr<Message> message1;
+  message1.reset(factory.GetPrototype(UNITTEST::TestMap::descriptor())->New());
+  MapReflectionTester reflection_tester(UNITTEST::TestMap::descriptor());
+  reflection_tester.SetMapFieldsViaMapReflection(message1.get());
+  reflection_tester.ExpectMapFieldsSetViaReflection(*message1);
+  reflection_tester.ExpectMapFieldsSetViaReflectionIterator(message1.get());
+  message2.CopyFrom(*message1);
+  MapTestUtil::ExpectMapFieldsSet(message2);
+}
+
+TEST(GeneratedMapFieldTest, DynamicMessageMergeFromDynamicMessage) {
+  // Construct two dynamic message and sets via map reflection.
+  DynamicMessageFactory factory;
+  std::unique_ptr<Message> message1;
+  message1.reset(factory.GetPrototype(UNITTEST::TestMap::descriptor())->New());
+  MapReflectionTester reflection_tester(UNITTEST::TestMap::descriptor());
+  reflection_tester.SetMapFieldsViaMapReflection(message1.get());
+
+  // message2 is created by same factory.
+  std::unique_ptr<Message> message2;
+  message2.reset(factory.GetPrototype(UNITTEST::TestMap::descriptor())->New());
+  reflection_tester.SetMapFieldsViaMapReflection(message2.get());
+
+  // message3 is created by different factory.
+  DynamicMessageFactory factory3;
+  std::unique_ptr<Message> message3;
+  message3.reset(factory3.GetPrototype(UNITTEST::TestMap::descriptor())->New());
+  reflection_tester.SetMapFieldsViaMapReflection(message3.get());
+
+  message2->MergeFrom(*message1);
+  message3->MergeFrom(*message1);
+
+  // Test MergeFrom does not sync to repeated fields and
+  // there is no duplicate keys in text format.
+  std::string output1, output2, output3;
+  TextFormat::PrintToString(*message1, &output1);
+  TextFormat::PrintToString(*message2, &output2);
+  TextFormat::PrintToString(*message3, &output3);
+  EXPECT_EQ(output1, output2);
+  EXPECT_EQ(output1, output3);
+}
+
+TEST(GeneratedMapFieldTest, DynamicMessageCopyFrom) {
+  // Test copying to a DynamicMessage, which must fall back to using reflection.
+  UNITTEST::TestMap message2;
+  MapTestUtil::SetMapFields(&message2);
+
+  // Construct a new version of the dynamic message via the factory.
+  DynamicMessageFactory factory;
+  std::unique_ptr<Message> message1;
+  message1.reset(factory.GetPrototype(UNITTEST::TestMap::descriptor())->New());
+
+  MapReflectionTester reflection_tester(UNITTEST::TestMap::descriptor());
+  message1->MergeFrom(message2);
+  reflection_tester.ExpectMapFieldsSetViaReflection(*message1);
+  reflection_tester.ExpectMapFieldsSetViaReflectionIterator(message1.get());
+}
+
+TEST(GeneratedMapFieldTest, DynamicMessageCopyFromMapReflection) {
+  MapReflectionTester reflection_tester(UNITTEST::TestMap::descriptor());
+  UNITTEST::TestMap message2;
+  reflection_tester.SetMapFieldsViaMapReflection(&message2);
+
+  // Construct a dynamic message via the factory.
+  DynamicMessageFactory factory;
+  std::unique_ptr<Message> message1;
+  message1.reset(factory.GetPrototype(UNITTEST::TestMap::descriptor())->New());
+
+  message1->MergeFrom(message2);
+  reflection_tester.ExpectMapFieldsSetViaReflectionIterator(message1.get());
+  reflection_tester.ExpectMapFieldsSetViaReflection(*message1);
+}
+
+TEST(GeneratedMapFieldTest, SyncDynamicMapWithRepeatedField) {
+  // Construct a dynamic message via the factory.
+  MapReflectionTester reflection_tester(UNITTEST::TestMap::descriptor());
+  DynamicMessageFactory factory;
+  std::unique_ptr<Message> message;
+  message.reset(factory.GetPrototype(UNITTEST::TestMap::descriptor())->New());
+  reflection_tester.SetMapFieldsViaReflection(message.get());
+  reflection_tester.ExpectMapFieldsSetViaReflectionIterator(message.get());
+  reflection_tester.ExpectMapFieldsSetViaReflection(*message);
+}
+
+#endif  // !PROTOBUF_TEST_NO_DESCRIPTORS
+
+TEST(GeneratedMapFieldTest, NonEmptyMergeFrom) {
+  UNITTEST::TestMap message1, message2;
+
+  MapTestUtil::SetMapFields(&message1);
+
+  // This field will test merging into an empty spot.
+  (*message2.mutable_map_int32_int32())[1] = 1;
+  message1.mutable_map_int32_int32()->erase(1);
+
+  // This tests overwriting.
+  (*message2.mutable_map_int32_double())[1] = 1;
+  (*message1.mutable_map_int32_double())[1] = 2;
+
+  message1.MergeFrom(message2);
+  MapTestUtil::ExpectMapFieldsSet(message1);
+
+  // Test reflection MergeFrom does not sync to repeated field
+  // and there is no duplicated keys.
+  MapTestUtil::SetMapFields(&message1);
+  MapTestUtil::SetMapFields(&message2);
+
+  message2.MergeFrom(message1);
+
+  std::string output1, output2;
+  TextFormat::PrintToString(message1, &output1);
+  TextFormat::PrintToString(message2, &output2);
+  EXPECT_EQ(output1, output2);
+}
+
+TEST(GeneratedMapFieldTest, MergeFromMessageMap) {
+  UNITTEST::TestMessageMap message1, message2;
+
+  (*message1.mutable_map_int32_message())[0].add_repeated_int32(100);
+  (*message2.mutable_map_int32_message())[0].add_repeated_int32(101);
+
+  message1.MergeFrom(message2);
+
+  // Checks repeated field is overwritten.
+  EXPECT_EQ(1, message1.map_int32_message().at(0).repeated_int32_size());
+  EXPECT_EQ(101, message1.map_int32_message().at(0).repeated_int32(0));
+}
+
+// Test the generated SerializeWithCachedSizesToArray()
+TEST(GeneratedMapFieldTest, SerializationToArray) {
+  UNITTEST::TestMap message1, message2;
+  std::string data;
+  MapTestUtil::SetMapFields(&message1);
+  size_t size = message1.ByteSizeLong();
+  data.resize(size);
+  uint8_t* start = reinterpret_cast<uint8_t*>(::google::protobuf::string_as_array(&data));
+  uint8_t* end = message1.SerializeWithCachedSizesToArray(start);
+  EXPECT_EQ(size, end - start);
+  EXPECT_TRUE(message2.ParseFromString(data));
+  MapTestUtil::ExpectMapFieldsSet(message2);
+}
+
+// Test the generated SerializeWithCachedSizes()
+TEST(GeneratedMapFieldTest, SerializationToStream) {
+  UNITTEST::TestMap message1, message2;
+  MapTestUtil::SetMapFields(&message1);
+  size_t size = message1.ByteSizeLong();
+  std::string data;
+  data.resize(size);
+  {
+    // Allow the output stream to buffer only one byte at a time.
+    io::ArrayOutputStream array_stream(::google::protobuf::string_as_array(&data), size, 1);
+    io::CodedOutputStream output_stream(&array_stream);
+    message1.SerializeWithCachedSizes(&output_stream);
+    EXPECT_FALSE(output_stream.HadError());
+    EXPECT_EQ(size, output_stream.ByteCount());
+  }
+  EXPECT_TRUE(message2.ParseFromString(data));
+  MapTestUtil::ExpectMapFieldsSet(message2);
+}
+
+TEST(GeneratedMapFieldTest, ParseFailsIfMalformed) {
+  UNITTEST::TestMapSubmessage o, p;
+  auto m = o.mutable_test_map()->mutable_map_int32_foreign_message();
+  (*m)[0].set_c(-1);
+  std::string serialized;
+  EXPECT_TRUE(o.SerializeToString(&serialized));
+
+  // Should parse correctly.
+  EXPECT_TRUE(p.ParseFromString(serialized));
+
+  // Overwriting the last byte to 0xFF results in malformed wire.
+  serialized[serialized.size() - 1] = 0xFF;
+  EXPECT_FALSE(p.ParseFromString(serialized));
+}
+
+
+TEST(GeneratedMapFieldTest, SameTypeMaps) {
+  const Descriptor* map1 = UNITTEST::TestSameTypeMap::descriptor()
+                               ->FindFieldByName("map1")
+                               ->message_type();
+  const Descriptor* map2 = UNITTEST::TestSameTypeMap::descriptor()
+                               ->FindFieldByName("map2")
+                               ->message_type();
+
+  const Message* map1_entry =
+      MessageFactory::generated_factory()->GetPrototype(map1);
+  const Message* map2_entry =
+      MessageFactory::generated_factory()->GetPrototype(map2);
+
+  EXPECT_EQ(map1, map1_entry->GetDescriptor());
+  EXPECT_EQ(map2, map2_entry->GetDescriptor());
+}
+
+TEST(GeneratedMapFieldTest, Proto2UnknownEnum) {
+  UNITTEST::TestEnumMapPlusExtra from;
+  (*from.mutable_known_map_field())[0] = UNITTEST::E_PROTO2_MAP_ENUM_FOO;
+  (*from.mutable_unknown_map_field())[0] = UNITTEST::E_PROTO2_MAP_ENUM_EXTRA;
+  std::string data;
+  from.SerializeToString(&data);
+
+  UNITTEST::TestEnumMap to;
+  EXPECT_TRUE(to.ParseFromString(data));
+  EXPECT_EQ(0, to.unknown_map_field().size());
+  const UnknownFieldSet& unknown_field_set =
+      to.GetReflection()->GetUnknownFields(to);
+  EXPECT_EQ(1, unknown_field_set.field_count());
+  EXPECT_EQ(1, to.known_map_field().size());
+  EXPECT_EQ(UNITTEST::PROTO2_MAP_ENUM_FOO, to.known_map_field().at(0));
+
+  data.clear();
+  from.Clear();
+  to.SerializeToString(&data);
+  EXPECT_TRUE(from.ParseFromString(data));
+  EXPECT_EQ(0, from.GetReflection()->GetUnknownFields(from).field_count());
+  EXPECT_EQ(1, from.known_map_field().size());
+  EXPECT_EQ(UNITTEST::E_PROTO2_MAP_ENUM_FOO, from.known_map_field().at(0));
+  EXPECT_EQ(1, from.unknown_map_field().size());
+  EXPECT_EQ(UNITTEST::E_PROTO2_MAP_ENUM_EXTRA, from.unknown_map_field().at(0));
+}
+
+TEST(GeneratedMapFieldTest, StandardWireFormat) {
+  UNITTEST::TestMap message;
+  std::string data = "\x0A\x04\x08\x01\x10\x01";
+
+  EXPECT_TRUE(message.ParseFromString(data));
+  EXPECT_EQ(1, message.map_int32_int32().size());
+  EXPECT_EQ(1, message.map_int32_int32().at(1));
+}
+
+TEST(GeneratedMapFieldTest, UnorderedWireFormat) {
+  UNITTEST::TestMap message;
+
+  // put value before key in wire format
+  std::string data = "\x0A\x04\x10\x01\x08\x02";
+
+  EXPECT_TRUE(message.ParseFromString(data));
+  EXPECT_EQ(1, message.map_int32_int32().size());
+  ASSERT_NE(message.map_int32_int32().find(2), message.map_int32_int32().end());
+  EXPECT_EQ(1, message.map_int32_int32().at(2));
+}
+
+TEST(GeneratedMapFieldTest, DuplicatedKeyWireFormat) {
+  UNITTEST::TestMap message;
+
+  // Two key fields in wire format
+  std::string data = "\x0A\x06\x08\x01\x08\x02\x10\x01";
+
+  EXPECT_TRUE(message.ParseFromString(data));
+  EXPECT_EQ(1, message.map_int32_int32().size());
+  EXPECT_EQ(1, message.map_int32_int32().at(2));
+
+  // A similar test, but with a map from int to a message type.
+  // Again, we want to be sure that the "second one wins" when
+  // there are two separate entries with the same key.
+  const int key = 99;
+  UNITTEST::TestRequiredMessageMap map_message;
+  UNITTEST::TestRequired with_dummy4;
+  with_dummy4.set_a(0);
+  with_dummy4.set_b(0);
+  with_dummy4.set_c(0);
+  with_dummy4.set_dummy4(11);
+  (*map_message.mutable_map_field())[key] = with_dummy4;
+  std::string s = map_message.SerializeAsString();
+  UNITTEST::TestRequired with_dummy5;
+  with_dummy5.set_a(0);
+  with_dummy5.set_b(0);
+  with_dummy5.set_c(0);
+  with_dummy5.set_dummy5(12);
+  (*map_message.mutable_map_field())[key] = with_dummy5;
+  std::string both = s + map_message.SerializeAsString();
+  // We don't expect a merge now.  The "second one wins."
+  ASSERT_TRUE(map_message.ParseFromString(both));
+  ASSERT_EQ(1, map_message.map_field().size());
+  ASSERT_EQ(1, map_message.map_field().count(key));
+  EXPECT_EQ(0, map_message.map_field().find(key)->second.a());
+  EXPECT_EQ(0, map_message.map_field().find(key)->second.b());
+  EXPECT_EQ(0, map_message.map_field().find(key)->second.c());
+  EXPECT_FALSE(map_message.map_field().find(key)->second.has_dummy4());
+  ASSERT_TRUE(map_message.map_field().find(key)->second.has_dummy5());
+  EXPECT_EQ(12, map_message.map_field().find(key)->second.dummy5());
+}
+
+// Exhaustive combinations of keys, values, and junk in any order.
+// This re-tests some of the things tested above, but if it fails
+// it's more work to determine what went wrong, so it isn't necessarily
+// bad that we have the simpler tests too.
+TEST(GeneratedMapFieldTest, KeysValuesUnknownsWireFormat) {
+  UNITTEST::TestMap message;
+  const int kMaxNumKeysAndValuesAndJunk = 4;
+  const char kKeyTag = 0x08;
+  const char kValueTag = 0x10;
+  const char kJunkTag = 0x20;
+  for (int items = 0; items <= kMaxNumKeysAndValuesAndJunk; items++) {
+    std::string data = "\x0A";
+    // Encode length of what will follow.
+    data.push_back(items * 2);
+    static const int kBitsOfIPerItem = 4;
+    static const int mask = (1 << kBitsOfIPerItem) - 1;
+    // Each iteration of the following is a test.  It uses i as bit vector
+    // encoding the keys and values to put in the wire format.
+    for (int i = 0; i < (1 << (items * kBitsOfIPerItem)); i++) {
+      std::string wire_format = data;
+      int expected_key = 0;
+      int expected_value = 0;
+      for (int k = i, j = 0; j < items; j++, k >>= kBitsOfIPerItem) {
+        bool is_key = k & 0x1;
+        bool is_value = !is_key && (k & 0x2);
+        wire_format.push_back(is_key ? kKeyTag
+                                     : is_value ? kValueTag : kJunkTag);
+        char c = static_cast<char>(k & mask) >> 2;  // One char after the tag.
+        wire_format.push_back(c);
+        if (is_key) expected_key = static_cast<int>(c);
+        if (is_value) expected_value = static_cast<int>(c);
+        bool res = message.ParseFromString(wire_format);
+        bool expect_success = true;
+        // Unfortunately the old map parser accepts malformed input, the new
+        // parser accepts only correct input.
+        if (j != items - 1) expect_success = false;
+        if (expect_success) {
+          ASSERT_TRUE(res);
+          ASSERT_EQ(1, message.map_int32_int32().size());
+          ASSERT_EQ(expected_key, message.map_int32_int32().begin()->first);
+          ASSERT_EQ(expected_value, message.map_int32_int32().begin()->second);
+        } else {
+          ASSERT_FALSE(res);
+        }
+      }
+    }
+  }
+}
+
+TEST(GeneratedMapFieldTest, DuplicatedValueWireFormat) {
+  UNITTEST::TestMap message;
+
+  // Two value fields in wire format
+  std::string data = "\x0A\x06\x08\x01\x10\x01\x10\x02";
+
+  EXPECT_TRUE(message.ParseFromString(data));
+  EXPECT_EQ(1, message.map_int32_int32().size());
+  EXPECT_EQ(2, message.map_int32_int32().at(1));
+}
+
+TEST(GeneratedMapFieldTest, MissedKeyWireFormat) {
+  UNITTEST::TestMap message;
+
+  // No key field in wire format
+  std::string data = "\x0A\x02\x10\x01";
+
+  EXPECT_TRUE(message.ParseFromString(data));
+  EXPECT_EQ(1, message.map_int32_int32().size());
+  ASSERT_NE(message.map_int32_int32().find(0), message.map_int32_int32().end());
+  EXPECT_EQ(1, message.map_int32_int32().at(0));
+}
+
+TEST(GeneratedMapFieldTest, MissedValueWireFormat) {
+  UNITTEST::TestMap message;
+
+  // No value field in wire format
+  std::string data = "\x0A\x02\x08\x01";
+
+  EXPECT_TRUE(message.ParseFromString(data));
+  EXPECT_EQ(1, message.map_int32_int32().size());
+  ASSERT_NE(message.map_int32_int32().find(1), message.map_int32_int32().end());
+  EXPECT_EQ(0, message.map_int32_int32().at(1));
+}
+
+TEST(GeneratedMapFieldTest, MissedValueTextFormat) {
+  UNITTEST::TestMap message;
+
+  // No value field in text format
+  std::string text =
+      "map_int32_foreign_message {\n"
+      "  key: 1234567890\n"
+      "}";
+
+  EXPECT_TRUE(TextFormat::ParseFromString(text, &message));
+  EXPECT_EQ(1, message.map_int32_foreign_message().size());
+  EXPECT_EQ(11, message.ByteSizeLong());
+}
+
+TEST(GeneratedMapFieldTest, UnknownFieldWireFormat) {
+  UNITTEST::TestMap message;
+
+  // Unknown field in wire format
+  std::string data = "\x0A\x06\x08\x02\x10\x03\x18\x01";
+
+  EXPECT_TRUE(message.ParseFromString(data));
+  EXPECT_EQ(1, message.map_int32_int32().size());
+  EXPECT_EQ(3, message.map_int32_int32().at(2));
+}
+
+TEST(GeneratedMapFieldTest, CorruptedWireFormat) {
+  UNITTEST::TestMap message;
+
+  // corrupted data in wire format
+  std::string data = "\x0A\x06\x08\x02\x11\x03";
+
+  EXPECT_FALSE(message.ParseFromString(data));
+}
+
+TEST(GeneratedMapFieldTest, IsInitialized) {
+  UNITTEST::TestRequiredMessageMap map_message;
+
+  // Add an uninitialized message.
+  (*map_message.mutable_map_field())[0];
+  EXPECT_FALSE(map_message.IsInitialized());
+
+  // Initialize uninitialized message
+  (*map_message.mutable_map_field())[0].set_a(0);
+  (*map_message.mutable_map_field())[0].set_b(0);
+  (*map_message.mutable_map_field())[0].set_c(0);
+  EXPECT_TRUE(map_message.IsInitialized());
+}
+
+TEST(GeneratedMapFieldTest, SpaceUsed) {
+  UNITTEST::TestRequiredMessageMap map_message;
+  const size_t initial = map_message.SpaceUsed();
+  const size_t space_used_message = UNITTEST::TestRequired().SpaceUsed();
+
+  auto& m = *map_message.mutable_map_field();
+  constexpr int kNumValues = 100;
+  for (int i = 0; i < kNumValues; ++i) {
+    m[i];
+  }
+
+  // The exact value will depend on internal state, like collisions,
+  // so we can't predict it. But we can predict a lower bound.
+  size_t lower_bound =
+      initial + kNumValues * (space_used_message + sizeof(int32_t) +
+                              /* Node::next */ sizeof(void*) +
+                              /* table entry */ sizeof(void*));
+
+  EXPECT_LE(lower_bound, map_message.SpaceUsed());
+}
+
+TEST(GeneratedMapFieldTest, MessagesMustMerge) {
+  UNITTEST::TestRequiredMessageMap map_message;
+
+  UNITTEST::TestRequired with_dummy4;
+  with_dummy4.set_a(97);
+  with_dummy4.set_b(91);
+  with_dummy4.set_dummy4(98);
+  EXPECT_FALSE(with_dummy4.IsInitialized());
+  (*map_message.mutable_map_field())[0] = with_dummy4;
+  EXPECT_FALSE(map_message.IsInitialized());
+
+  UNITTEST::TestRequired with_dummy5;
+  with_dummy5.set_b(0);
+  with_dummy5.set_c(33);
+  with_dummy5.set_dummy5(99);
+  EXPECT_FALSE(with_dummy5.IsInitialized());
+  (*map_message.mutable_map_field())[0] = with_dummy5;
+  EXPECT_FALSE(map_message.IsInitialized());
+
+  // The wire format of MapEntry is straightforward (*) and can be manually
+  // constructed to force merging of two uninitialized messages that would
+  // result in an initialized message.
+  //
+  // (*) http://google3/net/proto2/internal/map_test.cc?l=2433&rcl=310012028
+  std::string dummy4_s = with_dummy4.SerializePartialAsString();
+  std::string dummy5_s = with_dummy5.SerializePartialAsString();
+  int payload_size = dummy4_s.size() + dummy5_s.size();
+  // Makes sure the payload size fits into one byte.
+  ASSERT_LT(payload_size, 128);
+
+  std::string s(6, 0);
+  char* p = &s[0];
+  *p++ = WireFormatLite::MakeTag(1, WireFormatLite::WIRETYPE_LENGTH_DELIMITED);
+  // Length: 2B for key tag & val and 2B for val tag and length of the following
+  // payload.
+  *p++ = 4 + payload_size;
+  *p++ = WireFormatLite::MakeTag(1, WireFormatLite::WIRETYPE_VARINT);
+  *p++ = 0;
+  *p++ = WireFormatLite::MakeTag(2, WireFormatLite::WIRETYPE_LENGTH_DELIMITED);
+  *p++ = payload_size;
+  StrAppend(&s, dummy4_s, dummy5_s);
+
+  // Test key then value then value.
+  int key = 0;
+  ASSERT_TRUE(map_message.ParseFromString(s));
+  ASSERT_EQ(1, map_message.map_field().size());
+  ASSERT_EQ(1, map_message.map_field().count(key));
+  EXPECT_EQ(97, map_message.map_field().find(key)->second.a());
+  EXPECT_EQ(0, map_message.map_field().find(key)->second.b());
+  EXPECT_EQ(33, map_message.map_field().find(key)->second.c());
+  EXPECT_EQ(98, map_message.map_field().find(key)->second.dummy4());
+  EXPECT_EQ(99, map_message.map_field().find(key)->second.dummy5());
+
+  // Test key then value then value then key.
+  s.push_back(s[2]);  // Copy the key's tag.
+  key = 19;
+  s.push_back(key);  // Second key is 19 instead of 0.
+  s[1] += 2;         // Adjust encoded size.
+  ASSERT_TRUE(map_message.ParseFromString(s));
+  ASSERT_EQ(1, map_message.map_field().size());
+  ASSERT_EQ(1, map_message.map_field().count(key));
+  EXPECT_EQ(97, map_message.map_field().find(key)->second.a());
+  EXPECT_EQ(0, map_message.map_field().find(key)->second.b());
+  EXPECT_EQ(33, map_message.map_field().find(key)->second.c());
+  EXPECT_EQ(98, map_message.map_field().find(key)->second.dummy4());
+  EXPECT_EQ(99, map_message.map_field().find(key)->second.dummy5());
+}
+
+// Generated Message Reflection Test ================================
+
+TEST(GeneratedMapFieldReflectionTest, SpaceUsed) {
+  UNITTEST::TestMap message;
+  MapReflectionTester reflection_tester(UNITTEST::TestMap::descriptor());
+  reflection_tester.SetMapFieldsViaReflection(&message);
+
+  EXPECT_LT(0, message.GetReflection()->SpaceUsedLong(message));
+}
+
+TEST(GeneratedMapFieldReflectionTest, Accessors) {
+  // Set every field to a unique value then go back and check all those
+  // values.
+  UNITTEST::TestMap message;
+  MapReflectionTester reflection_tester(UNITTEST::TestMap::descriptor());
+  reflection_tester.SetMapFieldsViaReflection(&message);
+  MapTestUtil::ExpectMapFieldsSet(message);
+  reflection_tester.ExpectMapFieldsSetViaReflection(message);
+  reflection_tester.ExpectMapFieldsSetViaReflectionIterator(&message);
+
+  reflection_tester.ModifyMapFieldsViaReflection(&message);
+  MapTestUtil::ExpectMapFieldsModified(message);
+}
+
+TEST(GeneratedMapFieldReflectionTest, Swap) {
+  UNITTEST::TestMap message1;
+  UNITTEST::TestMap message2;
+
+  MapTestUtil::SetMapFields(&message1);
+
+  const Reflection* reflection = message1.GetReflection();
+  reflection->Swap(&message1, &message2);
+
+  MapTestUtil::ExpectClear(message1);
+  MapTestUtil::ExpectMapFieldsSet(message2);
+}
+
+TEST(GeneratedMapFieldReflectionTest, SwapWithBothSet) {
+  UNITTEST::TestMap message1;
+  UNITTEST::TestMap message2;
+
+  MapTestUtil::SetMapFields(&message1);
+  MapTestUtil::SetMapFields(&message2);
+  MapTestUtil::ModifyMapFields(&message2);
+
+  const Reflection* reflection = message1.GetReflection();
+  reflection->Swap(&message1, &message2);
+
+  MapTestUtil::ExpectMapFieldsModified(message1);
+  MapTestUtil::ExpectMapFieldsSet(message2);
+}
+
+TEST(GeneratedMapFieldReflectionTest, SwapFields) {
+  UNITTEST::TestMap message1;
+  UNITTEST::TestMap message2;
+
+  MapTestUtil::SetMapFields(&message2);
+
+  std::vector<const FieldDescriptor*> fields;
+  const Reflection* reflection = message1.GetReflection();
+  reflection->ListFields(message2, &fields);
+  reflection->SwapFields(&message1, &message2, fields);
+
+  MapTestUtil::ExpectMapFieldsSet(message1);
+  MapTestUtil::ExpectClear(message2);
+}
+
+TEST(GeneratedMapFieldReflectionTest, ClearField) {
+  UNITTEST::TestMap message;
+  MapTestUtil::SetMapFields(&message);
+  MapTestUtil::ExpectMapFieldsSet(message);
+
+  MapReflectionTester reflection_tester(UNITTEST::TestMap::descriptor());
+  reflection_tester.ClearMapFieldsViaReflection(&message);
+  reflection_tester.ExpectClearViaReflection(message);
+  reflection_tester.ExpectClearViaReflectionIterator(&message);
+}
+
+TEST(GeneratedMapFieldReflectionTest, RemoveLast) {
+  UNITTEST::TestMap message;
+  MapReflectionTester reflection_tester(UNITTEST::TestMap::descriptor());
+
+  MapTestUtil::SetMapFields(&message);
+  MapTestUtil::ExpectMapsSize(message, 2);
+  std::vector<const Message*> expected_entries =
+      MapTestUtil::GetMapEntries(message, 0);
+
+  reflection_tester.RemoveLastMapsViaReflection(&message);
+
+  MapTestUtil::ExpectMapsSize(message, 1);
+  std::vector<const Message*> remained_entries =
+      MapTestUtil::GetMapEntries(message, 0);
+  EXPECT_TRUE(expected_entries == remained_entries);
+}
+
+TEST(GeneratedMapFieldReflectionTest, ReleaseLast) {
+  UNITTEST::TestMap message;
+  const Descriptor* descriptor = message.GetDescriptor();
+  MapReflectionTester reflection_tester(descriptor);
+
+  MapTestUtil::SetMapFields(&message);
+
+  MapTestUtil::ExpectMapsSize(message, 2);
+
+  reflection_tester.ReleaseLastMapsViaReflection(&message);
+
+  MapTestUtil::ExpectMapsSize(message, 1);
+
+  // Now test that we actually release the right message.
+  message.Clear();
+  MapTestUtil::SetMapFields(&message);
+
+  MapTestUtil::ExpectMapsSize(message, 2);
+  std::vector<const Message*> expect_last =
+      MapTestUtil::GetMapEntries(message, 1);
+  std::vector<const Message*> release_last =
+      MapTestUtil::GetMapEntriesFromRelease(&message);
+  MapTestUtil::ExpectMapsSize(message, 1);
+  EXPECT_TRUE(expect_last == release_last);
+  for (std::vector<const Message*>::iterator it = release_last.begin();
+       it != release_last.end(); ++it) {
+    delete *it;
+  }
+}
+
+TEST(GeneratedMapFieldReflectionTest, SwapElements) {
+  UNITTEST::TestMap message;
+  MapReflectionTester reflection_tester(UNITTEST::TestMap::descriptor());
+
+  MapTestUtil::SetMapFields(&message);
+
+  // Get pointers of map entries at their original position
+  std::vector<const Message*> entries0 = MapTestUtil::GetMapEntries(message, 0);
+  std::vector<const Message*> entries1 = MapTestUtil::GetMapEntries(message, 1);
+
+  // Swap the first time.
+  reflection_tester.SwapMapsViaReflection(&message);
+
+  // Get pointer of map entry after swap once.
+  std::vector<const Message*> entries0_once =
+      MapTestUtil::GetMapEntries(message, 0);
+  std::vector<const Message*> entries1_once =
+      MapTestUtil::GetMapEntries(message, 1);
+
+  // Test map entries are swapped.
+  MapTestUtil::ExpectMapsSize(message, 2);
+  EXPECT_TRUE(entries0 == entries1_once);
+  EXPECT_TRUE(entries1 == entries0_once);
+
+  // Swap the second time.
+  reflection_tester.SwapMapsViaReflection(&message);
+
+  // Get pointer of map entry after swap once.
+  std::vector<const Message*> entries0_twice =
+      MapTestUtil::GetMapEntries(message, 0);
+  std::vector<const Message*> entries1_twice =
+      MapTestUtil::GetMapEntries(message, 1);
+
+  // Test map entries are swapped back.
+  MapTestUtil::ExpectMapsSize(message, 2);
+  EXPECT_TRUE(entries0 == entries0_twice);
+  EXPECT_TRUE(entries1 == entries1_twice);
+}
+
+TEST(GeneratedMapFieldReflectionTest, MutableUnknownFields) {
+  UNITTEST::TestMap message;
+  MapReflectionTester reflection_tester(UNITTEST::TestMap::descriptor());
+  reflection_tester.MutableUnknownFieldsOfMapFieldsViaReflection(&message);
+}
+
+TEST(GeneratedMapFieldReflectionTest, EmbedProto2Message) {
+  UNITTEST::TestMessageMap message;
+
+  const FieldDescriptor* map_field =
+      UNITTEST::TestMessageMap::descriptor()->FindFieldByName(
+          "map_int32_message");
+  const FieldDescriptor* value = map_field->message_type()->map_value();
+
+  Message* entry_message =
+      message.GetReflection()->AddMessage(&message, map_field);
+  EXPECT_EQ(
+      &entry_message->GetReflection()->GetMessage(*entry_message, value),
+      reinterpret_cast<const Message*>(&TestAllTypes::default_instance()));
+
+  Message* proto2_message =
+      entry_message->GetReflection()->MutableMessage(entry_message, value);
+  EXPECT_EQ(UNITTEST::TestAllTypes::descriptor(),
+            proto2_message->GetDescriptor());
+  ASSERT_EQ(1, message.map_int32_message().size());
+}
+
+TEST(GeneratedMapFieldReflectionTest, MergeFromClearMapEntry) {
+  UNITTEST::TestMap message;
+  const FieldDescriptor* map_field =
+      UNITTEST::TestMap::descriptor()->FindFieldByName("map_int32_int32");
+  const FieldDescriptor* key = map_field->message_type()->map_key();
+  const FieldDescriptor* value = map_field->message_type()->map_value();
+
+  Message* entry_message1 =
+      message.GetReflection()->AddMessage(&message, map_field);
+  EXPECT_FALSE(entry_message1->GetReflection()->HasField(*entry_message1, key));
+  EXPECT_FALSE(
+      entry_message1->GetReflection()->HasField(*entry_message1, value));
+
+  Message* entry_message2 =
+      message.GetReflection()->AddMessage(&message, map_field);
+  EXPECT_FALSE(entry_message2->GetReflection()->HasField(*entry_message2, key));
+  EXPECT_FALSE(
+      entry_message2->GetReflection()->HasField(*entry_message2, value));
+
+  entry_message1->MergeFrom(*entry_message2);
+  EXPECT_FALSE(entry_message1->GetReflection()->HasField(*entry_message1, key));
+  EXPECT_FALSE(
+      entry_message1->GetReflection()->HasField(*entry_message1, value));
+}
+
+TEST(GeneratedMapFieldReflectionTest, MapEntryClear) {
+  UNITTEST::TestMap message;
+  MapReflectionTester reflection_tester(UNITTEST::TestMap::descriptor());
+  reflection_tester.MutableUnknownFieldsOfMapFieldsViaReflection(&message);
+}
+
+TEST(GeneratedMapFieldReflectionTest, Proto2MapEntryClear) {
+  UNITTEST::TestEnumMap message;
+  const Descriptor* descriptor = message.GetDescriptor();
+  const FieldDescriptor* field_descriptor =
+      descriptor->FindFieldByName("known_map_field");
+  const FieldDescriptor* value_descriptor =
+      field_descriptor->message_type()->map_value();
+  Message* sub_message =
+      message.GetReflection()->AddMessage(&message, field_descriptor);
+  EXPECT_EQ(0, sub_message->GetReflection()->GetEnumValue(*sub_message,
+                                                          value_descriptor));
+}
+
+// Map Reflection API Test =========================================
+
+TEST(GeneratedMapFieldReflectionTest, SetViaMapReflection) {
+  UNITTEST::TestMap message;
+  MapReflectionTester reflection_tester(UNITTEST::TestMap::descriptor());
+  reflection_tester.SetMapFieldsViaMapReflection(&message);
+  reflection_tester.ExpectMapFieldsSetViaReflection(message);
+  reflection_tester.ExpectMapFieldsSetViaReflectionIterator(&message);
+}
+
+// Dynamic Message Test =============================================
+
+class MapFieldInDynamicMessageTest : public testing::Test {
+ protected:
+  const DescriptorPool* pool_;
+  DynamicMessageFactory factory_;
+  const Descriptor* map_descriptor_;
+  const Descriptor* recursive_map_descriptor_;
+  const Message* map_prototype_;
+
+  MapFieldInDynamicMessageTest()
+      : pool_(DescriptorPool::generated_pool()), factory_(pool_) {}
+
+  void SetUp() override {
+    map_descriptor_ = pool_->FindMessageTypeByName(
+        std::string(UNITTEST_PACKAGE_NAME) + ".TestMap");
+    recursive_map_descriptor_ = pool_->FindMessageTypeByName(
+        std::string(UNITTEST_PACKAGE_NAME) + ".TestRecursiveMapMessage");
+    ASSERT_TRUE(map_descriptor_ != nullptr);
+    ASSERT_TRUE(recursive_map_descriptor_ != nullptr);
+    map_prototype_ = factory_.GetPrototype(map_descriptor_);
+  }
+};
+
+TEST_F(MapFieldInDynamicMessageTest, MapIndependentOffsets) {
+  // Check that all fields have independent offsets by setting each
+  // one to a unique value then checking that they all still have those
+  // unique values (i.e. they don't stomp each other).
+  std::unique_ptr<Message> message(map_prototype_->New());
+  MapReflectionTester reflection_tester(map_descriptor_);
+
+  reflection_tester.SetMapFieldsViaReflection(message.get());
+  reflection_tester.ExpectMapFieldsSetViaReflection(*message);
+}
+
+TEST_F(MapFieldInDynamicMessageTest, DynamicMapReflection) {
+  // Check that map fields work properly.
+  std::unique_ptr<Message> message(map_prototype_->New());
+
+  // Check set functions.
+  MapReflectionTester reflection_tester(map_descriptor_);
+  reflection_tester.SetMapFieldsViaMapReflection(message.get());
+  reflection_tester.ExpectMapFieldsSetViaReflection(*message);
+}
+
+TEST_F(MapFieldInDynamicMessageTest, MapSpaceUsed) {
+  // Test that SpaceUsedLong() works properly
+
+  // Since we share the implementation with generated messages, we don't need
+  // to test very much here.  Just make sure it appears to be working.
+
+  std::unique_ptr<Message> message(map_prototype_->New());
+  MapReflectionTester reflection_tester(map_descriptor_);
+
+  int initial_space_used = message->SpaceUsedLong();
+
+  reflection_tester.SetMapFieldsViaReflection(message.get());
+  EXPECT_LT(initial_space_used, message->SpaceUsedLong());
+}
+
+TEST_F(MapFieldInDynamicMessageTest, RecursiveMap) {
+  TestRecursiveMapMessage from;
+  (*from.mutable_a())[""];
+  std::string data = from.SerializeAsString();
+  std::unique_ptr<Message> to(
+      factory_.GetPrototype(recursive_map_descriptor_)->New());
+  ASSERT_TRUE(to->ParseFromString(data));
+}
+
+TEST_F(MapFieldInDynamicMessageTest, MapValueReferernceValidAfterSerialize) {
+  std::unique_ptr<Message> message(map_prototype_->New());
+  MapReflectionTester reflection_tester(map_descriptor_);
+  reflection_tester.SetMapFieldsViaMapReflection(message.get());
+
+  // Get value reference before serialization, so that we know the value is from
+  // map.
+  MapKey map_key;
+  MapValueRef map_val;
+  map_key.SetInt32Value(0);
+  reflection_tester.GetMapValueViaMapReflection(
+      message.get(), "map_int32_foreign_message", map_key, &map_val);
+  Message* submsg = map_val.MutableMessageValue();
+
+  // In previous implementation, calling SerializeToString will cause syncing
+  // from map to repeated field, which will invalidate the submsg we previously
+  // got.
+  std::string data;
+  message->SerializeToString(&data);
+
+  const Reflection* submsg_reflection = submsg->GetReflection();
+  const Descriptor* submsg_desc = submsg->GetDescriptor();
+  const FieldDescriptor* submsg_field = submsg_desc->FindFieldByName("c");
+  submsg_reflection->SetInt32(submsg, submsg_field, 128);
+
+  message->SerializeToString(&data);
+  TestMap to;
+  to.ParseFromString(data);
+  EXPECT_EQ(128, to.map_int32_foreign_message().at(0).c());
+}
+
+TEST_F(MapFieldInDynamicMessageTest, MapEntryReferernceValidAfterSerialize) {
+  std::unique_ptr<Message> message(map_prototype_->New());
+  MapReflectionTester reflection_tester(map_descriptor_);
+  reflection_tester.SetMapFieldsViaReflection(message.get());
+
+  // Get map entry before serialization, so that we know the it is from
+  // repeated field.
+  Message* map_entry = reflection_tester.GetMapEntryViaReflection(
+      message.get(), "map_int32_foreign_message", 0);
+  const Reflection* map_entry_reflection = map_entry->GetReflection();
+  const Descriptor* map_entry_desc = map_entry->GetDescriptor();
+  const FieldDescriptor* value_field = map_entry_desc->map_value();
+  Message* submsg =
+      map_entry_reflection->MutableMessage(map_entry, value_field);
+
+  // In previous implementation, calling SerializeToString will cause syncing
+  // from repeated field to map, which will invalidate the map_entry we
+  // previously got.
+  std::string data;
+  message->SerializeToString(&data);
+
+  const Reflection* submsg_reflection = submsg->GetReflection();
+  const Descriptor* submsg_desc = submsg->GetDescriptor();
+  const FieldDescriptor* submsg_field = submsg_desc->FindFieldByName("c");
+  submsg_reflection->SetInt32(submsg, submsg_field, 128);
+
+  message->SerializeToString(&data);
+  TestMap to;
+  to.ParseFromString(data);
+  EXPECT_EQ(128, to.map_int32_foreign_message().at(0).c());
+}
+
+// ReflectionOps Test ===============================================
+
+TEST(ReflectionOpsForMapFieldTest, MapSanityCheck) {
+  UNITTEST::TestMap message;
+
+  MapTestUtil::SetMapFields(&message);
+  MapTestUtil::ExpectMapFieldsSet(message);
+}
+
+TEST(ReflectionOpsForMapFieldTest, MapCopy) {
+  UNITTEST::TestMap message, message2;
+
+  MapTestUtil::SetMapFields(&message);
+
+  ReflectionOps::Copy(message, &message2);
+
+  MapTestUtil::ExpectMapFieldsSet(message2);
+
+  // Copying from self should be a no-op.
+  ReflectionOps::Copy(message2, &message2);
+  MapTestUtil::ExpectMapFieldsSet(message2);
+}
+
+TEST(ReflectionOpsForMapFieldTest, MergeMap) {
+  // Note:  Copy is implemented in terms of Merge() so technically the Copy
+  //   test already tested most of this.
+
+  UNITTEST::TestMap message, message2;
+
+  MapTestUtil::SetMapFields(&message);
+
+  ReflectionOps::Merge(message2, &message);
+
+  MapTestUtil::ExpectMapFieldsSet(message);
+}
+
+TEST(ReflectionOpsForMapFieldTest, ClearMap) {
+  UNITTEST::TestMap message;
+
+  MapTestUtil::SetMapFields(&message);
+
+  ReflectionOps::Clear(&message);
+
+  MapTestUtil::ExpectClear(message);
+}
+
+TEST(ReflectionOpsForMapFieldTest, MapDiscardUnknownFields) {
+  UNITTEST::TestMap message;
+  MapTestUtil::SetMapFields(&message);
+
+  // Set some unknown fields in message.
+  message.GetReflection()->MutableUnknownFields(&message)->AddVarint(123456,
+                                                                     654321);
+
+  // Discard them.
+  ReflectionOps::DiscardUnknownFields(&message);
+  MapTestUtil::ExpectMapFieldsSet(message);
+
+  EXPECT_EQ(0,
+            message.GetReflection()->GetUnknownFields(message).field_count());
+}
+
+TEST(ReflectionOpsForMapFieldTest, IsInitialized) {
+  UNITTEST::TestRequiredMessageMap map_message;
+
+  // Add an uninitialized message.
+  (*map_message.mutable_map_field())[0];
+  EXPECT_FALSE(ReflectionOps::IsInitialized(map_message));
+
+  // Initialize uninitialized message
+  (*map_message.mutable_map_field())[0].set_a(0);
+  (*map_message.mutable_map_field())[0].set_b(0);
+  (*map_message.mutable_map_field())[0].set_c(0);
+  EXPECT_TRUE(ReflectionOps::IsInitialized(map_message));
+}
+
+// Wire Format Test =================================================
+
+TEST(WireFormatForMapFieldTest, ParseMap) {
+  UNITTEST::TestMap source, dest;
+  std::string data;
+
+  // Serialize using the generated code.
+  MapTestUtil::SetMapFields(&source);
+  source.SerializeToString(&data);
+
+  // Parse using WireFormat.
+  io::ArrayInputStream raw_input(data.data(), data.size());
+  io::CodedInputStream input(&raw_input);
+  WireFormat::ParseAndMergePartial(&input, &dest);
+
+  // Check.
+  MapTestUtil::ExpectMapFieldsSet(dest);
+}
+
+TEST(WireFormatForMapFieldTest, MapByteSize) {
+  UNITTEST::TestMap message;
+  MapTestUtil::SetMapFields(&message);
+
+  EXPECT_EQ(message.ByteSizeLong(), WireFormat::ByteSize(message));
+  message.Clear();
+  EXPECT_EQ(0, message.ByteSizeLong());
+  EXPECT_EQ(0, WireFormat::ByteSize(message));
+}
+
+TEST(WireFormatForMapFieldTest, SerializeMap) {
+  UNITTEST::TestMap message;
+  std::string generated_data;
+  std::string dynamic_data;
+
+  MapTestUtil::SetMapFields(&message);
+
+  // Serialize using the generated code.
+  {
+    message.ByteSizeLong();
+    io::StringOutputStream raw_output(&generated_data);
+    io::CodedOutputStream output(&raw_output);
+    message.SerializeWithCachedSizes(&output);
+    ASSERT_FALSE(output.HadError());
+  }
+
+  // Serialize using WireFormat.
+  {
+    io::StringOutputStream raw_output(&dynamic_data);
+    io::CodedOutputStream output(&raw_output);
+    size_t size = WireFormat::ByteSize(message);
+    WireFormat::SerializeWithCachedSizes(message, size, &output);
+    ASSERT_FALSE(output.HadError());
+  }
+
+  // Should parse to the same message.
+  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, generated_data));
+  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, dynamic_data));
+}
+
+TEST(WireFormatForMapFieldTest, SerializeMapDynamicMessage) {
+  DynamicMessageFactory factory;
+  std::unique_ptr<Message> dynamic_message;
+  dynamic_message.reset(
+      factory.GetPrototype(UNITTEST::TestMap::descriptor())->New());
+  MapReflectionTester reflection_tester(UNITTEST::TestMap::descriptor());
+  reflection_tester.SetMapFieldsViaReflection(dynamic_message.get());
+  reflection_tester.ExpectMapFieldsSetViaReflection(*dynamic_message);
+
+  UNITTEST::TestMap generated_message;
+  MapTestUtil::SetMapFields(&generated_message);
+  MapTestUtil::ExpectMapFieldsSet(generated_message);
+
+  std::string generated_data;
+  std::string dynamic_data;
+
+  // Serialize.
+  generated_message.SerializeToString(&generated_data);
+  dynamic_message->SerializeToString(&dynamic_data);
+
+  // Because map serialization doesn't guarantee order, we just compare
+  // serialized size here. This is enough to tell dynamic message doesn't miss
+  // anything in serialization.
+  EXPECT_TRUE(dynamic_data.size() == generated_data.size());
+}
+
+TEST(WireFormatForMapFieldTest, MapByteSizeDynamicMessage) {
+  DynamicMessageFactory factory;
+  std::unique_ptr<Message> dynamic_message;
+  dynamic_message.reset(
+      factory.GetPrototype(UNITTEST::TestMap::descriptor())->New());
+  MapReflectionTester reflection_tester(UNITTEST::TestMap::descriptor());
+  reflection_tester.SetMapFieldsViaReflection(dynamic_message.get());
+  reflection_tester.ExpectMapFieldsSetViaReflection(*dynamic_message);
+  std::string expected_serialized_data;
+  dynamic_message->SerializeToString(&expected_serialized_data);
+  int expected_size = expected_serialized_data.size();
+  EXPECT_EQ(dynamic_message->ByteSizeLong(), expected_size);
+  TestMap expected_message;
+  expected_message.ParseFromString(expected_serialized_data);
+
+  std::unique_ptr<Message> message2;
+  message2.reset(factory.GetPrototype(UNITTEST::TestMap::descriptor())->New());
+  reflection_tester.SetMapFieldsViaMapReflection(message2.get());
+
+  const FieldDescriptor* field =
+      UNITTEST::TestMap::descriptor()->FindFieldByName("map_int32_int32");
+  const Reflection* reflection = dynamic_message->GetReflection();
+
+  // Force the map field to mark with STATE_MODIFIED_REPEATED
+  reflection->RemoveLast(dynamic_message.get(), field);
+  dynamic_message->MergeFrom(*message2);
+  dynamic_message->MergeFrom(*message2);
+  // The map field is marked as STATE_MODIFIED_REPEATED, ByteSizeLong() will use
+  // repeated field which have duplicate keys to calculate.
+  size_t duplicate_size = dynamic_message->ByteSizeLong();
+  EXPECT_TRUE(duplicate_size > expected_size);
+  std::string duplicate_serialized_data;
+  dynamic_message->SerializeToString(&duplicate_serialized_data);
+  EXPECT_EQ(dynamic_message->ByteSizeLong(), duplicate_serialized_data.size());
+
+  // Force the map field to mark with map CLEAN
+  EXPECT_EQ(reflection_tester.MapSize(
+      *dynamic_message, "map_int32_int32"), 2);
+  EXPECT_EQ(reflection_tester.MapSize(
+      *dynamic_message, "map_int32_int32"), 2);
+  EXPECT_EQ(reflection_tester.MapSize(
+      *dynamic_message, "map_int64_int64"), 2);
+  EXPECT_EQ(reflection_tester.MapSize(
+      *dynamic_message, "map_uint32_uint32"), 2);
+  EXPECT_EQ(reflection_tester.MapSize(
+      *dynamic_message, "map_uint64_uint64"), 2);
+  EXPECT_EQ(reflection_tester.MapSize(
+      *dynamic_message, "map_sint32_sint32"), 2);
+  EXPECT_EQ(reflection_tester.MapSize(
+      *dynamic_message, "map_sint64_sint64"), 2);
+  EXPECT_EQ(reflection_tester.MapSize(
+      *dynamic_message, "map_fixed32_fixed32"), 2);
+  EXPECT_EQ(reflection_tester.MapSize(
+      *dynamic_message, "map_fixed64_fixed64"), 2);
+  EXPECT_EQ(reflection_tester.MapSize(
+      *dynamic_message, "map_sfixed32_sfixed32"), 2);
+  EXPECT_EQ(reflection_tester.MapSize(
+      *dynamic_message, "map_sfixed64_sfixed64"), 2);
+  EXPECT_EQ(reflection_tester.MapSize(
+      *dynamic_message, "map_int32_float"), 2);
+  EXPECT_EQ(reflection_tester.MapSize(
+      *dynamic_message, "map_int32_double"), 2);
+  EXPECT_EQ(reflection_tester.MapSize(
+      *dynamic_message, "map_bool_bool"), 2);
+  EXPECT_EQ(reflection_tester.MapSize(
+      *dynamic_message, "map_string_string"), 2);
+  EXPECT_EQ(reflection_tester.MapSize(
+      *dynamic_message, "map_int32_bytes"), 2);
+  EXPECT_EQ(reflection_tester.MapSize(
+      *dynamic_message, "map_int32_enum"), 2);
+  EXPECT_EQ(reflection_tester.MapSize(*dynamic_message, "map_int32_foreign_message"), 2);
+  // The map field is marked as CLEAN, ByteSizeLong() will use map which do not
+  // have duplicate keys to calculate.
+  int size = dynamic_message->ByteSizeLong();
+  EXPECT_EQ(expected_size, size);
+
+  // Protobuf used to have a bug for serialize when map it marked CLEAN. It used
+  // repeated field to calculate ByteSizeLong but use map to serialize the real
+  // data, thus the ByteSizeLong may bigger than real serialized size. A crash
+  // might be happen at SerializeToString(). Or an "unexpected end group"
+  // warning was raised at parse back if user use SerializeWithCachedSizes()
+  // which avoids size check at serialize.
+  std::string serialized_data;
+  dynamic_message->SerializeToString(&serialized_data);
+  EXPECT_TRUE(dynamic_message->ParseFromString(serialized_data));
+}
+
+TEST(WireFormatForMapFieldTest, MapParseHelpers) {
+  std::string data;
+
+  {
+    // Set up.
+    UNITTEST::TestMap message;
+    MapTestUtil::SetMapFields(&message);
+    message.SerializeToString(&data);
+  }
+
+  {
+    // Test ParseFromString.
+    UNITTEST::TestMap message;
+    EXPECT_TRUE(message.ParseFromString(data));
+    MapTestUtil::ExpectMapFieldsSet(message);
+  }
+
+  {
+    // Test ParseFromIstream.
+    UNITTEST::TestMap message;
+    std::stringstream stream(data);
+    EXPECT_TRUE(message.ParseFromIstream(&stream));
+    EXPECT_TRUE(stream.eof());
+    MapTestUtil::ExpectMapFieldsSet(message);
+  }
+
+  {
+    // Test ParseFromBoundedZeroCopyStream.
+    std::string data_with_junk(data);
+    data_with_junk.append("some junk on the end");
+    io::ArrayInputStream stream(data_with_junk.data(), data_with_junk.size());
+    UNITTEST::TestMap message;
+    EXPECT_TRUE(message.ParseFromBoundedZeroCopyStream(&stream, data.size()));
+    MapTestUtil::ExpectMapFieldsSet(message);
+  }
+
+  {
+    // Test that ParseFromBoundedZeroCopyStream fails (but doesn't crash) if
+    // EOF is reached before the expected number of bytes.
+    io::ArrayInputStream stream(data.data(), data.size());
+    UNITTEST::TestAllTypes message;
+    EXPECT_FALSE(
+        message.ParseFromBoundedZeroCopyStream(&stream, data.size() + 1));
+  }
+}
+
+// Deterministic Serialization Test ==========================================
+
+template <typename T>
+static std::string DeterministicSerializationWithSerializePartialToCodedStream(
+    const T& t) {
+  const size_t size = t.ByteSizeLong();
+  std::string result(size, '\0');
+  io::ArrayOutputStream array_stream(::google::protobuf::string_as_array(&result), size);
+  io::CodedOutputStream output_stream(&array_stream);
+  output_stream.SetSerializationDeterministic(true);
+  t.SerializePartialToCodedStream(&output_stream);
+  EXPECT_FALSE(output_stream.HadError());
+  EXPECT_EQ(size, output_stream.ByteCount());
+  return result;
+}
+
+template <typename T>
+static std::string DeterministicSerializationWithSerializeToCodedStream(
+    const T& t) {
+  const size_t size = t.ByteSizeLong();
+  std::string result(size, '\0');
+  io::ArrayOutputStream array_stream(::google::protobuf::string_as_array(&result), size);
+  io::CodedOutputStream output_stream(&array_stream);
+  output_stream.SetSerializationDeterministic(true);
+  t.SerializeToCodedStream(&output_stream);
+  EXPECT_FALSE(output_stream.HadError());
+  EXPECT_EQ(size, output_stream.ByteCount());
+  return result;
+}
+
+template <typename T>
+static std::string DeterministicSerialization(const T& t) {
+  const size_t size = t.ByteSizeLong();
+  std::string result(size, '\0');
+  io::ArrayOutputStream array_stream(::google::protobuf::string_as_array(&result), size);
+  {
+    io::CodedOutputStream output_stream(&array_stream);
+    output_stream.SetSerializationDeterministic(true);
+    t.SerializeWithCachedSizes(&output_stream);
+    EXPECT_FALSE(output_stream.HadError());
+    EXPECT_EQ(size, output_stream.ByteCount());
+  }
+  EXPECT_EQ(result, DeterministicSerializationWithSerializeToCodedStream(t));
+  EXPECT_EQ(result,
+            DeterministicSerializationWithSerializePartialToCodedStream(t));
+  return result;
+}
+
+// Helper for MapSerializationTest.  Return a 7-bit ASCII string.
+static std::string ConstructKey(uint64_t n) {
+  std::string s(n % static_cast<uint64_t>(9), '\0');
+  if (s.empty()) {
+    return StrCat(n);
+  } else {
+    while (n != 0) {
+      s[n % s.size()] = (n >> 10) & 0x7f;
+      n /= 888;
+    }
+    return s;
+  }
+}
+
+TEST(MapSerializationTest, Deterministic) {
+  const int kIters = 25;
+  UNITTEST::TestMaps t;
+  UNITTEST::TestIntIntMap inner;
+  (*inner.mutable_m())[0] = (*inner.mutable_m())[10] =
+      (*inner.mutable_m())[-200] = 0;
+  uint64_t frog = 9;
+  const uint64_t multiplier = 0xa29cd16f;
+  for (int i = 0; i < kIters; i++) {
+    const int32_t i32 = static_cast<int32_t>(frog & 0xffffffff);
+    const uint32_t u32 = static_cast<uint32_t>(i32) * 91919;
+    const int64_t i64 = static_cast<int64_t>(frog);
+    const uint64_t u64 = frog * static_cast<uint64_t>(187321);
+    const bool b = i32 > 0;
+    const std::string s = ConstructKey(frog);
+    (*inner.mutable_m())[i] = i32;
+    (*t.mutable_m_int32())[i32] = (*t.mutable_m_sint32())[i32] =
+        (*t.mutable_m_sfixed32())[i32] = inner;
+    (*t.mutable_m_uint32())[u32] = (*t.mutable_m_fixed32())[u32] = inner;
+    (*t.mutable_m_int64())[i64] = (*t.mutable_m_sint64())[i64] =
+        (*t.mutable_m_sfixed64())[i64] = inner;
+    (*t.mutable_m_uint64())[u64] = (*t.mutable_m_fixed64())[u64] = inner;
+    (*t.mutable_m_bool())[b] = inner;
+    (*t.mutable_m_string())[s] = inner;
+    (*t.mutable_m_string())[s + std::string(
+                                    1 << (u32 % static_cast<uint32_t>(9)), b)] =
+        inner;
+    inner.mutable_m()->erase(i);
+    frog = frog * multiplier + i;
+    frog ^= (frog >> 41);
+  }
+
+  // Verifies if two consecutive calls to deterministic serialization produce
+  // the same bytes. Deterministic serialization means the same serialization
+  // bytes in the same binary.
+  const std::string s1 = DeterministicSerialization(t);
+  const std::string s2 = DeterministicSerialization(t);
+  EXPECT_EQ(s1, s2);
+
+  UNITTEST::TestMaps u;
+  EXPECT_TRUE(u.ParseFromString(s1));
+  EXPECT_TRUE(util::MessageDifferencer::Equals(u, t));
+}
+
+TEST(MapSerializationTest, DeterministicSubmessage) {
+  UNITTEST::TestSubmessageMaps p;
+  UNITTEST::TestMaps t;
+  const std::string filename = "golden_message_maps";
+  std::string golden;
+  GOOGLE_CHECK_OK(File::GetContents(
+      TestUtil::GetTestDataPath("net/proto2/internal/testdata/" + filename),
+      &golden, true));
+  t.ParseFromString(golden);
+  *(p.mutable_m()) = t;
+  std::vector<std::string> v;
+  // Use multiple attempts to increase the chance of a failure if something is
+  // buggy.  For example, each separate copy of a map might use a different
+  // randomly-chosen hash function.
+  const int kAttempts = 10;
+  for (int i = 0; i < kAttempts; i++) {
+    // NOLINTNEXTLINE(performance-unnecessary-copy-initialization)
+    UNITTEST::TestSubmessageMaps q(p);
+    ASSERT_EQ(DeterministicSerialization(q), DeterministicSerialization(p));
+  }
+}
+
+// Text Format Test =================================================
+
+TEST(TextFormatMapTest, SerializeAndParse) {
+  UNITTEST::TestMap source;
+  UNITTEST::TestMap dest;
+  MapTestUtil::SetMapFields(&source);
+  std::string output;
+
+  // Test compact ASCII
+  TextFormat::Printer printer;
+  printer.PrintToString(source, &output);
+  TextFormat::Parser parser;
+  EXPECT_TRUE(parser.ParseFromString(output, &dest));
+  MapTestUtil::ExpectMapFieldsSet(dest);
+}
+
+TEST(TextFormatMapTest, DynamicMessage) {
+  TestMap prototype;
+  DynamicMessageFactory factory;
+  std::unique_ptr<Message> message(
+      factory.GetPrototype(prototype.GetDescriptor())->New());
+  MapReflectionTester tester(message->GetDescriptor());
+  tester.SetMapFieldsViaReflection(message.get());
+
+  std::string expected_text;
+  GOOGLE_CHECK_OK(
+      File::GetContents(TestUtil::GetTestDataPath("net/proto2/internal/"
+                                                  "testdata/map_test_data.txt"),
+                        &expected_text, true));
+
+  CleanStringLineEndings(&expected_text, false);
+  EXPECT_EQ(message->DebugString(), expected_text);
+}
+
+TEST(TextFormatMapTest, Sorted) {
+  UNITTEST::TestMap message;
+  MapReflectionTester tester(message.GetDescriptor());
+  tester.SetMapFieldsViaReflection(&message);
+
+  std::string expected_text;
+  GOOGLE_CHECK_OK(
+      File::GetContents(TestUtil::GetTestDataPath("net/proto2/internal/"
+                                                  "testdata/map_test_data.txt"),
+                        &expected_text, true));
+
+  CleanStringLineEndings(&expected_text, false);
+  EXPECT_EQ(message.DebugString(), expected_text);
+
+  // Test again on the reverse order.
+  UNITTEST::TestMap message2;
+  tester.SetMapFieldsViaReflection(&message2);
+  tester.SwapMapsViaReflection(&message2);
+  EXPECT_EQ(message2.DebugString(), expected_text);
+}
+
+TEST(TextFormatMapTest, ParseCorruptedString) {
+  std::string serialized_message;
+  GOOGLE_CHECK_OK(
+      File::GetContents(TestUtil::GetTestDataPath(
+                            "net/proto2/internal/testdata/golden_message_maps"),
+                        &serialized_message, true));
+  UNITTEST::TestMaps message;
+  GOOGLE_CHECK(message.ParseFromString(serialized_message));
+  TestParseCorruptedString<UNITTEST::TestMaps, true>(message);
+  TestParseCorruptedString<UNITTEST::TestMaps, false>(message);
+}
+
+// Previously, serializing to text format will disable iterator from generated
+// API. Now, the iterator can be still used even after serializing to text
+// format.
+TEST(TextFormatMapTest, NoDisableIterator) {
+  UNITTEST::TestMap source;
+  (*source.mutable_map_int32_int32())[1] = 1;
+
+  // Get iterator.
+  Map<int32_t, int32_t>::iterator iter =
+      source.mutable_map_int32_int32()->find(1);
+
+  // Serialize message to text format, which will invalidate the previous
+  // iterator previously.
+  std::string output;
+  TextFormat::Printer printer;
+  printer.PrintToString(source, &output);
+
+  // Modify map via the iterator (invalidated in previous implementation.).
+  iter->second = 2;
+
+  // In previous implementation, the new change won't be reflected in text
+  // format, because the previous iterator has been invalidated.
+  output.clear();
+  printer.PrintToString(source, &output);
+  std::string expected =
+      "map_int32_int32 {\n"
+      "  key: 1\n"
+      "  value: 2\n"
+      "}\n";
+  EXPECT_EQ(output, expected);
+}
+
+// Previously, serializing to text format will disable iterator from reflection
+// API.
+TEST(TextFormatMapTest, NoDisableReflectionIterator) {
+  UNITTEST::TestMap source;
+  (*source.mutable_map_int32_int32())[1] = 1;
+
+  // Get iterator. This will also sync internal repeated field with map inside
+  // of MapField.
+  const Reflection* reflection = source.GetReflection();
+  const FieldDescriptor* field_desc =
+      source.GetDescriptor()->FindFieldByName("map_int32_int32");
+  RepeatedPtrField<Message>* map_field =
+      reflection->MutableRepeatedPtrField<Message>(&source, field_desc);
+  RepeatedPtrField<Message>::iterator iter = map_field->begin();
+
+  // Serialize message to text format, which will invalidate the previous
+  // iterator previously.
+  std::string output;
+  TextFormat::Printer printer;
+  printer.PrintToString(source, &output);
+
+  // Modify map via the iterator (invalidated in previous implementation.).
+  const Reflection* map_entry_reflection = iter->GetReflection();
+  const FieldDescriptor* value_field_desc = iter->GetDescriptor()->map_value();
+  map_entry_reflection->SetInt32(&(*iter), value_field_desc, 2);
+  GOOGLE_LOG(INFO) << iter->DebugString();
+
+  // In previous implementation, the new change won't be reflected in text
+  // format, because the previous iterator has been invalidated.
+  output.clear();
+  printer.PrintToString(source, &output);
+  std::string expected =
+      "map_int32_int32 {\n"
+      "  key: 1\n"
+      "  value: 2\n"
+      "}\n";
+  EXPECT_EQ(output, expected);
+}
+
+// arena support =================================================
+TEST(ArenaTest, ParsingAndSerializingNoHeapAllocation) {
+  // Allocate a large initial block to avoid mallocs during hooked test.
+  std::vector<char> arena_block(128 * 1024);
+  ArenaOptions options;
+  options.initial_block = &arena_block[0];
+  options.initial_block_size = arena_block.size();
+  Arena arena(options);
+  std::string data;
+  data.reserve(128 * 1024);
+
+  {
+    // TODO(teboring): Enable no heap check when ArenaStringPtr is used in map.
+    // NoHeapChecker no_heap;
+
+    UNITTEST::TestArenaMap* from =
+        Arena::CreateMessage<UNITTEST::TestArenaMap>(&arena);
+    MapTestUtil::SetArenaMapFields(from);
+    from->SerializeToString(&data);
+
+    UNITTEST::TestArenaMap* to =
+        Arena::CreateMessage<UNITTEST::TestArenaMap>(&arena);
+    to->ParseFromString(data);
+    MapTestUtil::ExpectArenaMapFieldsSet(*to);
+  }
+}
+
+TEST(ArenaTest, SubmessageOnSameArena) {
+  Arena arena;
+  for (Arena* arena_to_use : {&arena, static_cast<Arena*>(nullptr)}) {
+    ArenaHolder<UNITTEST::TestArenaMap> m(arena_to_use);
+    auto* subm = &(*m->mutable_map_int32_foreign_message())[0];
+    EXPECT_EQ(subm->GetArena(), arena_to_use);
+  }
+}
+
+// Use text format parsing and serializing to test reflection api.
+TEST(ArenaTest, ReflectionInTextFormat) {
+  Arena arena;
+  std::string data;
+
+  TextFormat::Printer printer;
+  TextFormat::Parser parser;
+
+  UNITTEST::TestArenaMap* from =
+      Arena::CreateMessage<UNITTEST::TestArenaMap>(&arena);
+  UNITTEST::TestArenaMap* to =
+      Arena::CreateMessage<UNITTEST::TestArenaMap>(&arena);
+
+  MapTestUtil::SetArenaMapFields(from);
+  printer.PrintToString(*from, &data);
+
+  EXPECT_TRUE(parser.ParseFromString(data, to));
+  MapTestUtil::ExpectArenaMapFieldsSet(*to);
+}
+
+// Make sure the memory allocated for string in map is deallocated.
+TEST(ArenaTest, StringMapNoLeak) {
+  Arena arena;
+  UNITTEST::TestArenaMap* message =
+      Arena::CreateMessage<UNITTEST::TestArenaMap>(&arena);
+  std::string data;
+  // String with length less than 16 will not be allocated from heap.
+  int original_capacity = data.capacity();
+  while (data.capacity() <= original_capacity) {
+    data.append("a");
+  }
+  (*message->mutable_map_string_string())[data] = data;
+  // We rely on heap checkers to detect memory leak for us.
+  ASSERT_FALSE(message == nullptr);
+}
+
+TEST(ArenaTest, IsInitialized) {
+  // Allocate a large initial polluted block.
+  std::vector<char> arena_block(128 * 1024);
+  std::fill(arena_block.begin(), arena_block.end(), '\xff');
+
+  ArenaOptions options;
+  options.initial_block = &arena_block[0];
+  options.initial_block_size = arena_block.size();
+  Arena arena(options);
+
+  UNITTEST::TestArenaMap* message =
+      Arena::CreateMessage<UNITTEST::TestArenaMap>(&arena);
+  EXPECT_EQ(0, (*message->mutable_map_int32_int32())[0]);
+}
+
+TEST(ArenaTest, DynamicMapFieldOnArena) {
+  Arena arena;
+  UNITTEST::TestMap message2;
+
+  DynamicMessageFactory factory;
+  Message* message1 =
+      factory.GetPrototype(UNITTEST::TestMap::descriptor())->New(&arena);
+  MapReflectionTester reflection_tester(UNITTEST::TestMap::descriptor());
+  reflection_tester.SetMapFieldsViaReflection(message1);
+  reflection_tester.ExpectMapFieldsSetViaReflection(*message1);
+  reflection_tester.ExpectMapFieldsSetViaReflectionIterator(message1);
+  message2.CopyFrom(*message1);
+  MapTestUtil::ExpectMapFieldsSet(message2);
+}
+
+TEST(ArenaTest, DynamicMapFieldOnArenaMemoryLeak) {
+  auto* desc = UNITTEST::TestMap::descriptor();
+  auto* field = desc->FindFieldByName("map_int32_int32");
+
+  Arena arena;
+  DynamicMessageFactory factory;
+  auto* message = factory.GetPrototype(desc)->New(&arena);
+  auto* reflection = message->GetReflection();
+  reflection->AddMessage(message, field);
+
+  // Force internal syncing, which initializes the mutex.
+  MapReflectionTester reflection_tester(UNITTEST::TestMap::descriptor());
+  int size = reflection_tester.MapSize(*message, "map_int32_int32");
+  EXPECT_EQ(size, 1);
+}
+
+TEST(MoveTest, MoveConstructorWorks) {
+  Map<int32_t, TestAllTypes> original_map;
+  original_map[42].mutable_optional_nested_message()->set_bb(42);
+  original_map[43].mutable_optional_nested_message()->set_bb(43);
+  const auto* nested_msg42_ptr = &original_map[42].optional_nested_message();
+  const auto* nested_msg43_ptr = &original_map[43].optional_nested_message();
+
+  Map<int32_t, TestAllTypes> moved_to_map(std::move(original_map));
+  EXPECT_TRUE(original_map.empty());
+  EXPECT_EQ(2, moved_to_map.size());
+  EXPECT_EQ(42, moved_to_map[42].optional_nested_message().bb());
+  EXPECT_EQ(43, moved_to_map[43].optional_nested_message().bb());
+  // This test takes advantage of the fact that pointers are swapped, so there
+  // should be pointer stability.
+  EXPECT_EQ(nested_msg42_ptr, &moved_to_map[42].optional_nested_message());
+  EXPECT_EQ(nested_msg43_ptr, &moved_to_map[43].optional_nested_message());
+}
+
+TEST(MoveTest, MoveAssignmentWorks) {
+  Map<int32_t, TestAllTypes> original_map;
+  original_map[42].mutable_optional_nested_message()->set_bb(42);
+  original_map[43].mutable_optional_nested_message()->set_bb(43);
+  const auto* nested_msg42_ptr = &original_map[42].optional_nested_message();
+  const auto* nested_msg43_ptr = &original_map[43].optional_nested_message();
+
+  Map<int32_t, TestAllTypes> moved_to_map = std::move(original_map);
+  EXPECT_TRUE(original_map.empty());
+  EXPECT_EQ(2, moved_to_map.size());
+  EXPECT_EQ(42, moved_to_map[42].optional_nested_message().bb());
+  EXPECT_EQ(43, moved_to_map[43].optional_nested_message().bb());
+  // This test takes advantage of the fact that pointers are swapped, so there
+  // should be pointer stability.
+  EXPECT_EQ(nested_msg42_ptr, &moved_to_map[42].optional_nested_message());
+  EXPECT_EQ(nested_msg43_ptr, &moved_to_map[43].optional_nested_message());
+}
+
+}  // namespace
+}  // namespace internal
+}  // namespace protobuf
+}  // namespace google
+
+#include <google/protobuf/port_undef.inc>
diff --git protobuf-3.17.3protobuf-3.17.3-patched/src/google/protobuf/reflection_tester.cc protobuf-3.17.3-patchedprotobuf-3.17.3-patched/src/google/protobuf/reflection_tester.cc
new file mode 100644
index 0000000..77601a7
--- /dev/null
+++ protobuf-3.17.3-patchedprotobuf-3.17.3-patched/src/google/protobuf/reflection_tester.cc
@@ -0,0 +1,1673 @@
+// Protocol Buffers - Google's data interchange format
+// Copyright 2008 Google Inc.  All rights reserved.
+// https://developers.google.com/protocol-buffers/
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include <google/protobuf/reflection_tester.h>
+
+#include <google/protobuf/map_field.h>
+#include <google/protobuf/message.h>
+#include <gtest/gtest.h>
+
+// Must include last.
+#include <google/protobuf/port_def.inc>
+
+namespace google {
+namespace protobuf {
+
+MapReflectionTester::MapReflectionTester(const Descriptor* base_descriptor)
+    : base_descriptor_(base_descriptor) {
+  const DescriptorPool* pool = base_descriptor->file()->pool();
+  std::string package = base_descriptor->file()->package();
+
+  map_enum_foo_ = pool->FindEnumValueByName(package + ".MAP_ENUM_FOO");
+  map_enum_bar_ = pool->FindEnumValueByName(package + ".MAP_ENUM_BAR");
+  map_enum_baz_ = pool->FindEnumValueByName(package + ".MAP_ENUM_BAZ");
+
+  foreign_c_ = pool->FindFieldByName(package + ".ForeignMessage.c");
+  map_int32_int32_key_ =
+      pool->FindFieldByName(package + ".TestMap.MapInt32Int32Entry.key");
+  map_int32_int32_val_ =
+      pool->FindFieldByName(package + ".TestMap.MapInt32Int32Entry.value");
+  map_int64_int64_key_ =
+      pool->FindFieldByName(package + ".TestMap.MapInt64Int64Entry.key");
+  map_int64_int64_val_ =
+      pool->FindFieldByName(package + ".TestMap.MapInt64Int64Entry.value");
+  map_uint32_uint32_key_ =
+      pool->FindFieldByName(package + ".TestMap.MapUint32Uint32Entry.key");
+  map_uint32_uint32_val_ =
+      pool->FindFieldByName(package + ".TestMap.MapUint32Uint32Entry.value");
+  map_uint64_uint64_key_ =
+      pool->FindFieldByName(package + ".TestMap.MapUint64Uint64Entry.key");
+  map_uint64_uint64_val_ =
+      pool->FindFieldByName(package + ".TestMap.MapUint64Uint64Entry.value");
+  map_sint32_sint32_key_ =
+      pool->FindFieldByName(package + ".TestMap.MapSint32Sint32Entry.key");
+  map_sint32_sint32_val_ =
+      pool->FindFieldByName(package + ".TestMap.MapSint32Sint32Entry.value");
+  map_sint64_sint64_key_ =
+      pool->FindFieldByName(package + ".TestMap.MapSint64Sint64Entry.key");
+  map_sint64_sint64_val_ =
+      pool->FindFieldByName(package + ".TestMap.MapSint64Sint64Entry.value");
+  map_fixed32_fixed32_key_ =
+      pool->FindFieldByName(package + ".TestMap.MapFixed32Fixed32Entry.key");
+  map_fixed32_fixed32_val_ =
+      pool->FindFieldByName(package + ".TestMap.MapFixed32Fixed32Entry.value");
+  map_fixed64_fixed64_key_ =
+      pool->FindFieldByName(package + ".TestMap.MapFixed64Fixed64Entry.key");
+  map_fixed64_fixed64_val_ =
+      pool->FindFieldByName(package + ".TestMap.MapFixed64Fixed64Entry.value");
+  map_sfixed32_sfixed32_key_ =
+      pool->FindFieldByName(package + ".TestMap.MapSfixed32Sfixed32Entry.key");
+  map_sfixed32_sfixed32_val_ = pool->FindFieldByName(
+      package + ".TestMap.MapSfixed32Sfixed32Entry.value");
+  map_sfixed64_sfixed64_key_ =
+      pool->FindFieldByName(package + ".TestMap.MapSfixed64Sfixed64Entry.key");
+  map_sfixed64_sfixed64_val_ = pool->FindFieldByName(
+      package + ".TestMap.MapSfixed64Sfixed64Entry.value");
+  map_int32_float_key_ =
+      pool->FindFieldByName(package + ".TestMap.MapInt32FloatEntry.key");
+  map_int32_float_val_ =
+      pool->FindFieldByName(package + ".TestMap.MapInt32FloatEntry.value");
+  map_int32_double_key_ =
+      pool->FindFieldByName(package + ".TestMap.MapInt32DoubleEntry.key");
+  map_int32_double_val_ =
+      pool->FindFieldByName(package + ".TestMap.MapInt32DoubleEntry.value");
+  map_bool_bool_key_ =
+      pool->FindFieldByName(package + ".TestMap.MapBoolBoolEntry.key");
+  map_bool_bool_val_ =
+      pool->FindFieldByName(package + ".TestMap.MapBoolBoolEntry.value");
+  map_string_string_key_ =
+      pool->FindFieldByName(package + ".TestMap.MapStringStringEntry.key");
+  map_string_string_val_ =
+      pool->FindFieldByName(package + ".TestMap.MapStringStringEntry.value");
+  map_int32_bytes_key_ =
+      pool->FindFieldByName(package + ".TestMap.MapInt32BytesEntry.key");
+  map_int32_bytes_val_ =
+      pool->FindFieldByName(package + ".TestMap.MapInt32BytesEntry.value");
+  map_int32_enum_key_ =
+      pool->FindFieldByName(package + ".TestMap.MapInt32EnumEntry.key");
+  map_int32_enum_val_ =
+      pool->FindFieldByName(package + ".TestMap.MapInt32EnumEntry.value");
+  map_int32_foreign_message_key_ = pool->FindFieldByName(
+      package + ".TestMap.MapInt32ForeignMessageEntry.key");
+  map_int32_foreign_message_val_ = pool->FindFieldByName(
+      package + ".TestMap.MapInt32ForeignMessageEntry.value");
+
+  EXPECT_FALSE(map_enum_foo_ == nullptr);
+  EXPECT_FALSE(map_enum_bar_ == nullptr);
+  EXPECT_FALSE(map_enum_baz_ == nullptr);
+  EXPECT_FALSE(map_int32_int32_key_ == nullptr);
+  EXPECT_FALSE(map_int32_int32_val_ == nullptr);
+  EXPECT_FALSE(map_int64_int64_key_ == nullptr);
+  EXPECT_FALSE(map_int64_int64_val_ == nullptr);
+  EXPECT_FALSE(map_uint32_uint32_key_ == nullptr);
+  EXPECT_FALSE(map_uint32_uint32_val_ == nullptr);
+  EXPECT_FALSE(map_uint64_uint64_key_ == nullptr);
+  EXPECT_FALSE(map_uint64_uint64_val_ == nullptr);
+  EXPECT_FALSE(map_sint32_sint32_key_ == nullptr);
+  EXPECT_FALSE(map_sint32_sint32_val_ == nullptr);
+  EXPECT_FALSE(map_sint64_sint64_key_ == nullptr);
+  EXPECT_FALSE(map_sint64_sint64_val_ == nullptr);
+  EXPECT_FALSE(map_fixed32_fixed32_key_ == nullptr);
+  EXPECT_FALSE(map_fixed32_fixed32_val_ == nullptr);
+  EXPECT_FALSE(map_fixed64_fixed64_key_ == nullptr);
+  EXPECT_FALSE(map_fixed64_fixed64_val_ == nullptr);
+  EXPECT_FALSE(map_sfixed32_sfixed32_key_ == nullptr);
+  EXPECT_FALSE(map_sfixed32_sfixed32_val_ == nullptr);
+  EXPECT_FALSE(map_sfixed64_sfixed64_key_ == nullptr);
+  EXPECT_FALSE(map_sfixed64_sfixed64_val_ == nullptr);
+  EXPECT_FALSE(map_int32_float_key_ == nullptr);
+  EXPECT_FALSE(map_int32_float_val_ == nullptr);
+  EXPECT_FALSE(map_int32_double_key_ == nullptr);
+  EXPECT_FALSE(map_int32_double_val_ == nullptr);
+  EXPECT_FALSE(map_bool_bool_key_ == nullptr);
+  EXPECT_FALSE(map_bool_bool_val_ == nullptr);
+  EXPECT_FALSE(map_string_string_key_ == nullptr);
+  EXPECT_FALSE(map_string_string_val_ == nullptr);
+  EXPECT_FALSE(map_int32_bytes_key_ == nullptr);
+  EXPECT_FALSE(map_int32_bytes_val_ == nullptr);
+  EXPECT_FALSE(map_int32_enum_key_ == nullptr);
+  EXPECT_FALSE(map_int32_enum_val_ == nullptr);
+  EXPECT_FALSE(map_int32_foreign_message_key_ == nullptr);
+  EXPECT_FALSE(map_int32_foreign_message_val_ == nullptr);
+
+  std::vector<const FieldDescriptor*> all_map_descriptors = {
+      map_int32_int32_key_,
+      map_int32_int32_val_,
+      map_int64_int64_key_,
+      map_int64_int64_val_,
+      map_uint32_uint32_key_,
+      map_uint32_uint32_val_,
+      map_uint64_uint64_key_,
+      map_uint64_uint64_val_,
+      map_sint32_sint32_key_,
+      map_sint32_sint32_val_,
+      map_sint64_sint64_key_,
+      map_sint64_sint64_val_,
+      map_fixed32_fixed32_key_,
+      map_fixed32_fixed32_val_,
+      map_fixed64_fixed64_key_,
+      map_fixed64_fixed64_val_,
+      map_sfixed32_sfixed32_key_,
+      map_sfixed32_sfixed32_val_,
+      map_sfixed64_sfixed64_key_,
+      map_sfixed64_sfixed64_val_,
+      map_int32_float_key_,
+      map_int32_float_val_,
+      map_int32_double_key_,
+      map_int32_double_val_,
+      map_bool_bool_key_,
+      map_bool_bool_val_,
+      map_string_string_key_,
+      map_string_string_val_,
+      map_int32_bytes_key_,
+      map_int32_bytes_val_,
+      map_int32_enum_key_,
+      map_int32_enum_val_,
+      map_int32_foreign_message_key_,
+      map_int32_foreign_message_val_};
+  for (const FieldDescriptor* fdesc : all_map_descriptors) {
+    GOOGLE_CHECK(fdesc->containing_type() != nullptr) << fdesc->name();
+    if (fdesc->name() == "key") {
+      EXPECT_EQ(fdesc->containing_type()->map_key(), fdesc);
+    } else {
+      EXPECT_EQ(fdesc->name(), "value");
+      EXPECT_EQ(fdesc->containing_type()->map_value(), fdesc);
+    }
+  }
+}
+
+// Shorthand to get a FieldDescriptor for a field of unittest::TestMap.
+const FieldDescriptor* MapReflectionTester::F(const std::string& name) {
+  const FieldDescriptor* result = nullptr;
+  result = base_descriptor_->FindFieldByName(name);
+  GOOGLE_CHECK(result != nullptr);
+  return result;
+}
+
+void MapReflectionTester::SetMapFieldsViaReflection(Message* message) {
+  const Reflection* reflection = message->GetReflection();
+  Message* sub_message = nullptr;
+  Message* sub_foreign_message = nullptr;
+
+  // Add first element.
+  sub_message = reflection->AddMessage(message, F("map_int32_int32"));
+  sub_message->GetReflection()->SetInt32(sub_message, map_int32_int32_key_, 0);
+  sub_message->GetReflection()->SetInt32(sub_message, map_int32_int32_val_, 0);
+
+  sub_message = reflection->AddMessage(message, F("map_int64_int64"));
+  sub_message->GetReflection()->SetInt64(sub_message, map_int64_int64_key_, 0);
+  sub_message->GetReflection()->SetInt64(sub_message, map_int64_int64_val_, 0);
+
+  sub_message = reflection->AddMessage(message, F("map_uint32_uint32"));
+  sub_message->GetReflection()->SetUInt32(sub_message, map_uint32_uint32_key_,
+                                          0);
+  sub_message->GetReflection()->SetUInt32(sub_message, map_uint32_uint32_val_,
+                                          0);
+
+  sub_message = reflection->AddMessage(message, F("map_uint64_uint64"));
+  sub_message->GetReflection()->SetUInt64(sub_message, map_uint64_uint64_key_,
+                                          0);
+  sub_message->GetReflection()->SetUInt64(sub_message, map_uint64_uint64_val_,
+                                          0);
+
+  sub_message = reflection->AddMessage(message, F("map_sint32_sint32"));
+  sub_message->GetReflection()->SetInt32(sub_message, map_sint32_sint32_key_,
+                                         0);
+  sub_message->GetReflection()->SetInt32(sub_message, map_sint32_sint32_val_,
+                                         0);
+
+  sub_message = reflection->AddMessage(message, F("map_sint64_sint64"));
+  sub_message->GetReflection()->SetInt64(sub_message, map_sint64_sint64_key_,
+                                         0);
+  sub_message->GetReflection()->SetInt64(sub_message, map_sint64_sint64_val_,
+                                         0);
+
+  sub_message = reflection->AddMessage(message, F("map_fixed32_fixed32"));
+  sub_message->GetReflection()->SetUInt32(sub_message, map_fixed32_fixed32_key_,
+                                          0);
+  sub_message->GetReflection()->SetUInt32(sub_message, map_fixed32_fixed32_val_,
+                                          0);
+
+  sub_message = reflection->AddMessage(message, F("map_fixed64_fixed64"));
+  sub_message->GetReflection()->SetUInt64(sub_message, map_fixed64_fixed64_key_,
+                                          0);
+  sub_message->GetReflection()->SetUInt64(sub_message, map_fixed64_fixed64_val_,
+                                          0);
+
+  sub_message = reflection->AddMessage(message, F("map_sfixed32_sfixed32"));
+  sub_message->GetReflection()->SetInt32(sub_message,
+                                         map_sfixed32_sfixed32_key_, 0);
+  sub_message->GetReflection()->SetInt32(sub_message,
+                                         map_sfixed32_sfixed32_val_, 0);
+
+  sub_message = reflection->AddMessage(message, F("map_sfixed64_sfixed64"));
+  sub_message->GetReflection()->SetInt64(sub_message,
+                                         map_sfixed64_sfixed64_key_, 0);
+  sub_message->GetReflection()->SetInt64(sub_message,
+                                         map_sfixed64_sfixed64_val_, 0);
+
+  sub_message = reflection->AddMessage(message, F("map_int32_float"));
+  sub_message->GetReflection()->SetInt32(sub_message, map_int32_float_key_, 0);
+  sub_message->GetReflection()->SetFloat(sub_message, map_int32_float_val_,
+                                         0.0);
+
+  sub_message = reflection->AddMessage(message, F("map_int32_double"));
+  sub_message->GetReflection()->SetInt32(sub_message, map_int32_double_key_, 0);
+  sub_message->GetReflection()->SetDouble(sub_message, map_int32_double_val_,
+                                          0.0);
+
+  sub_message = reflection->AddMessage(message, F("map_bool_bool"));
+  sub_message->GetReflection()->SetBool(sub_message, map_bool_bool_key_, false);
+  sub_message->GetReflection()->SetBool(sub_message, map_bool_bool_val_, false);
+
+  sub_message = reflection->AddMessage(message, F("map_string_string"));
+  sub_message->GetReflection()->SetString(sub_message, map_string_string_key_,
+                                          "0");
+  sub_message->GetReflection()->SetString(sub_message, map_string_string_val_,
+                                          "0");
+
+  sub_message = reflection->AddMessage(message, F("map_int32_bytes"));
+  sub_message->GetReflection()->SetInt32(sub_message, map_int32_bytes_key_, 0);
+  sub_message->GetReflection()->SetString(sub_message, map_int32_bytes_val_,
+                                          "0");
+
+  sub_message = reflection->AddMessage(message, F("map_int32_enum"));
+  sub_message->GetReflection()->SetInt32(sub_message, map_int32_enum_key_, 0);
+  sub_message->GetReflection()->SetEnum(sub_message, map_int32_enum_val_,
+                                        map_enum_bar_);
+
+  sub_message = reflection->AddMessage(message, F("map_int32_foreign_message"));
+  sub_message->GetReflection()->SetInt32(sub_message,
+                                         map_int32_foreign_message_key_, 0);
+  sub_foreign_message = sub_message->GetReflection()->MutableMessage(
+      sub_message, map_int32_foreign_message_val_, nullptr);
+  sub_foreign_message->GetReflection()->SetInt32(sub_foreign_message,
+                                                 foreign_c_, 0);
+
+  // Add second element
+  sub_message = reflection->AddMessage(message, F("map_int32_int32"));
+  sub_message->GetReflection()->SetInt32(sub_message, map_int32_int32_key_, 1);
+  sub_message->GetReflection()->SetInt32(sub_message, map_int32_int32_val_, 1);
+
+  sub_message = reflection->AddMessage(message, F("map_int64_int64"));
+  sub_message->GetReflection()->SetInt64(sub_message, map_int64_int64_key_, 1);
+  sub_message->GetReflection()->SetInt64(sub_message, map_int64_int64_val_, 1);
+
+  sub_message = reflection->AddMessage(message, F("map_uint32_uint32"));
+  sub_message->GetReflection()->SetUInt32(sub_message, map_uint32_uint32_key_,
+                                          1);
+  sub_message->GetReflection()->SetUInt32(sub_message, map_uint32_uint32_val_,
+                                          1);
+
+  sub_message = reflection->AddMessage(message, F("map_uint64_uint64"));
+  sub_message->GetReflection()->SetUInt64(sub_message, map_uint64_uint64_key_,
+                                          1);
+  sub_message->GetReflection()->SetUInt64(sub_message, map_uint64_uint64_val_,
+                                          1);
+
+  sub_message = reflection->AddMessage(message, F("map_sint32_sint32"));
+  sub_message->GetReflection()->SetInt32(sub_message, map_sint32_sint32_key_,
+                                         1);
+  sub_message->GetReflection()->SetInt32(sub_message, map_sint32_sint32_val_,
+                                         1);
+
+  sub_message = reflection->AddMessage(message, F("map_sint64_sint64"));
+  sub_message->GetReflection()->SetInt64(sub_message, map_sint64_sint64_key_,
+                                         1);
+  sub_message->GetReflection()->SetInt64(sub_message, map_sint64_sint64_val_,
+                                         1);
+
+  sub_message = reflection->AddMessage(message, F("map_fixed32_fixed32"));
+  sub_message->GetReflection()->SetUInt32(sub_message, map_fixed32_fixed32_key_,
+                                          1);
+  sub_message->GetReflection()->SetUInt32(sub_message, map_fixed32_fixed32_val_,
+                                          1);
+
+  sub_message = reflection->AddMessage(message, F("map_fixed64_fixed64"));
+  sub_message->GetReflection()->SetUInt64(sub_message, map_fixed64_fixed64_key_,
+                                          1);
+  sub_message->GetReflection()->SetUInt64(sub_message, map_fixed64_fixed64_val_,
+                                          1);
+
+  sub_message = reflection->AddMessage(message, F("map_sfixed32_sfixed32"));
+  sub_message->GetReflection()->SetInt32(sub_message,
+                                         map_sfixed32_sfixed32_key_, 1);
+  sub_message->GetReflection()->SetInt32(sub_message,
+                                         map_sfixed32_sfixed32_val_, 1);
+
+  sub_message = reflection->AddMessage(message, F("map_sfixed64_sfixed64"));
+  sub_message->GetReflection()->SetInt64(sub_message,
+                                         map_sfixed64_sfixed64_key_, 1);
+  sub_message->GetReflection()->SetInt64(sub_message,
+                                         map_sfixed64_sfixed64_val_, 1);
+
+  sub_message = reflection->AddMessage(message, F("map_int32_float"));
+  sub_message->GetReflection()->SetInt32(sub_message, map_int32_float_key_, 1);
+  sub_message->GetReflection()->SetFloat(sub_message, map_int32_float_val_,
+                                         1.0);
+
+  sub_message = reflection->AddMessage(message, F("map_int32_double"));
+  sub_message->GetReflection()->SetInt32(sub_message, map_int32_double_key_, 1);
+  sub_message->GetReflection()->SetDouble(sub_message, map_int32_double_val_,
+                                          1.0);
+
+  sub_message = reflection->AddMessage(message, F("map_bool_bool"));
+  sub_message->GetReflection()->SetBool(sub_message, map_bool_bool_key_, true);
+  sub_message->GetReflection()->SetBool(sub_message, map_bool_bool_val_, true);
+
+  sub_message = reflection->AddMessage(message, F("map_string_string"));
+  sub_message->GetReflection()->SetString(sub_message, map_string_string_key_,
+                                          "1");
+  sub_message->GetReflection()->SetString(sub_message, map_string_string_val_,
+                                          "1");
+
+  sub_message = reflection->AddMessage(message, F("map_int32_bytes"));
+  sub_message->GetReflection()->SetInt32(sub_message, map_int32_bytes_key_, 1);
+  sub_message->GetReflection()->SetString(sub_message, map_int32_bytes_val_,
+                                          "1");
+
+  sub_message = reflection->AddMessage(message, F("map_int32_enum"));
+  sub_message->GetReflection()->SetInt32(sub_message, map_int32_enum_key_, 1);
+  sub_message->GetReflection()->SetEnum(sub_message, map_int32_enum_val_,
+                                        map_enum_baz_);
+
+  sub_message = reflection->AddMessage(message, F("map_int32_foreign_message"));
+  sub_message->GetReflection()->SetInt32(sub_message,
+                                         map_int32_foreign_message_key_, 1);
+  sub_foreign_message = sub_message->GetReflection()->MutableMessage(
+      sub_message, map_int32_foreign_message_val_, nullptr);
+  sub_foreign_message->GetReflection()->SetInt32(sub_foreign_message,
+                                                 foreign_c_, 1);
+}
+
+void MapReflectionTester::SetMapFieldsViaMapReflection(Message* message) {
+  const Reflection* reflection = message->GetReflection();
+
+  Message* sub_foreign_message = nullptr;
+  MapValueRef map_val;
+  MapValueConstRef map_val_const;
+
+  // Add first element.
+  MapKey map_key;
+  map_key.SetInt32Value(0);
+  EXPECT_FALSE(reflection->LookupMapValue(*message, F("map_int32_int32"),
+                                          map_key, &map_val_const));
+  EXPECT_TRUE(reflection->InsertOrLookupMapValue(message, F("map_int32_int32"),
+                                                 map_key, &map_val));
+  map_val.SetInt32Value(0);
+
+  map_key.SetInt64Value(0);
+  EXPECT_FALSE(reflection->LookupMapValue(*message, F("map_int64_int64"),
+                                          map_key, &map_val_const));
+  EXPECT_TRUE(reflection->InsertOrLookupMapValue(message, F("map_int64_int64"),
+                                                 map_key, &map_val));
+  map_val.SetInt64Value(0);
+
+  map_key.SetUInt32Value(0);
+  EXPECT_FALSE(reflection->LookupMapValue(*message, F("map_uint32_uint32"),
+                                          map_key, &map_val_const));
+  EXPECT_TRUE(reflection->InsertOrLookupMapValue(
+      message, F("map_uint32_uint32"), map_key, &map_val));
+  map_val.SetUInt32Value(0);
+
+  map_key.SetUInt64Value(0);
+  EXPECT_TRUE(reflection->InsertOrLookupMapValue(
+      message, F("map_uint64_uint64"), map_key, &map_val));
+  map_val.SetUInt64Value(0);
+
+  map_key.SetInt32Value(0);
+  EXPECT_TRUE(reflection->InsertOrLookupMapValue(
+      message, F("map_sint32_sint32"), map_key, &map_val));
+  map_val.SetInt32Value(0);
+
+  map_key.SetInt64Value(0);
+  EXPECT_TRUE(reflection->InsertOrLookupMapValue(
+      message, F("map_sint64_sint64"), map_key, &map_val));
+  map_val.SetInt64Value(0);
+
+  map_key.SetUInt32Value(0);
+  EXPECT_TRUE(reflection->InsertOrLookupMapValue(
+      message, F("map_fixed32_fixed32"), map_key, &map_val));
+  map_val.SetUInt32Value(0);
+
+  map_key.SetUInt64Value(0);
+  EXPECT_TRUE(reflection->InsertOrLookupMapValue(
+      message, F("map_fixed64_fixed64"), map_key, &map_val));
+  map_val.SetUInt64Value(0);
+
+  map_key.SetInt32Value(0);
+  EXPECT_TRUE(reflection->InsertOrLookupMapValue(
+      message, F("map_sfixed32_sfixed32"), map_key, &map_val));
+  map_val.SetInt32Value(0);
+
+  map_key.SetInt64Value(0);
+  EXPECT_TRUE(reflection->InsertOrLookupMapValue(
+      message, F("map_sfixed64_sfixed64"), map_key, &map_val));
+  map_val.SetInt64Value(0);
+
+  map_key.SetInt32Value(0);
+  EXPECT_TRUE(reflection->InsertOrLookupMapValue(message, F("map_int32_float"),
+                                                 map_key, &map_val));
+  map_val.SetFloatValue(0.0);
+
+  map_key.SetInt32Value(0);
+  EXPECT_TRUE(reflection->InsertOrLookupMapValue(message, F("map_int32_double"),
+                                                 map_key, &map_val));
+  map_val.SetDoubleValue(0.0);
+
+  map_key.SetBoolValue(false);
+  EXPECT_FALSE(reflection->LookupMapValue(*message, F("map_bool_bool"), map_key,
+                                          &map_val_const));
+  EXPECT_TRUE(reflection->InsertOrLookupMapValue(message, F("map_bool_bool"),
+                                                 map_key, &map_val));
+  map_val.SetBoolValue(false);
+
+  map_key.SetStringValue("0");
+  EXPECT_FALSE(reflection->LookupMapValue(*message, F("map_string_string"),
+                                          map_key, &map_val_const));
+  EXPECT_TRUE(reflection->InsertOrLookupMapValue(
+      message, F("map_string_string"), map_key, &map_val));
+  map_val.SetStringValue("0");
+
+  map_key.SetInt32Value(0);
+  EXPECT_FALSE(reflection->LookupMapValue(*message, F("map_int32_bytes"),
+                                          map_key, &map_val_const));
+  EXPECT_TRUE(reflection->InsertOrLookupMapValue(message, F("map_int32_bytes"),
+                                                 map_key, &map_val));
+  map_val.SetStringValue("0");
+
+  map_key.SetInt32Value(0);
+  EXPECT_FALSE(reflection->LookupMapValue(*message, F("map_int32_enum"),
+                                          map_key, &map_val_const));
+  EXPECT_TRUE(reflection->InsertOrLookupMapValue(message, F("map_int32_enum"),
+                                                 map_key, &map_val));
+  map_val.SetEnumValue(map_enum_bar_->number());
+
+  map_key.SetInt32Value(0);
+  EXPECT_FALSE(reflection->LookupMapValue(
+      *message, F("map_int32_foreign_message"), map_key, &map_val_const));
+  EXPECT_TRUE(reflection->InsertOrLookupMapValue(
+      message, F("map_int32_foreign_message"), map_key, &map_val));
+  sub_foreign_message = map_val.MutableMessageValue();
+  sub_foreign_message->GetReflection()->SetInt32(sub_foreign_message,
+                                                 foreign_c_, 0);
+
+  // Add second element
+  map_key.SetInt32Value(1);
+  EXPECT_TRUE(reflection->InsertOrLookupMapValue(message, F("map_int32_int32"),
+                                                 map_key, &map_val));
+  map_val.SetInt32Value(1);
+  EXPECT_FALSE(reflection->InsertOrLookupMapValue(message, F("map_int32_int32"),
+                                                  map_key, &map_val));
+
+  map_key.SetInt64Value(1);
+  EXPECT_TRUE(reflection->InsertOrLookupMapValue(message, F("map_int64_int64"),
+                                                 map_key, &map_val));
+  map_val.SetInt64Value(1);
+  EXPECT_FALSE(reflection->InsertOrLookupMapValue(message, F("map_int64_int64"),
+                                                  map_key, &map_val));
+
+  map_key.SetUInt32Value(1);
+  reflection->InsertOrLookupMapValue(message, F("map_uint32_uint32"), map_key,
+                                     &map_val);
+  map_val.SetUInt32Value(1);
+
+  map_key.SetUInt64Value(1);
+  reflection->InsertOrLookupMapValue(message, F("map_uint64_uint64"), map_key,
+                                     &map_val);
+  map_val.SetUInt64Value(1);
+
+  map_key.SetInt32Value(1);
+  reflection->InsertOrLookupMapValue(message, F("map_sint32_sint32"), map_key,
+                                     &map_val);
+  map_val.SetInt32Value(1);
+
+  map_key.SetInt64Value(1);
+  reflection->InsertOrLookupMapValue(message, F("map_sint64_sint64"), map_key,
+                                     &map_val);
+  map_val.SetInt64Value(1);
+
+  map_key.SetUInt32Value(1);
+  reflection->InsertOrLookupMapValue(message, F("map_fixed32_fixed32"), map_key,
+                                     &map_val);
+  map_val.SetUInt32Value(1);
+
+  map_key.SetUInt64Value(1);
+  reflection->InsertOrLookupMapValue(message, F("map_fixed64_fixed64"), map_key,
+                                     &map_val);
+  map_val.SetUInt64Value(1);
+
+  map_key.SetInt32Value(1);
+  reflection->InsertOrLookupMapValue(message, F("map_sfixed32_sfixed32"),
+                                     map_key, &map_val);
+  map_val.SetInt32Value(1);
+
+  map_key.SetInt64Value(1);
+  reflection->InsertOrLookupMapValue(message, F("map_sfixed64_sfixed64"),
+                                     map_key, &map_val);
+  map_val.SetInt64Value(1);
+
+  map_key.SetInt32Value(1);
+  reflection->InsertOrLookupMapValue(message, F("map_int32_float"), map_key,
+                                     &map_val);
+  map_val.SetFloatValue(1.0);
+
+  map_key.SetInt32Value(1);
+  reflection->InsertOrLookupMapValue(message, F("map_int32_double"), map_key,
+                                     &map_val);
+  map_val.SetDoubleValue(1.0);
+
+  map_key.SetBoolValue(true);
+  reflection->InsertOrLookupMapValue(message, F("map_bool_bool"), map_key,
+                                     &map_val);
+  map_val.SetBoolValue(true);
+
+  map_key.SetStringValue("1");
+  reflection->InsertOrLookupMapValue(message, F("map_string_string"), map_key,
+                                     &map_val);
+  map_val.SetStringValue("1");
+
+  map_key.SetInt32Value(1);
+  reflection->InsertOrLookupMapValue(message, F("map_int32_bytes"), map_key,
+                                     &map_val);
+  map_val.SetStringValue("1");
+
+  map_key.SetInt32Value(1);
+  reflection->InsertOrLookupMapValue(message, F("map_int32_enum"), map_key,
+                                     &map_val);
+  map_val.SetEnumValue(map_enum_baz_->number());
+
+  map_key.SetInt32Value(1);
+  EXPECT_TRUE(reflection->InsertOrLookupMapValue(
+      message, F("map_int32_foreign_message"), map_key, &map_val));
+  sub_foreign_message = map_val.MutableMessageValue();
+  sub_foreign_message->GetReflection()->SetInt32(sub_foreign_message,
+                                                 foreign_c_, 1);
+}
+
+void MapReflectionTester::GetMapValueViaMapReflection(
+    Message* message, const std::string& field_name, const MapKey& map_key,
+    MapValueRef* map_val) {
+  const Reflection* reflection = message->GetReflection();
+  EXPECT_FALSE(reflection->InsertOrLookupMapValue(message, F(field_name),
+                                                  map_key, map_val));
+}
+
+Message* MapReflectionTester::GetMapEntryViaReflection(
+    Message* message, const std::string& field_name, int index) {
+  const Reflection* reflection = message->GetReflection();
+  return reflection->MutableRepeatedMessage(message, F(field_name), index);
+}
+
+MapIterator MapReflectionTester::MapBegin(Message* message,
+                                          const std::string& field_name) {
+  const Reflection* reflection = message->GetReflection();
+  return reflection->MapBegin(message, F(field_name));
+}
+
+MapIterator MapReflectionTester::MapEnd(Message* message,
+                                        const std::string& field_name) {
+  const Reflection* reflection = message->GetReflection();
+  return reflection->MapEnd(message, F(field_name));
+}
+
+int MapReflectionTester::MapSize(const Message& message,
+                                 const std::string& field_name) {
+  const Reflection* reflection = message.GetReflection();
+  return reflection->MapSize(message, F(field_name));
+}
+
+void MapReflectionTester::ClearMapFieldsViaReflection(Message* message) {
+  const Reflection* reflection = message->GetReflection();
+
+  reflection->ClearField(message, F("map_int32_int32"));
+  reflection->ClearField(message, F("map_int64_int64"));
+  reflection->ClearField(message, F("map_uint32_uint32"));
+  reflection->ClearField(message, F("map_uint64_uint64"));
+  reflection->ClearField(message, F("map_sint32_sint32"));
+  reflection->ClearField(message, F("map_sint64_sint64"));
+  reflection->ClearField(message, F("map_fixed32_fixed32"));
+  reflection->ClearField(message, F("map_fixed64_fixed64"));
+  reflection->ClearField(message, F("map_sfixed32_sfixed32"));
+  reflection->ClearField(message, F("map_sfixed64_sfixed64"));
+  reflection->ClearField(message, F("map_int32_float"));
+  reflection->ClearField(message, F("map_int32_double"));
+  reflection->ClearField(message, F("map_bool_bool"));
+  reflection->ClearField(message, F("map_string_string"));
+  reflection->ClearField(message, F("map_int32_bytes"));
+  reflection->ClearField(message, F("map_int32_enum"));
+  reflection->ClearField(message, F("map_int32_foreign_message"));
+}
+
+void MapReflectionTester::ModifyMapFieldsViaReflection(Message* message) {
+  const Reflection* reflection = message->GetReflection();
+  MapValueRef map_val;
+  Message* sub_foreign_message;
+
+  // Modify the second element
+  MapKey map_key;
+  map_key.SetInt32Value(1);
+  EXPECT_FALSE(reflection->InsertOrLookupMapValue(message, F("map_int32_int32"),
+                                                  map_key, &map_val));
+  map_val.SetInt32Value(2);
+
+  map_key.SetInt64Value(1);
+  EXPECT_FALSE(reflection->InsertOrLookupMapValue(message, F("map_int64_int64"),
+                                                  map_key, &map_val));
+  map_val.SetInt64Value(2);
+
+  map_key.SetUInt32Value(1);
+  EXPECT_FALSE(reflection->InsertOrLookupMapValue(
+      message, F("map_uint32_uint32"), map_key, &map_val));
+  map_val.SetUInt32Value(2);
+
+  map_key.SetUInt64Value(1);
+  reflection->InsertOrLookupMapValue(message, F("map_uint64_uint64"), map_key,
+                                     &map_val);
+  map_val.SetUInt64Value(2);
+
+  map_key.SetInt32Value(1);
+  reflection->InsertOrLookupMapValue(message, F("map_sint32_sint32"), map_key,
+                                     &map_val);
+  map_val.SetInt32Value(2);
+
+  map_key.SetInt64Value(1);
+  reflection->InsertOrLookupMapValue(message, F("map_sint64_sint64"), map_key,
+                                     &map_val);
+  map_val.SetInt64Value(2);
+
+  map_key.SetUInt32Value(1);
+  reflection->InsertOrLookupMapValue(message, F("map_fixed32_fixed32"), map_key,
+                                     &map_val);
+  map_val.SetUInt32Value(2);
+
+  map_key.SetUInt64Value(1);
+  reflection->InsertOrLookupMapValue(message, F("map_fixed64_fixed64"), map_key,
+                                     &map_val);
+  map_val.SetUInt64Value(2);
+
+  map_key.SetInt32Value(1);
+  reflection->InsertOrLookupMapValue(message, F("map_sfixed32_sfixed32"),
+                                     map_key, &map_val);
+  map_val.SetInt32Value(2);
+
+  map_key.SetInt64Value(1);
+  reflection->InsertOrLookupMapValue(message, F("map_sfixed64_sfixed64"),
+                                     map_key, &map_val);
+  map_val.SetInt64Value(2);
+
+  map_key.SetInt32Value(1);
+  reflection->InsertOrLookupMapValue(message, F("map_int32_float"), map_key,
+                                     &map_val);
+  map_val.SetFloatValue(2.0);
+
+  map_key.SetInt32Value(1);
+  reflection->InsertOrLookupMapValue(message, F("map_int32_double"), map_key,
+                                     &map_val);
+  map_val.SetDoubleValue(2.0);
+
+  map_key.SetBoolValue(true);
+  reflection->InsertOrLookupMapValue(message, F("map_bool_bool"), map_key,
+                                     &map_val);
+  map_val.SetBoolValue(false);
+
+  map_key.SetStringValue("1");
+  reflection->InsertOrLookupMapValue(message, F("map_string_string"), map_key,
+                                     &map_val);
+  map_val.SetStringValue("2");
+
+  map_key.SetInt32Value(1);
+  reflection->InsertOrLookupMapValue(message, F("map_int32_bytes"), map_key,
+                                     &map_val);
+  map_val.SetStringValue("2");
+
+  map_key.SetInt32Value(1);
+  reflection->InsertOrLookupMapValue(message, F("map_int32_enum"), map_key,
+                                     &map_val);
+  map_val.SetEnumValue(map_enum_foo_->number());
+
+  map_key.SetInt32Value(1);
+  EXPECT_FALSE(reflection->InsertOrLookupMapValue(
+      message, F("map_int32_foreign_message"), map_key, &map_val));
+  sub_foreign_message = map_val.MutableMessageValue();
+  sub_foreign_message->GetReflection()->SetInt32(sub_foreign_message,
+                                                 foreign_c_, 2);
+}
+
+void MapReflectionTester::RemoveLastMapsViaReflection(Message* message) {
+  const Reflection* reflection = message->GetReflection();
+
+  std::vector<const FieldDescriptor*> output;
+  reflection->ListFields(*message, &output);
+  for (int i = 0; i < output.size(); ++i) {
+    const FieldDescriptor* field = output[i];
+    if (!field->is_repeated()) continue;
+    reflection->RemoveLast(message, field);
+  }
+}
+
+void MapReflectionTester::ReleaseLastMapsViaReflection(Message* message) {
+  const Reflection* reflection = message->GetReflection();
+
+  std::vector<const FieldDescriptor*> output;
+  reflection->ListFields(*message, &output);
+  for (int i = 0; i < output.size(); ++i) {
+    const FieldDescriptor* field = output[i];
+    if (!field->is_repeated()) continue;
+    if (field->cpp_type() != FieldDescriptor::CPPTYPE_MESSAGE) continue;
+
+    Message* released = reflection->ReleaseLast(message, field);
+    ASSERT_TRUE(released != nullptr)
+        << "ReleaseLast returned nullptr for: " << field->name();
+    delete released;
+  }
+}
+
+void MapReflectionTester::SwapMapsViaReflection(Message* message) {
+  const Reflection* reflection = message->GetReflection();
+  std::vector<const FieldDescriptor*> output;
+  reflection->ListFields(*message, &output);
+  for (int i = 0; i < output.size(); ++i) {
+    const FieldDescriptor* field = output[i];
+    if (!field->is_repeated()) continue;
+    reflection->SwapElements(message, field, 0, 1);
+  }
+}
+
+void MapReflectionTester::MutableUnknownFieldsOfMapFieldsViaReflection(
+    Message* message) {
+  const Reflection* reflection = message->GetReflection();
+  Message* sub_message = nullptr;
+
+  sub_message = reflection->AddMessage(message, F("map_int32_int32"));
+  EXPECT_TRUE(sub_message->GetReflection()->MutableUnknownFields(sub_message) !=
+              nullptr);
+  sub_message = reflection->AddMessage(message, F("map_int64_int64"));
+  EXPECT_TRUE(sub_message->GetReflection()->MutableUnknownFields(sub_message) !=
+              nullptr);
+  sub_message = reflection->AddMessage(message, F("map_uint32_uint32"));
+  EXPECT_TRUE(sub_message->GetReflection()->MutableUnknownFields(sub_message) !=
+              nullptr);
+  sub_message = reflection->AddMessage(message, F("map_uint64_uint64"));
+  EXPECT_TRUE(sub_message->GetReflection()->MutableUnknownFields(sub_message) !=
+              nullptr);
+  sub_message = reflection->AddMessage(message, F("map_sint32_sint32"));
+  EXPECT_TRUE(sub_message->GetReflection()->MutableUnknownFields(sub_message) !=
+              nullptr);
+  sub_message = reflection->AddMessage(message, F("map_sint64_sint64"));
+  EXPECT_TRUE(sub_message->GetReflection()->MutableUnknownFields(sub_message) !=
+              nullptr);
+  sub_message = reflection->AddMessage(message, F("map_fixed32_fixed32"));
+  EXPECT_TRUE(sub_message->GetReflection()->MutableUnknownFields(sub_message) !=
+              nullptr);
+  sub_message = reflection->AddMessage(message, F("map_fixed64_fixed64"));
+  EXPECT_TRUE(sub_message->GetReflection()->MutableUnknownFields(sub_message) !=
+              nullptr);
+  sub_message = reflection->AddMessage(message, F("map_sfixed32_sfixed32"));
+  EXPECT_TRUE(sub_message->GetReflection()->MutableUnknownFields(sub_message) !=
+              nullptr);
+  sub_message = reflection->AddMessage(message, F("map_sfixed64_sfixed64"));
+  EXPECT_TRUE(sub_message->GetReflection()->MutableUnknownFields(sub_message) !=
+              nullptr);
+  sub_message = reflection->AddMessage(message, F("map_int32_float"));
+  EXPECT_TRUE(sub_message->GetReflection()->MutableUnknownFields(sub_message) !=
+              nullptr);
+  sub_message = reflection->AddMessage(message, F("map_int32_double"));
+  EXPECT_TRUE(sub_message->GetReflection()->MutableUnknownFields(sub_message) !=
+              nullptr);
+  sub_message = reflection->AddMessage(message, F("map_bool_bool"));
+  EXPECT_TRUE(sub_message->GetReflection()->MutableUnknownFields(sub_message) !=
+              nullptr);
+  sub_message = reflection->AddMessage(message, F("map_string_string"));
+  EXPECT_TRUE(sub_message->GetReflection()->MutableUnknownFields(sub_message) !=
+              nullptr);
+  sub_message = reflection->AddMessage(message, F("map_int32_bytes"));
+  EXPECT_TRUE(sub_message->GetReflection()->MutableUnknownFields(sub_message) !=
+              nullptr);
+  sub_message = reflection->AddMessage(message, F("map_int32_enum"));
+  EXPECT_TRUE(sub_message->GetReflection()->MutableUnknownFields(sub_message) !=
+              nullptr);
+  sub_message = reflection->AddMessage(message, F("map_int32_foreign_message"));
+  EXPECT_TRUE(sub_message->GetReflection()->MutableUnknownFields(sub_message) !=
+              nullptr);
+}
+
+void MapReflectionTester::ExpectMapFieldsSetViaReflection(
+    const Message& message) {
+  std::string scratch;
+  const Reflection* reflection = message.GetReflection();
+  const Message* sub_message;
+  MapKey map_key;
+  MapValueConstRef map_value_const_ref;
+
+  // -----------------------------------------------------------------
+
+  ASSERT_EQ(2, reflection->FieldSize(message, F("map_int32_int32")));
+  ASSERT_EQ(2, reflection->FieldSize(message, F("map_int64_int64")));
+  ASSERT_EQ(2, reflection->FieldSize(message, F("map_uint32_uint32")));
+  ASSERT_EQ(2, reflection->FieldSize(message, F("map_uint64_uint64")));
+  ASSERT_EQ(2, reflection->FieldSize(message, F("map_sint32_sint32")));
+  ASSERT_EQ(2, reflection->FieldSize(message, F("map_sint64_sint64")));
+  ASSERT_EQ(2, reflection->FieldSize(message, F("map_fixed32_fixed32")));
+  ASSERT_EQ(2, reflection->FieldSize(message, F("map_fixed64_fixed64")));
+  ASSERT_EQ(2, reflection->FieldSize(message, F("map_sfixed32_sfixed32")));
+  ASSERT_EQ(2, reflection->FieldSize(message, F("map_sfixed64_sfixed64")));
+  ASSERT_EQ(2, reflection->FieldSize(message, F("map_int32_float")));
+  ASSERT_EQ(2, reflection->FieldSize(message, F("map_int32_double")));
+  ASSERT_EQ(2, reflection->FieldSize(message, F("map_bool_bool")));
+  ASSERT_EQ(2, reflection->FieldSize(message, F("map_string_string")));
+  ASSERT_EQ(2, reflection->FieldSize(message, F("map_int32_bytes")));
+  ASSERT_EQ(2, reflection->FieldSize(message, F("map_int32_enum")));
+  ASSERT_EQ(2, reflection->FieldSize(message, F("map_int32_foreign_message")));
+
+  {
+    std::map<int32_t, int32_t> map;
+    map[0] = 0;
+    map[1] = 1;
+    for (int i = 0; i < 2; i++) {
+      const internal::MapFieldBase& map_field =
+          reflection->GetRaw<internal::MapFieldBase>(message,
+                                                     F("map_int32_int32"));
+      if (map_field.IsRepeatedFieldValid()) {
+        // Check with RepeatedField Reflection
+        sub_message =
+            &reflection->GetRepeatedMessage(message, F("map_int32_int32"), i);
+        int32_t key = sub_message->GetReflection()->GetInt32(
+            *sub_message, map_int32_int32_key_);
+        int32_t val = sub_message->GetReflection()->GetInt32(
+            *sub_message, map_int32_int32_val_);
+        EXPECT_EQ(map[key], val);
+      } else {
+        // Check with Map Reflection
+        map_key.SetInt32Value(i);
+        EXPECT_TRUE(
+            reflection->ContainsMapKey(message, F("map_int32_int32"), map_key));
+        EXPECT_TRUE(reflection->LookupMapValue(message, F("map_int32_int32"),
+                                               map_key, &map_value_const_ref));
+        EXPECT_EQ(map_value_const_ref.GetInt32Value(), map[i]);
+      }
+    }
+  }
+  {
+    std::map<int64_t, int64_t> map;
+    map[0] = 0;
+    map[1] = 1;
+    for (int i = 0; i < 2; i++) {
+      const internal::MapFieldBase& map_field =
+          reflection->GetRaw<internal::MapFieldBase>(message,
+                                                     F("map_int64_int64"));
+      if (map_field.IsRepeatedFieldValid()) {
+        // Check with RepeatedField Reflection
+        sub_message =
+            &reflection->GetRepeatedMessage(message, F("map_int64_int64"), i);
+        int64_t key = sub_message->GetReflection()->GetInt64(
+            *sub_message, map_int64_int64_key_);
+        int64_t val = sub_message->GetReflection()->GetInt64(
+            *sub_message, map_int64_int64_val_);
+        EXPECT_EQ(map[key], val);
+      } else {
+        // Check with Map Reflection
+        map_key.SetInt64Value(i);
+        EXPECT_TRUE(
+            reflection->ContainsMapKey(message, F("map_int64_int64"), map_key));
+        EXPECT_TRUE(reflection->LookupMapValue(message, F("map_int64_int64"),
+                                               map_key, &map_value_const_ref));
+        EXPECT_EQ(map_value_const_ref.GetInt64Value(), map[i]);
+      }
+    }
+  }
+  {
+    std::map<uint32_t, uint32_t> map;
+    map[0] = 0;
+    map[1] = 1;
+    for (int i = 0; i < 2; i++) {
+      const internal::MapFieldBase& map_field =
+          reflection->GetRaw<internal::MapFieldBase>(message,
+                                                     F("map_uint32_uint32"));
+      if (map_field.IsRepeatedFieldValid()) {
+        // Check with RepeatedField Reflection
+        sub_message =
+            &reflection->GetRepeatedMessage(message, F("map_uint32_uint32"), i);
+        uint32_t key = sub_message->GetReflection()->GetUInt32(
+            *sub_message, map_uint32_uint32_key_);
+        uint32_t val = sub_message->GetReflection()->GetUInt32(
+            *sub_message, map_uint32_uint32_val_);
+        EXPECT_EQ(map[key], val);
+      } else {
+        // Check with Map Reflection
+        map_key.SetUInt32Value(i);
+        EXPECT_TRUE(reflection->ContainsMapKey(message, F("map_uint32_uint32"),
+                                               map_key));
+        EXPECT_TRUE(reflection->LookupMapValue(message, F("map_uint32_uint32"),
+                                               map_key, &map_value_const_ref));
+        EXPECT_EQ(map_value_const_ref.GetUInt32Value(), map[i]);
+      }
+    }
+  }
+  {
+    std::map<uint64_t, uint64_t> map;
+    map[0] = 0;
+    map[1] = 1;
+    for (int i = 0; i < 2; i++) {
+      const internal::MapFieldBase& map_field =
+          reflection->GetRaw<internal::MapFieldBase>(message,
+                                                     F("map_uint64_uint64"));
+      if (map_field.IsRepeatedFieldValid()) {
+        // Check with RepeatedField Reflection
+        sub_message =
+            &reflection->GetRepeatedMessage(message, F("map_uint64_uint64"), i);
+        uint64_t key = sub_message->GetReflection()->GetUInt64(
+            *sub_message, map_uint64_uint64_key_);
+        uint64_t val = sub_message->GetReflection()->GetUInt64(
+            *sub_message, map_uint64_uint64_val_);
+        EXPECT_EQ(map[key], val);
+      } else {
+        // Check with Map Reflection
+        map_key.SetUInt64Value(i);
+        EXPECT_TRUE(reflection->ContainsMapKey(message, F("map_uint64_uint64"),
+                                               map_key));
+        EXPECT_TRUE(reflection->LookupMapValue(message, F("map_uint64_uint64"),
+                                               map_key, &map_value_const_ref));
+        EXPECT_EQ(map_value_const_ref.GetUInt64Value(), map[i]);
+      }
+    }
+  }
+  {
+    std::map<int32_t, int32_t> map;
+    map[0] = 0;
+    map[1] = 1;
+    for (int i = 0; i < 2; i++) {
+      const internal::MapFieldBase& map_field =
+          reflection->GetRaw<internal::MapFieldBase>(message,
+                                                     F("map_sint32_sint32"));
+      if (map_field.IsRepeatedFieldValid()) {
+        // Check with RepeatedField Reflection
+        sub_message =
+            &reflection->GetRepeatedMessage(message, F("map_sint32_sint32"), i);
+        int32_t key = sub_message->GetReflection()->GetInt32(
+            *sub_message, map_sint32_sint32_key_);
+        int32_t val = sub_message->GetReflection()->GetInt32(
+            *sub_message, map_sint32_sint32_val_);
+        EXPECT_EQ(map[key], val);
+      } else {
+        // Check with Map Reflection
+        map_key.SetInt32Value(i);
+        EXPECT_EQ(true, reflection->ContainsMapKey(
+                            message, F("map_sint32_sint32"), map_key));
+        EXPECT_TRUE(reflection->LookupMapValue(message, F("map_sint32_sint32"),
+                                               map_key, &map_value_const_ref));
+        EXPECT_EQ(map_value_const_ref.GetInt32Value(), map[i]);
+      }
+    }
+  }
+  {
+    std::map<int64_t, int64_t> map;
+    map[0] = 0;
+    map[1] = 1;
+    for (int i = 0; i < 2; i++) {
+      const internal::MapFieldBase& map_field =
+          reflection->GetRaw<internal::MapFieldBase>(message,
+                                                     F("map_sint64_sint64"));
+      if (map_field.IsRepeatedFieldValid()) {
+        // Check with RepeatedField Reflection
+        sub_message =
+            &reflection->GetRepeatedMessage(message, F("map_sint64_sint64"), i);
+        int64_t key = sub_message->GetReflection()->GetInt64(
+            *sub_message, map_sint64_sint64_key_);
+        int64_t val = sub_message->GetReflection()->GetInt64(
+            *sub_message, map_sint64_sint64_val_);
+        EXPECT_EQ(map[key], val);
+      } else {
+        // Check with Map Reflection
+        map_key.SetInt64Value(i);
+        EXPECT_EQ(true, reflection->ContainsMapKey(
+                            message, F("map_sint64_sint64"), map_key));
+        EXPECT_TRUE(reflection->LookupMapValue(message, F("map_sint64_sint64"),
+                                               map_key, &map_value_const_ref));
+        EXPECT_EQ(map_value_const_ref.GetInt64Value(), map[i]);
+      }
+    }
+  }
+  {
+    std::map<uint32_t, uint32_t> map;
+    map[0] = 0;
+    map[1] = 1;
+    for (int i = 0; i < 2; i++) {
+      const internal::MapFieldBase& map_field =
+          reflection->GetRaw<internal::MapFieldBase>(message,
+                                                     F("map_fixed32_fixed32"));
+      if (map_field.IsRepeatedFieldValid()) {
+        // Check with RepeatedField Reflection
+        sub_message = &reflection->GetRepeatedMessage(
+            message, F("map_fixed32_fixed32"), i);
+        uint32_t key = sub_message->GetReflection()->GetUInt32(
+            *sub_message, map_fixed32_fixed32_key_);
+        uint32_t val = sub_message->GetReflection()->GetUInt32(
+            *sub_message, map_fixed32_fixed32_val_);
+        EXPECT_EQ(map[key], val);
+      } else {
+        // Check with Map Reflection
+        map_key.SetUInt32Value(i);
+        EXPECT_EQ(true, reflection->ContainsMapKey(
+                            message, F("map_fixed32_fixed32"), map_key));
+        EXPECT_TRUE(reflection->LookupMapValue(
+            message, F("map_fixed32_fixed32"), map_key, &map_value_const_ref));
+        EXPECT_EQ(map_value_const_ref.GetUInt32Value(), map[i]);
+      }
+    }
+  }
+  {
+    std::map<uint64_t, uint64_t> map;
+    map[0] = 0;
+    map[1] = 1;
+    for (int i = 0; i < 2; i++) {
+      const internal::MapFieldBase& map_field =
+          reflection->GetRaw<internal::MapFieldBase>(message,
+                                                     F("map_fixed64_fixed64"));
+      if (map_field.IsRepeatedFieldValid()) {
+        // Check with RepeatedField Reflection
+        sub_message = &reflection->GetRepeatedMessage(
+            message, F("map_fixed64_fixed64"), i);
+        uint64_t key = sub_message->GetReflection()->GetUInt64(
+            *sub_message, map_fixed64_fixed64_key_);
+        uint64_t val = sub_message->GetReflection()->GetUInt64(
+            *sub_message, map_fixed64_fixed64_val_);
+        EXPECT_EQ(map[key], val);
+      } else {
+        // Check with Map Reflection
+        map_key.SetUInt64Value(i);
+        EXPECT_EQ(true, reflection->ContainsMapKey(
+                            message, F("map_fixed64_fixed64"), map_key));
+        EXPECT_TRUE(reflection->LookupMapValue(
+            message, F("map_fixed64_fixed64"), map_key, &map_value_const_ref));
+        EXPECT_EQ(map_value_const_ref.GetUInt64Value(), map[i]);
+      }
+    }
+  }
+  {
+    std::map<int32_t, int32_t> map;
+    map[0] = 0;
+    map[1] = 1;
+    for (int i = 0; i < 2; i++) {
+      const internal::MapFieldBase& map_field =
+          reflection->GetRaw<internal::MapFieldBase>(
+              message, F("map_sfixed32_sfixed32"));
+      if (map_field.IsRepeatedFieldValid()) {
+        // Check with RepeatedField Reflection
+        sub_message = &reflection->GetRepeatedMessage(
+            message, F("map_sfixed32_sfixed32"), i);
+        int32_t key = sub_message->GetReflection()->GetInt32(
+            *sub_message, map_sfixed32_sfixed32_key_);
+        int32_t val = sub_message->GetReflection()->GetInt32(
+            *sub_message, map_sfixed32_sfixed32_val_);
+        EXPECT_EQ(map[key], val);
+      } else {
+        // Check with Map Reflection
+        map_key.SetInt32Value(i);
+        EXPECT_EQ(true, reflection->ContainsMapKey(
+                            message, F("map_sfixed32_sfixed32"), map_key));
+        EXPECT_TRUE(reflection->LookupMapValue(message,
+                                               F("map_sfixed32_sfixed32"),
+                                               map_key, &map_value_const_ref));
+        EXPECT_EQ(map_value_const_ref.GetInt32Value(), map[i]);
+      }
+    }
+  }
+  {
+    std::map<int64_t, int64_t> map;
+    map[0] = 0;
+    map[1] = 1;
+    for (int i = 0; i < 2; i++) {
+      const internal::MapFieldBase& map_field =
+          reflection->GetRaw<internal::MapFieldBase>(
+              message, F("map_sfixed64_sfixed64"));
+      if (map_field.IsRepeatedFieldValid()) {
+        // Check with RepeatedField Reflection
+        sub_message = &reflection->GetRepeatedMessage(
+            message, F("map_sfixed64_sfixed64"), i);
+        int64_t key = sub_message->GetReflection()->GetInt64(
+            *sub_message, map_sfixed64_sfixed64_key_);
+        int64_t val = sub_message->GetReflection()->GetInt64(
+            *sub_message, map_sfixed64_sfixed64_val_);
+        EXPECT_EQ(map[key], val);
+      } else {
+        // Check with Map Reflection
+        map_key.SetInt64Value(i);
+        EXPECT_EQ(true, reflection->ContainsMapKey(
+                            message, F("map_sfixed64_sfixed64"), map_key));
+        EXPECT_TRUE(reflection->LookupMapValue(message,
+                                               F("map_sfixed64_sfixed64"),
+                                               map_key, &map_value_const_ref));
+        EXPECT_EQ(map_value_const_ref.GetInt64Value(), map[i]);
+      }
+    }
+  }
+  {
+    std::map<int32_t, float> map;
+    map[0] = 0.0;
+    map[1] = 1.0;
+    for (int i = 0; i < 2; i++) {
+      const internal::MapFieldBase& map_field =
+          reflection->GetRaw<internal::MapFieldBase>(message,
+                                                     F("map_int32_float"));
+      if (map_field.IsRepeatedFieldValid()) {
+        // Check with RepeatedField Reflection
+        sub_message =
+            &reflection->GetRepeatedMessage(message, F("map_int32_float"), i);
+        int32_t key = sub_message->GetReflection()->GetInt32(
+            *sub_message, map_int32_float_key_);
+        float val = sub_message->GetReflection()->GetFloat(
+            *sub_message, map_int32_float_val_);
+        EXPECT_EQ(map[key], val);
+      } else {
+        // Check with Map Reflection
+        map_key.SetInt32Value(i);
+        EXPECT_EQ(true, reflection->ContainsMapKey(
+                            message, F("map_int32_float"), map_key));
+        EXPECT_TRUE(reflection->LookupMapValue(message, F("map_int32_float"),
+                                               map_key, &map_value_const_ref));
+        EXPECT_EQ(map_value_const_ref.GetFloatValue(), map[i]);
+      }
+    }
+  }
+  {
+    std::map<int32_t, double> map;
+    map[0] = 0.0;
+    map[1] = 1.0;
+    for (int i = 0; i < 2; i++) {
+      const internal::MapFieldBase& map_field =
+          reflection->GetRaw<internal::MapFieldBase>(message,
+                                                     F("map_int32_double"));
+      if (map_field.IsRepeatedFieldValid()) {
+        // Check with RepeatedField Reflection
+        sub_message =
+            &reflection->GetRepeatedMessage(message, F("map_int32_double"), i);
+        int32_t key = sub_message->GetReflection()->GetInt32(
+            *sub_message, map_int32_double_key_);
+        double val = sub_message->GetReflection()->GetDouble(
+            *sub_message, map_int32_double_val_);
+        EXPECT_EQ(map[key], val);
+      } else {
+        // Check with Map Reflection
+        map_key.SetInt32Value(i);
+        EXPECT_EQ(true, reflection->ContainsMapKey(
+                            message, F("map_int32_double"), map_key));
+        EXPECT_TRUE(reflection->LookupMapValue(message, F("map_int32_double"),
+                                               map_key, &map_value_const_ref));
+        EXPECT_EQ(map_value_const_ref.GetDoubleValue(), map[i]);
+      }
+    }
+  }
+  {
+    std::map<bool, bool> map;
+    map[false] = false;
+    map[true] = true;
+    std::vector<bool> keys = {false, true};
+    std::vector<bool> vals = {false, true};
+    for (int i = 0; i < 2; i++) {
+      const internal::MapFieldBase& map_field =
+          reflection->GetRaw<internal::MapFieldBase>(message,
+                                                     F("map_bool_bool"));
+      if (map_field.IsRepeatedFieldValid()) {
+        // Check with RepeatedField Reflection
+        sub_message =
+            &reflection->GetRepeatedMessage(message, F("map_bool_bool"), i);
+        bool key = sub_message->GetReflection()->GetBool(*sub_message,
+                                                         map_bool_bool_key_);
+        bool val = sub_message->GetReflection()->GetBool(*sub_message,
+                                                         map_bool_bool_val_);
+        EXPECT_EQ(map[key], val);
+      } else {
+        // Check with Map Reflection
+        map_key.SetBoolValue(keys[i]);
+        EXPECT_EQ(true, reflection->ContainsMapKey(message, F("map_bool_bool"),
+                                                   map_key));
+        EXPECT_TRUE(reflection->LookupMapValue(message, F("map_bool_bool"),
+                                               map_key, &map_value_const_ref));
+        EXPECT_EQ(map_value_const_ref.GetBoolValue(), vals[i]);
+      }
+    }
+  }
+  {
+    std::map<std::string, std::string> map;
+    map["0"] = "0";
+    map["1"] = "1";
+    std::vector<std::string> keys = {"0", "1"};
+    std::vector<std::string> vals = {"0", "1"};
+    for (int i = 0; i < 2; i++) {
+      const internal::MapFieldBase& map_field =
+          reflection->GetRaw<internal::MapFieldBase>(message,
+                                                     F("map_string_string"));
+      if (map_field.IsRepeatedFieldValid()) {
+        // Check with RepeatedField Reflection
+        sub_message =
+            &reflection->GetRepeatedMessage(message, F("map_string_string"), i);
+        std::string key = sub_message->GetReflection()->GetString(
+            *sub_message, map_string_string_key_);
+        std::string val = sub_message->GetReflection()->GetString(
+            *sub_message, map_string_string_val_);
+        EXPECT_EQ(map[key], val);
+      } else {
+        // Check with Map Reflection
+        map_key.SetStringValue(keys[i]);
+        EXPECT_EQ(true, reflection->ContainsMapKey(
+                            message, F("map_string_string"), map_key));
+        EXPECT_TRUE(reflection->LookupMapValue(message, F("map_string_string"),
+                                               map_key, &map_value_const_ref));
+        EXPECT_EQ(map_value_const_ref.GetStringValue(), vals[i]);
+      }
+    }
+  }
+  {
+    std::map<int32_t, std::string> map;
+    map[0] = "0";
+    map[1] = "1";
+    for (int i = 0; i < 2; i++) {
+      const internal::MapFieldBase& map_field =
+          reflection->GetRaw<internal::MapFieldBase>(message,
+                                                     F("map_int32_bytes"));
+      if (map_field.IsRepeatedFieldValid()) {
+        // Check with RepeatedField Reflection
+        sub_message =
+            &reflection->GetRepeatedMessage(message, F("map_int32_bytes"), i);
+        int32_t key = sub_message->GetReflection()->GetInt32(
+            *sub_message, map_int32_bytes_key_);
+        std::string val = sub_message->GetReflection()->GetString(
+            *sub_message, map_int32_bytes_val_);
+        EXPECT_EQ(map[key], val);
+      } else {
+        // Check with Map Reflection
+        map_key.SetInt32Value(i);
+        EXPECT_EQ(true, reflection->ContainsMapKey(
+                            message, F("map_int32_bytes"), map_key));
+        EXPECT_TRUE(reflection->LookupMapValue(message, F("map_int32_bytes"),
+                                               map_key, &map_value_const_ref));
+        EXPECT_EQ(map_value_const_ref.GetStringValue(), map[i]);
+      }
+    }
+  }
+  {
+    std::map<int32_t, const EnumValueDescriptor*> map;
+    map[0] = map_enum_bar_;
+    map[1] = map_enum_baz_;
+    for (int i = 0; i < 2; i++) {
+      const internal::MapFieldBase& map_field =
+          reflection->GetRaw<internal::MapFieldBase>(message,
+                                                     F("map_int32_enum"));
+      if (map_field.IsRepeatedFieldValid()) {
+        // Check with RepeatedField Reflection
+        sub_message =
+            &reflection->GetRepeatedMessage(message, F("map_int32_enum"), i);
+        int32_t key = sub_message->GetReflection()->GetInt32(
+            *sub_message, map_int32_enum_key_);
+        const EnumValueDescriptor* val = sub_message->GetReflection()->GetEnum(
+            *sub_message, map_int32_enum_val_);
+        EXPECT_EQ(map[key], val);
+      } else {
+        // Check with Map Reflection
+        map_key.SetInt32Value(i);
+        EXPECT_EQ(true, reflection->ContainsMapKey(message, F("map_int32_enum"),
+                                                   map_key));
+        EXPECT_TRUE(reflection->LookupMapValue(message, F("map_int32_enum"),
+                                               map_key, &map_value_const_ref));
+        EXPECT_EQ(map_value_const_ref.GetEnumValue(), map[i]->number());
+      }
+    }
+  }
+  {
+    std::map<int32_t, int32_t> map;
+    map[0] = 0;
+    map[1] = 1;
+    for (int i = 0; i < 2; i++) {
+      const internal::MapFieldBase& map_field =
+          reflection->GetRaw<internal::MapFieldBase>(
+              message, F("map_int32_foreign_message"));
+      if (map_field.IsRepeatedFieldValid()) {
+        // Check with RepeatedField Reflection
+        sub_message = &reflection->GetRepeatedMessage(
+            message, F("map_int32_foreign_message"), i);
+        int32_t key = sub_message->GetReflection()->GetInt32(
+            *sub_message, map_int32_foreign_message_key_);
+        const Message& foreign_message =
+            sub_message->GetReflection()->GetMessage(
+                *sub_message, map_int32_foreign_message_val_);
+        int32_t val = foreign_message.GetReflection()->GetInt32(foreign_message,
+                                                                foreign_c_);
+        EXPECT_EQ(map[key], val);
+      } else {
+        // Check with Map Reflection
+        map_key.SetInt32Value(i);
+        EXPECT_EQ(true, reflection->ContainsMapKey(
+                            message, F("map_int32_foreign_message"), map_key));
+        EXPECT_TRUE(reflection->LookupMapValue(message,
+                                               F("map_int32_foreign_message"),
+                                               map_key, &map_value_const_ref));
+        const Message& foreign_message = map_value_const_ref.GetMessageValue();
+        EXPECT_EQ(foreign_message.GetReflection()->GetInt32(foreign_message,
+                                                            foreign_c_),
+                  map[i]);
+      }
+    }
+  }
+}
+
+void MapReflectionTester::ExpectMapFieldsSetViaReflectionIterator(
+    Message* message) {
+  std::string scratch;
+  std::string serialized;
+  const Reflection* reflection = message->GetReflection();
+
+  ASSERT_EQ(2, reflection->FieldSize(*message, F("map_int32_int32")));
+  ASSERT_EQ(2, reflection->FieldSize(*message, F("map_int64_int64")));
+  ASSERT_EQ(2, reflection->FieldSize(*message, F("map_uint32_uint32")));
+  ASSERT_EQ(2, reflection->FieldSize(*message, F("map_uint64_uint64")));
+  ASSERT_EQ(2, reflection->FieldSize(*message, F("map_sint32_sint32")));
+  ASSERT_EQ(2, reflection->FieldSize(*message, F("map_sint64_sint64")));
+  ASSERT_EQ(2, reflection->FieldSize(*message, F("map_fixed32_fixed32")));
+  ASSERT_EQ(2, reflection->FieldSize(*message, F("map_fixed64_fixed64")));
+  ASSERT_EQ(2, reflection->FieldSize(*message, F("map_sfixed32_sfixed32")));
+  ASSERT_EQ(2, reflection->FieldSize(*message, F("map_sfixed64_sfixed64")));
+  ASSERT_EQ(2, reflection->FieldSize(*message, F("map_int32_float")));
+  ASSERT_EQ(2, reflection->FieldSize(*message, F("map_int32_double")));
+  ASSERT_EQ(2, reflection->FieldSize(*message, F("map_bool_bool")));
+  ASSERT_EQ(2, reflection->FieldSize(*message, F("map_string_string")));
+  ASSERT_EQ(2, reflection->FieldSize(*message, F("map_int32_bytes")));
+  ASSERT_EQ(2, reflection->FieldSize(*message, F("map_int32_enum")));
+  ASSERT_EQ(2, reflection->FieldSize(*message, F("map_int32_foreign_message")));
+
+  {
+    std::map<int32_t, int32_t> map;
+    map[0] = 0;
+    map[1] = 1;
+    int size = 0;
+    for (MapIterator iter = reflection->MapBegin(message, F("map_int32_int32"));
+         iter != reflection->MapEnd(message, F("map_int32_int32"));
+         ++iter, ++size) {
+      // Check const methods do not invalidate map.
+      message->DebugString();
+      message->ShortDebugString();
+      message->SerializeToString(&serialized);
+      message->SpaceUsedLong();
+      message->ByteSizeLong();
+      EXPECT_EQ(map[iter.GetKey().GetInt32Value()],
+                iter.GetValueRef().GetInt32Value());
+    }
+    EXPECT_EQ(size, 2);
+  }
+  {
+    std::map<int64_t, int64_t> map;
+    map[0] = 0;
+    map[1] = 1;
+    for (MapIterator iter = reflection->MapBegin(message, F("map_int64_int64"));
+         iter != reflection->MapEnd(message, F("map_int64_int64")); ++iter) {
+      EXPECT_EQ(map[iter.GetKey().GetInt64Value()],
+                iter.GetValueRef().GetInt64Value());
+    }
+  }
+  {
+    std::map<uint32_t, uint32_t> map;
+    map[0] = 0;
+    map[1] = 1;
+    for (MapIterator iter =
+             reflection->MapBegin(message, F("map_uint32_uint32"));
+         iter != reflection->MapEnd(message, F("map_uint32_uint32")); ++iter) {
+      EXPECT_EQ(map[iter.GetKey().GetUInt32Value()],
+                iter.GetValueRef().GetUInt32Value());
+    }
+  }
+  {
+    std::map<uint64_t, uint64_t> map;
+    map[0] = 0;
+    map[1] = 1;
+    for (MapIterator iter =
+             reflection->MapBegin(message, F("map_uint64_uint64"));
+         iter != reflection->MapEnd(message, F("map_uint64_uint64")); ++iter) {
+      EXPECT_EQ(map[iter.GetKey().GetUInt64Value()],
+                iter.GetValueRef().GetUInt64Value());
+    }
+  }
+  {
+    std::map<int32_t, int32_t> map;
+    map[0] = 0;
+    map[1] = 1;
+    for (MapIterator iter =
+             reflection->MapBegin(message, F("map_sint32_sint32"));
+         iter != reflection->MapEnd(message, F("map_sint32_sint32")); ++iter) {
+      EXPECT_EQ(map[iter.GetKey().GetInt32Value()],
+                iter.GetValueRef().GetInt32Value());
+    }
+  }
+  {
+    std::map<int64_t, int64_t> map;
+    map[0] = 0;
+    map[1] = 1;
+    for (MapIterator iter =
+             reflection->MapBegin(message, F("map_sint64_sint64"));
+         iter != reflection->MapEnd(message, F("map_sint64_sint64")); ++iter) {
+      EXPECT_EQ(map[iter.GetKey().GetInt64Value()],
+                iter.GetValueRef().GetInt64Value());
+    }
+  }
+  {
+    std::map<uint32_t, uint32_t> map;
+    map[0] = 0;
+    map[1] = 1;
+    for (MapIterator iter =
+             reflection->MapBegin(message, F("map_fixed32_fixed32"));
+         iter != reflection->MapEnd(message, F("map_fixed32_fixed32"));
+         ++iter) {
+      EXPECT_EQ(map[iter.GetKey().GetUInt32Value()],
+                iter.GetValueRef().GetUInt32Value());
+    }
+  }
+  {
+    std::map<uint64_t, uint64_t> map;
+    map[0] = 0;
+    map[1] = 1;
+    for (MapIterator iter =
+             reflection->MapBegin(message, F("map_fixed64_fixed64"));
+         iter != reflection->MapEnd(message, F("map_fixed64_fixed64"));
+         ++iter) {
+      EXPECT_EQ(map[iter.GetKey().GetUInt64Value()],
+                iter.GetValueRef().GetUInt64Value());
+    }
+  }
+  {
+    std::map<int32_t, int32_t> map;
+    map[0] = 0;
+    map[1] = 1;
+    for (MapIterator iter =
+             reflection->MapBegin(message, F("map_sfixed32_sfixed32"));
+         iter != reflection->MapEnd(message, F("map_sfixed32_sfixed32"));
+         ++iter) {
+      EXPECT_EQ(map[iter.GetKey().GetInt32Value()],
+                iter.GetValueRef().GetInt32Value());
+    }
+  }
+  {
+    std::map<int32_t, float> map;
+    map[0] = 0.0;
+    map[1] = 1.0;
+    for (MapIterator iter = reflection->MapBegin(message, F("map_int32_float"));
+         iter != reflection->MapEnd(message, F("map_int32_float")); ++iter) {
+      EXPECT_EQ(map[iter.GetKey().GetInt32Value()],
+                iter.GetValueRef().GetFloatValue());
+    }
+  }
+  {
+    std::map<int32_t, double> map;
+    map[0] = 0.0;
+    map[1] = 1.0;
+    for (MapIterator iter =
+             reflection->MapBegin(message, F("map_int32_double"));
+         iter != reflection->MapEnd(message, F("map_int32_double")); ++iter) {
+      EXPECT_EQ(map[iter.GetKey().GetInt32Value()],
+                iter.GetValueRef().GetDoubleValue());
+    }
+  }
+  {
+    std::map<bool, bool> map;
+    map[false] = false;
+    map[true] = true;
+    for (MapIterator iter = reflection->MapBegin(message, F("map_bool_bool"));
+         iter != reflection->MapEnd(message, F("map_bool_bool")); ++iter) {
+      EXPECT_EQ(map[iter.GetKey().GetBoolValue()],
+                iter.GetValueRef().GetBoolValue());
+    }
+  }
+  {
+    std::map<std::string, std::string> map;
+    map["0"] = "0";
+    map["1"] = "1";
+    int size = 0;
+    for (MapIterator iter =
+             reflection->MapBegin(message, F("map_string_string"));
+         iter != reflection->MapEnd(message, F("map_string_string"));
+         ++iter, ++size) {
+      // Check const methods do not invalidate map.
+      message->DebugString();
+      message->ShortDebugString();
+      message->SerializeToString(&serialized);
+      message->SpaceUsedLong();
+      message->ByteSizeLong();
+      EXPECT_EQ(map[iter.GetKey().GetStringValue()],
+                iter.GetValueRef().GetStringValue());
+    }
+    EXPECT_EQ(size, 2);
+  }
+  {
+    std::map<int32_t, std::string> map;
+    map[0] = "0";
+    map[1] = "1";
+    for (MapIterator iter = reflection->MapBegin(message, F("map_int32_bytes"));
+         iter != reflection->MapEnd(message, F("map_int32_bytes")); ++iter) {
+      EXPECT_EQ(map[iter.GetKey().GetInt32Value()],
+                iter.GetValueRef().GetStringValue());
+    }
+  }
+  {
+    std::map<int32_t, const EnumValueDescriptor*> map;
+    map[0] = map_enum_bar_;
+    map[1] = map_enum_baz_;
+    for (MapIterator iter = reflection->MapBegin(message, F("map_int32_enum"));
+         iter != reflection->MapEnd(message, F("map_int32_enum")); ++iter) {
+      EXPECT_EQ(map[iter.GetKey().GetInt32Value()]->number(),
+                iter.GetValueRef().GetEnumValue());
+    }
+  }
+  {
+    std::map<int32_t, int32_t> map;
+    map[0] = 0;
+    map[1] = 1;
+    int size = 0;
+    for (MapIterator iter =
+             reflection->MapBegin(message, F("map_int32_foreign_message"));
+         iter != reflection->MapEnd(message, F("map_int32_foreign_message"));
+         ++iter, ++size) {
+      // Check const methods do not invalidate map.
+      message->DebugString();
+      message->ShortDebugString();
+      message->SerializeToString(&serialized);
+      message->SpaceUsedLong();
+      message->ByteSizeLong();
+      const Message& sub_message = iter.GetValueRef().GetMessageValue();
+      EXPECT_EQ(map[iter.GetKey().GetInt32Value()],
+                sub_message.GetReflection()->GetInt32(sub_message, foreign_c_));
+    }
+    EXPECT_EQ(size, 2);
+  }
+}
+
+void MapReflectionTester::ExpectClearViaReflection(const Message& message) {
+  const Reflection* reflection = message.GetReflection();
+  // Map fields are empty.
+  EXPECT_EQ(0, reflection->FieldSize(message, F("map_int32_int32")));
+  EXPECT_EQ(0, reflection->FieldSize(message, F("map_int64_int64")));
+  EXPECT_EQ(0, reflection->FieldSize(message, F("map_uint32_uint32")));
+  EXPECT_EQ(0, reflection->FieldSize(message, F("map_uint64_uint64")));
+  EXPECT_EQ(0, reflection->FieldSize(message, F("map_sint32_sint32")));
+  EXPECT_EQ(0, reflection->FieldSize(message, F("map_sint64_sint64")));
+  EXPECT_EQ(0, reflection->FieldSize(message, F("map_fixed32_fixed32")));
+  EXPECT_EQ(0, reflection->FieldSize(message, F("map_fixed64_fixed64")));
+  EXPECT_EQ(0, reflection->FieldSize(message, F("map_sfixed32_sfixed32")));
+  EXPECT_EQ(0, reflection->FieldSize(message, F("map_sfixed64_sfixed64")));
+  EXPECT_EQ(0, reflection->FieldSize(message, F("map_int32_float")));
+  EXPECT_EQ(0, reflection->FieldSize(message, F("map_int32_double")));
+  EXPECT_EQ(0, reflection->FieldSize(message, F("map_bool_bool")));
+  EXPECT_EQ(0, reflection->FieldSize(message, F("map_string_string")));
+  EXPECT_EQ(0, reflection->FieldSize(message, F("map_int32_bytes")));
+  EXPECT_EQ(0, reflection->FieldSize(message, F("map_int32_enum")));
+  EXPECT_EQ(0, reflection->FieldSize(message, F("map_int32_foreign_message")));
+  EXPECT_TRUE(reflection->GetMapData(message, F("map_int32_foreign_message"))
+                  ->IsMapValid());
+}
+
+void MapReflectionTester::ExpectClearViaReflectionIterator(Message* message) {
+  const Reflection* reflection = message->GetReflection();
+  EXPECT_TRUE(reflection->MapBegin(message, F("map_int32_int32")) ==
+              reflection->MapEnd(message, F("map_int32_int32")));
+  EXPECT_TRUE(reflection->MapBegin(message, F("map_int64_int64")) ==
+              reflection->MapEnd(message, F("map_int64_int64")));
+  EXPECT_TRUE(reflection->MapBegin(message, F("map_uint32_uint32")) ==
+              reflection->MapEnd(message, F("map_uint32_uint32")));
+  EXPECT_TRUE(reflection->MapBegin(message, F("map_uint64_uint64")) ==
+              reflection->MapEnd(message, F("map_uint64_uint64")));
+  EXPECT_TRUE(reflection->MapBegin(message, F("map_sint32_sint32")) ==
+              reflection->MapEnd(message, F("map_sint32_sint32")));
+  EXPECT_TRUE(reflection->MapBegin(message, F("map_sint64_sint64")) ==
+              reflection->MapEnd(message, F("map_sint64_sint64")));
+  EXPECT_TRUE(reflection->MapBegin(message, F("map_fixed32_fixed32")) ==
+              reflection->MapEnd(message, F("map_fixed32_fixed32")));
+  EXPECT_TRUE(reflection->MapBegin(message, F("map_fixed64_fixed64")) ==
+              reflection->MapEnd(message, F("map_fixed64_fixed64")));
+  EXPECT_TRUE(reflection->MapBegin(message, F("map_sfixed32_sfixed32")) ==
+              reflection->MapEnd(message, F("map_sfixed32_sfixed32")));
+  EXPECT_TRUE(reflection->MapBegin(message, F("map_sfixed64_sfixed64")) ==
+              reflection->MapEnd(message, F("map_sfixed64_sfixed64")));
+  EXPECT_TRUE(reflection->MapBegin(message, F("map_int32_float")) ==
+              reflection->MapEnd(message, F("map_int32_float")));
+  EXPECT_TRUE(reflection->MapBegin(message, F("map_int32_double")) ==
+              reflection->MapEnd(message, F("map_int32_double")));
+  EXPECT_TRUE(reflection->MapBegin(message, F("map_bool_bool")) ==
+              reflection->MapEnd(message, F("map_bool_bool")));
+  EXPECT_TRUE(reflection->MapBegin(message, F("map_string_string")) ==
+              reflection->MapEnd(message, F("map_string_string")));
+  EXPECT_TRUE(reflection->MapBegin(message, F("map_int32_bytes")) ==
+              reflection->MapEnd(message, F("map_int32_bytes")));
+  EXPECT_TRUE(reflection->MapBegin(message, F("map_int32_enum")) ==
+              reflection->MapEnd(message, F("map_int32_enum")));
+  EXPECT_TRUE(reflection->MapBegin(message, F("map_int32_foreign_message")) ==
+              reflection->MapEnd(message, F("map_int32_foreign_message")));
+}
+
+}  // namespace protobuf
+}  // namespace google
+
+#include <google/protobuf/port_undef.inc>
diff --git protobuf-3.17.3protobuf-3.17.3-patched/src/google/protobuf/reflection_tester.h protobuf-3.17.3-patchedprotobuf-3.17.3-patched/src/google/protobuf/reflection_tester.h
new file mode 100644
index 0000000..3a2dc81
--- /dev/null
+++ protobuf-3.17.3-patchedprotobuf-3.17.3-patched/src/google/protobuf/reflection_tester.h
@@ -0,0 +1,122 @@
+// Protocol Buffers - Google's data interchange format
+// Copyright 2008 Google Inc.  All rights reserved.
+// https://developers.google.com/protocol-buffers/
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef GOOGLE_PROTOBUF_REFLECTION_TESTER_H__
+#define GOOGLE_PROTOBUF_REFLECTION_TESTER_H__
+
+#include <google/protobuf/message.h>
+
+// Must be included last.
+#include <google/protobuf/port_def.inc>
+
+namespace google {
+namespace protobuf {
+
+// Provides APIs to test protocol buffers reflectively.
+class MapReflectionTester {
+ public:
+  // base_descriptor must be a descriptor for TestMap, which is used for
+  // MapReflectionTester to fetch the FieldDescriptors needed to use the
+  // reflection interface.
+  explicit MapReflectionTester(const Descriptor* base_descriptor);
+
+  void SetMapFieldsViaReflection(Message* message);
+  void SetMapFieldsViaMapReflection(Message* message);
+  void ClearMapFieldsViaReflection(Message* message);
+  void ModifyMapFieldsViaReflection(Message* message);
+  void RemoveLastMapsViaReflection(Message* message);
+  void ReleaseLastMapsViaReflection(Message* message);
+  void SwapMapsViaReflection(Message* message);
+  void MutableUnknownFieldsOfMapFieldsViaReflection(Message* message);
+  void ExpectMapFieldsSetViaReflection(const Message& message);
+  void ExpectMapFieldsSetViaReflectionIterator(Message* message);
+  void ExpectClearViaReflection(const Message& message);
+  void ExpectClearViaReflectionIterator(Message* message);
+  void GetMapValueViaMapReflection(Message* message,
+                                   const std::string& field_name,
+                                   const MapKey& map_key, MapValueRef* map_val);
+  Message* GetMapEntryViaReflection(Message* message,
+                                    const std::string& field_name, int index);
+  MapIterator MapBegin(Message* message, const std::string& field_name);
+  MapIterator MapEnd(Message* message, const std::string& field_name);
+  int MapSize(const Message& message, const std::string& field_name);
+
+ private:
+  const FieldDescriptor* F(const std::string& name);
+
+  const Descriptor* base_descriptor_;
+
+  const EnumValueDescriptor* map_enum_bar_;
+  const EnumValueDescriptor* map_enum_baz_;
+  const EnumValueDescriptor* map_enum_foo_;
+
+  const FieldDescriptor* foreign_c_;
+  const FieldDescriptor* map_int32_int32_key_;
+  const FieldDescriptor* map_int32_int32_val_;
+  const FieldDescriptor* map_int64_int64_key_;
+  const FieldDescriptor* map_int64_int64_val_;
+  const FieldDescriptor* map_uint32_uint32_key_;
+  const FieldDescriptor* map_uint32_uint32_val_;
+  const FieldDescriptor* map_uint64_uint64_key_;
+  const FieldDescriptor* map_uint64_uint64_val_;
+  const FieldDescriptor* map_sint32_sint32_key_;
+  const FieldDescriptor* map_sint32_sint32_val_;
+  const FieldDescriptor* map_sint64_sint64_key_;
+  const FieldDescriptor* map_sint64_sint64_val_;
+  const FieldDescriptor* map_fixed32_fixed32_key_;
+  const FieldDescriptor* map_fixed32_fixed32_val_;
+  const FieldDescriptor* map_fixed64_fixed64_key_;
+  const FieldDescriptor* map_fixed64_fixed64_val_;
+  const FieldDescriptor* map_sfixed32_sfixed32_key_;
+  const FieldDescriptor* map_sfixed32_sfixed32_val_;
+  const FieldDescriptor* map_sfixed64_sfixed64_key_;
+  const FieldDescriptor* map_sfixed64_sfixed64_val_;
+  const FieldDescriptor* map_int32_float_key_;
+  const FieldDescriptor* map_int32_float_val_;
+  const FieldDescriptor* map_int32_double_key_;
+  const FieldDescriptor* map_int32_double_val_;
+  const FieldDescriptor* map_bool_bool_key_;
+  const FieldDescriptor* map_bool_bool_val_;
+  const FieldDescriptor* map_string_string_key_;
+  const FieldDescriptor* map_string_string_val_;
+  const FieldDescriptor* map_int32_bytes_key_;
+  const FieldDescriptor* map_int32_bytes_val_;
+  const FieldDescriptor* map_int32_enum_key_;
+  const FieldDescriptor* map_int32_enum_val_;
+  const FieldDescriptor* map_int32_foreign_message_key_;
+  const FieldDescriptor* map_int32_foreign_message_val_;
+};
+
+}  // namespace protobuf
+}  // namespace google
+
+#include <google/protobuf/port_undef.inc>
+
+#endif  // GOOGLE_PROTOBUF_REFLECTION_TESTER_H__
diff --git protobuf-3.17.3protobuf-3.17.3/src/google/protobuf/wire_format.cc protobuf-3.17.3-patchedprotobuf-3.17.3-patched/src/google/protobuf/wire_format.cc
index c30b7ab..daaa670 100644
--- protobuf-3.17.3protobuf-3.17.3/src/google/protobuf/wire_format.cc
+++ protobuf-3.17.3-patchedprotobuf-3.17.3-patched/src/google/protobuf/wire_format.cc
@@ -41,20 +41,21 @@
 #include <google/protobuf/stubs/logging.h>
 #include <google/protobuf/stubs/common.h>
 #include <google/protobuf/stubs/stringprintf.h>
-#include <google/protobuf/descriptor.pb.h>
-#include <google/protobuf/parse_context.h>
 #include <google/protobuf/io/coded_stream.h>
 #include <google/protobuf/io/zero_copy_stream.h>
 #include <google/protobuf/io/zero_copy_stream_impl.h>
 #include <google/protobuf/descriptor.h>
+#include <google/protobuf/descriptor.pb.h>
 #include <google/protobuf/dynamic_message.h>
 #include <google/protobuf/map_field.h>
 #include <google/protobuf/map_field_inl.h>
 #include <google/protobuf/message.h>
 #include <google/protobuf/message_lite.h>
+#include <google/protobuf/parse_context.h>
 #include <google/protobuf/unknown_field_set.h>
 
 
+// Must be included last.
 #include <google/protobuf/port_def.inc>
 
 const size_t kMapEntryTagByteSize = 2;
@@ -70,7 +71,7 @@ static size_t MapValueRefDataOnlyByteSize(const FieldDescriptor* field,
 // ===================================================================
 
 bool UnknownFieldSetFieldSkipper::SkipField(io::CodedInputStream* input,
-                                            uint32 tag) {
+                                            uint32_t tag) {
   return WireFormat::SkipField(input, tag, unknown_fields_);
 }
 
@@ -82,7 +83,7 @@ void UnknownFieldSetFieldSkipper::SkipUnknownEnum(int field_number, int value) {
   unknown_fields_->AddVarint(field_number, value);
 }
 
-bool WireFormat::SkipField(io::CodedInputStream* input, uint32 tag,
+bool WireFormat::SkipField(io::CodedInputStream* input, uint32_t tag,
                            UnknownFieldSet* unknown_fields) {
   int number = WireFormatLite::GetTagFieldNumber(tag);
   // Field number 0 is illegal.
@@ -90,21 +91,21 @@ bool WireFormat::SkipField(io::CodedInputStream* input, uint32 tag,
 
   switch (WireFormatLite::GetTagWireType(tag)) {
     case WireFormatLite::WIRETYPE_VARINT: {
-      uint64 value;
+      uint64_t value;
       if (!input->ReadVarint64(&value)) return false;
-      if (unknown_fields != NULL) unknown_fields->AddVarint(number, value);
+      if (unknown_fields != nullptr) unknown_fields->AddVarint(number, value);
       return true;
     }
     case WireFormatLite::WIRETYPE_FIXED64: {
-      uint64 value;
+      uint64_t value;
       if (!input->ReadLittleEndian64(&value)) return false;
-      if (unknown_fields != NULL) unknown_fields->AddFixed64(number, value);
+      if (unknown_fields != nullptr) unknown_fields->AddFixed64(number, value);
       return true;
     }
     case WireFormatLite::WIRETYPE_LENGTH_DELIMITED: {
-      uint32 length;
+      uint32_t length;
       if (!input->ReadVarint32(&length)) return false;
-      if (unknown_fields == NULL) {
+      if (unknown_fields == nullptr) {
         if (!input->Skip(length)) return false;
       } else {
         if (!input->ReadString(unknown_fields->AddLengthDelimited(number),
@@ -116,8 +117,8 @@ bool WireFormat::SkipField(io::CodedInputStream* input, uint32 tag,
     }
     case WireFormatLite::WIRETYPE_START_GROUP: {
       if (!input->IncrementRecursionDepth()) return false;
-      if (!SkipMessage(input, (unknown_fields == NULL)
-                                  ? NULL
+      if (!SkipMessage(input, (unknown_fields == nullptr)
+                                  ? nullptr
                                   : unknown_fields->AddGroup(number))) {
         return false;
       }
@@ -134,9 +135,9 @@ bool WireFormat::SkipField(io::CodedInputStream* input, uint32 tag,
       return false;
     }
     case WireFormatLite::WIRETYPE_FIXED32: {
-      uint32 value;
+      uint32_t value;
       if (!input->ReadLittleEndian32(&value)) return false;
-      if (unknown_fields != NULL) unknown_fields->AddFixed32(number, value);
+      if (unknown_fields != nullptr) unknown_fields->AddFixed32(number, value);
       return true;
     }
     default: {
@@ -148,7 +149,7 @@ bool WireFormat::SkipField(io::CodedInputStream* input, uint32 tag,
 bool WireFormat::SkipMessage(io::CodedInputStream* input,
                              UnknownFieldSet* unknown_fields) {
   while (true) {
-    uint32 tag = input->ReadTag();
+    uint32_t tag = input->ReadTag();
     if (tag == 0) {
       // End of input.  This is a valid place to end, so return true.
       return true;
@@ -166,11 +167,11 @@ bool WireFormat::SkipMessage(io::CodedInputStream* input,
 }
 
 bool WireFormat::ReadPackedEnumPreserveUnknowns(io::CodedInputStream* input,
-                                                uint32 field_number,
+                                                uint32_t field_number,
                                                 bool (*is_valid)(int),
                                                 UnknownFieldSet* unknown_fields,
                                                 RepeatedField<int>* values) {
-  uint32 length;
+  uint32_t length;
   if (!input->ReadVarint32(&length)) return false;
   io::CodedInputStream::Limit limit = input->PushLimit(length);
   while (input->BytesUntilLimit() > 0) {
@@ -179,7 +180,7 @@ bool WireFormat::ReadPackedEnumPreserveUnknowns(io::CodedInputStream* input,
             input, &value)) {
       return false;
     }
-    if (is_valid == NULL || is_valid(value)) {
+    if (is_valid == nullptr || is_valid(value)) {
       values->Add(value);
     } else {
       unknown_fields->AddVarint(field_number, value);
@@ -189,8 +190,8 @@ bool WireFormat::ReadPackedEnumPreserveUnknowns(io::CodedInputStream* input,
   return true;
 }
 
-uint8* WireFormat::InternalSerializeUnknownFieldsToArray(
-    const UnknownFieldSet& unknown_fields, uint8* target,
+uint8_t* WireFormat::InternalSerializeUnknownFieldsToArray(
+    const UnknownFieldSet& unknown_fields, uint8_t* target,
     io::EpsCopyOutputStream* stream) {
   for (int i = 0; i < unknown_fields.field_count(); i++) {
     const UnknownField& field = unknown_fields.field(i);
@@ -227,8 +228,8 @@ uint8* WireFormat::InternalSerializeUnknownFieldsToArray(
   return target;
 }
 
-uint8* WireFormat::InternalSerializeUnknownMessageSetItemsToArray(
-    const UnknownFieldSet& unknown_fields, uint8* target,
+uint8_t* WireFormat::InternalSerializeUnknownMessageSetItemsToArray(
+    const UnknownFieldSet& unknown_fields, uint8_t* target,
     io::EpsCopyOutputStream* stream) {
   for (int i = 0; i < unknown_fields.field_count(); i++) {
     const UnknownField& field = unknown_fields.field(i);
@@ -278,12 +279,12 @@ size_t WireFormat::ComputeUnknownFieldsSize(
       case UnknownField::TYPE_FIXED32:
         size += io::CodedOutputStream::VarintSize32(WireFormatLite::MakeTag(
             field.number(), WireFormatLite::WIRETYPE_FIXED32));
-        size += sizeof(int32);
+        size += sizeof(int32_t);
         break;
       case UnknownField::TYPE_FIXED64:
         size += io::CodedOutputStream::VarintSize32(WireFormatLite::MakeTag(
             field.number(), WireFormatLite::WIRETYPE_FIXED64));
-        size += sizeof(int64);
+        size += sizeof(int64_t);
         break;
       case UnknownField::TYPE_LENGTH_DELIMITED:
         size += io::CodedOutputStream::VarintSize32(WireFormatLite::MakeTag(
@@ -334,7 +335,7 @@ bool WireFormat::ParseAndMergePartial(io::CodedInputStream* input,
   const Reflection* message_reflection = message->GetReflection();
 
   while (true) {
-    uint32 tag = input->ReadTag();
+    uint32_t tag = input->ReadTag();
     if (tag == 0) {
       // End of input.  This is a valid place to end, so return true.
       return true;
@@ -346,15 +347,15 @@ bool WireFormat::ParseAndMergePartial(io::CodedInputStream* input,
       return true;
     }
 
-    const FieldDescriptor* field = NULL;
+    const FieldDescriptor* field = nullptr;
 
-    if (descriptor != NULL) {
+    if (descriptor != nullptr) {
       int field_number = WireFormatLite::GetTagFieldNumber(tag);
       field = descriptor->FindFieldByNumber(field_number);
 
       // If that failed, check if the field is an extension.
-      if (field == NULL && descriptor->IsExtensionNumber(field_number)) {
-        if (input->GetExtensionPool() == NULL) {
+      if (field == nullptr && descriptor->IsExtensionNumber(field_number)) {
+        if (input->GetExtensionPool() == nullptr) {
           field = message_reflection->FindKnownExtensionByNumber(field_number);
         } else {
           field = input->GetExtensionPool()->FindExtensionByNumber(
@@ -364,7 +365,7 @@ bool WireFormat::ParseAndMergePartial(io::CodedInputStream* input,
 
       // If that failed, but we're a MessageSet, and this is the tag for a
       // MessageSet item, then parse that.
-      if (field == NULL && descriptor->options().message_set_wire_format() &&
+      if (field == nullptr && descriptor->options().message_set_wire_format() &&
           tag == WireFormatLite::kMessageSetItemStartTag) {
         if (!ParseAndMergeMessageSetItem(input, message)) {
           return false;
@@ -380,20 +381,20 @@ bool WireFormat::ParseAndMergePartial(io::CodedInputStream* input,
 }
 
 bool WireFormat::SkipMessageSetField(io::CodedInputStream* input,
-                                     uint32 field_number,
+                                     uint32_t field_number,
                                      UnknownFieldSet* unknown_fields) {
-  uint32 length;
+  uint32_t length;
   if (!input->ReadVarint32(&length)) return false;
   return input->ReadString(unknown_fields->AddLengthDelimited(field_number),
                            length);
 }
 
-bool WireFormat::ParseAndMergeMessageSetField(uint32 field_number,
+bool WireFormat::ParseAndMergeMessageSetField(uint32_t field_number,
                                               const FieldDescriptor* field,
                                               Message* message,
                                               io::CodedInputStream* input) {
   const Reflection* message_reflection = message->GetReflection();
-  if (field == NULL) {
+  if (field == nullptr) {
     // We store unknown MessageSet extensions as groups.
     return SkipMessageSetField(
         input, field_number, message_reflection->MutableUnknownFields(message));
@@ -415,14 +416,14 @@ static bool StrictUtf8Check(const FieldDescriptor* field) {
 }
 
 bool WireFormat::ParseAndMergeField(
-    uint32 tag,
-    const FieldDescriptor* field,  // May be NULL for unknown
+    uint32_t tag,
+    const FieldDescriptor* field,  // May be nullptr for unknown
     Message* message, io::CodedInputStream* input) {
   const Reflection* message_reflection = message->GetReflection();
 
   enum { UNKNOWN, NORMAL_FORMAT, PACKED_FORMAT } value_format;
 
-  if (field == NULL) {
+  if (field == nullptr) {
     value_format = UNKNOWN;
   } else if (WireFormatLite::GetTagWireType(tag) ==
              WireTypeForFieldType(field->type())) {
@@ -441,7 +442,7 @@ bool WireFormat::ParseAndMergeField(
     return SkipField(input, tag,
                      message_reflection->MutableUnknownFields(message));
   } else if (value_format == PACKED_FORMAT) {
-    uint32 length;
+    uint32_t length;
     if (!input->ReadVarint32(&length)) return false;
     io::CodedInputStream::Limit limit = input->PushLimit(length);
 
@@ -459,17 +460,17 @@ bool WireFormat::ParseAndMergeField(
     break;                                                                     \
   }
 
-      HANDLE_PACKED_TYPE(INT32, int32, Int32)
-      HANDLE_PACKED_TYPE(INT64, int64, Int64)
-      HANDLE_PACKED_TYPE(SINT32, int32, Int32)
-      HANDLE_PACKED_TYPE(SINT64, int64, Int64)
-      HANDLE_PACKED_TYPE(UINT32, uint32, UInt32)
-      HANDLE_PACKED_TYPE(UINT64, uint64, UInt64)
+      HANDLE_PACKED_TYPE(INT32, int32_t, Int32)
+      HANDLE_PACKED_TYPE(INT64, int64_t, Int64)
+      HANDLE_PACKED_TYPE(SINT32, int32_t, Int32)
+      HANDLE_PACKED_TYPE(SINT64, int64_t, Int64)
+      HANDLE_PACKED_TYPE(UINT32, uint32_t, UInt32)
+      HANDLE_PACKED_TYPE(UINT64, uint64_t, UInt64)
 
-      HANDLE_PACKED_TYPE(FIXED32, uint32, UInt32)
-      HANDLE_PACKED_TYPE(FIXED64, uint64, UInt64)
-      HANDLE_PACKED_TYPE(SFIXED32, int32, Int32)
-      HANDLE_PACKED_TYPE(SFIXED64, int64, Int64)
+      HANDLE_PACKED_TYPE(FIXED32, uint32_t, UInt32)
+      HANDLE_PACKED_TYPE(FIXED64, uint64_t, UInt64)
+      HANDLE_PACKED_TYPE(SFIXED32, int32_t, Int32)
+      HANDLE_PACKED_TYPE(SFIXED64, int64_t, Int64)
 
       HANDLE_PACKED_TYPE(FLOAT, float, Float)
       HANDLE_PACKED_TYPE(DOUBLE, double, Double)
@@ -489,12 +490,12 @@ bool WireFormat::ParseAndMergeField(
           } else {
             const EnumValueDescriptor* enum_value =
                 field->enum_type()->FindValueByNumber(value);
-            if (enum_value != NULL) {
+            if (enum_value != nullptr) {
               message_reflection->AddEnum(message, field, enum_value);
             } else {
               // The enum value is not one of the known values.  Add it to the
               // UnknownFieldSet.
-              int64 sign_extended_value = static_cast<int64>(value);
+              int64_t sign_extended_value = static_cast<int64_t>(value);
               message_reflection->MutableUnknownFields(message)->AddVarint(
                   WireFormatLite::GetTagFieldNumber(tag), sign_extended_value);
             }
@@ -532,17 +533,17 @@ bool WireFormat::ParseAndMergeField(
     break;                                                                    \
   }
 
-      HANDLE_TYPE(INT32, int32, Int32)
-      HANDLE_TYPE(INT64, int64, Int64)
-      HANDLE_TYPE(SINT32, int32, Int32)
-      HANDLE_TYPE(SINT64, int64, Int64)
-      HANDLE_TYPE(UINT32, uint32, UInt32)
-      HANDLE_TYPE(UINT64, uint64, UInt64)
+      HANDLE_TYPE(INT32, int32_t, Int32)
+      HANDLE_TYPE(INT64, int64_t, Int64)
+      HANDLE_TYPE(SINT32, int32_t, Int32)
+      HANDLE_TYPE(SINT64, int64_t, Int64)
+      HANDLE_TYPE(UINT32, uint32_t, UInt32)
+      HANDLE_TYPE(UINT64, uint64_t, UInt64)
 
-      HANDLE_TYPE(FIXED32, uint32, UInt32)
-      HANDLE_TYPE(FIXED64, uint64, UInt64)
-      HANDLE_TYPE(SFIXED32, int32, Int32)
-      HANDLE_TYPE(SFIXED64, int64, Int64)
+      HANDLE_TYPE(FIXED32, uint32_t, UInt32)
+      HANDLE_TYPE(FIXED64, uint64_t, UInt64)
+      HANDLE_TYPE(SFIXED32, int32_t, Int32)
+      HANDLE_TYPE(SFIXED64, int64_t, Int64)
 
       HANDLE_TYPE(FLOAT, float, Float)
       HANDLE_TYPE(DOUBLE, double, Double)
@@ -641,8 +642,8 @@ bool WireFormat::ParseAndMergeMessageSetItem(io::CodedInputStream* input,
       return ParseAndMergeMessageSetField(type_id, field, message, input);
     }
 
-    bool SkipField(uint32 tag, io::CodedInputStream* input) {
-      return WireFormat::SkipField(input, tag, NULL);
+    bool SkipField(uint32_t tag, io::CodedInputStream* input) {
+      return WireFormat::SkipField(input, tag, nullptr);
     }
 
     const Reflection* message_reflection;
@@ -657,19 +658,24 @@ struct WireFormat::MessageSetParser {
   const char* _InternalParse(const char* ptr, internal::ParseContext* ctx) {
     // Parse a MessageSetItem
     auto metadata = reflection->MutableInternalMetadata(msg);
+    enum class State { kNoTag, kHasType, kHasPayload, kDone };
+    State state = State::kNoTag;
+
     std::string payload;
-    uint32 type_id = 0;
-    bool payload_read = false;
+    uint32_t type_id = 0;
     while (!ctx->Done(&ptr)) {
       // We use 64 bit tags in order to allow typeid's that span the whole
       // range of 32 bit numbers.
-      uint32 tag = static_cast<uint8>(*ptr++);
+      uint32_t tag = static_cast<uint8_t>(*ptr++);
       if (tag == WireFormatLite::kMessageSetTypeIdTag) {
-        uint64 tmp;
+        uint64_t tmp;
         ptr = ParseBigVarint(ptr, &tmp);
         GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
-        type_id = tmp;
-        if (payload_read) {
+        if (state == State::kNoTag) {
+          type_id = tmp;
+          state = State::kHasType;
+        } else if (state == State::kHasPayload) {
+          type_id = tmp;
           const FieldDescriptor* field;
           if (ctx->data().pool == nullptr) {
             field = reflection->FindKnownExtensionByNumber(type_id);
@@ -696,17 +702,17 @@ struct WireFormat::MessageSetParser {
             GOOGLE_PROTOBUF_PARSER_ASSERT(value->_InternalParse(p, &tmp_ctx) &&
                                            tmp_ctx.EndedAtLimit());
           }
-          type_id = 0;
+          state = State::kDone;
         }
         continue;
       } else if (tag == WireFormatLite::kMessageSetMessageTag) {
-        if (type_id == 0) {
-          int32 size = ReadSize(&ptr);
+        if (state == State::kNoTag) {
+          int32_t size = ReadSize(&ptr);
           GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
           ptr = ctx->ReadString(ptr, size, &payload);
           GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
-          payload_read = true;
-        } else {
+          state = State::kHasPayload;
+        } else if (state == State::kHasType) {
           // We're now parsing the payload
           const FieldDescriptor* field = nullptr;
           if (descriptor->IsExtensionNumber(type_id)) {
@@ -718,9 +724,14 @@ struct WireFormat::MessageSetParser {
             }
           }
           ptr = WireFormat::_InternalParseAndMergeField(
-              msg, ptr, ctx, static_cast<uint64>(type_id) * 8 + 2, reflection,
+              msg, ptr, ctx, static_cast<uint64_t>(type_id) * 8 + 2, reflection,
               field);
-          type_id = 0;
+          state = State::kDone;
+        } else {
+          int32_t size = ReadSize(&ptr);
+          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
+          ptr = ctx->Skip(ptr, size);
+          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
         }
       } else {
         // An unknown field in MessageSetItem.
@@ -740,7 +751,7 @@ struct WireFormat::MessageSetParser {
 
   const char* ParseMessageSet(const char* ptr, internal::ParseContext* ctx) {
     while (!ctx->Done(&ptr)) {
-      uint32 tag;
+      uint32_t tag;
       ptr = ReadTag(ptr, &tag);
       if (PROTOBUF_PREDICT_FALSE(ptr == nullptr)) return nullptr;
       if (tag == 0 || (tag & 7) == WireFormatLite::WIRETYPE_END_GROUP) {
@@ -786,7 +797,7 @@ const char* WireFormat::_InternalParse(Message* msg, const char* ptr,
     return message_set.ParseMessageSet(ptr, ctx);
   }
   while (!ctx->Done(&ptr)) {
-    uint32 tag;
+    uint32_t tag;
     ptr = ReadTag(ptr, &tag);
     if (PROTOBUF_PREDICT_FALSE(ptr == nullptr)) return nullptr;
     if (tag == 0 || (tag & 7) == WireFormatLite::WIRETYPE_END_GROUP) {
@@ -815,7 +826,7 @@ const char* WireFormat::_InternalParse(Message* msg, const char* ptr,
 }
 
 const char* WireFormat::_InternalParseAndMergeField(
-    Message* msg, const char* ptr, internal::ParseContext* ctx, uint64 tag,
+    Message* msg, const char* ptr, internal::ParseContext* ctx, uint64_t tag,
     const Reflection* reflection, const FieldDescriptor* field) {
   if (field == nullptr) {
     // unknown field set parser takes 64bit tags, because message set type ids
@@ -836,17 +847,17 @@ const char* WireFormat::_InternalParseAndMergeField(
     return ptr;                                                             \
   }
 
-        HANDLE_PACKED_TYPE(INT32, int32, Int32)
-        HANDLE_PACKED_TYPE(INT64, int64, Int64)
-        HANDLE_PACKED_TYPE(SINT32, int32, SInt32)
-        HANDLE_PACKED_TYPE(SINT64, int64, SInt64)
-        HANDLE_PACKED_TYPE(UINT32, uint32, UInt32)
-        HANDLE_PACKED_TYPE(UINT64, uint64, UInt64)
+        HANDLE_PACKED_TYPE(INT32, int32_t, Int32)
+        HANDLE_PACKED_TYPE(INT64, int64_t, Int64)
+        HANDLE_PACKED_TYPE(SINT32, int32_t, SInt32)
+        HANDLE_PACKED_TYPE(SINT64, int64_t, SInt64)
+        HANDLE_PACKED_TYPE(UINT32, uint32_t, UInt32)
+        HANDLE_PACKED_TYPE(UINT64, uint64_t, UInt64)
 
-        HANDLE_PACKED_TYPE(FIXED32, uint32, Fixed32)
-        HANDLE_PACKED_TYPE(FIXED64, uint64, Fixed64)
-        HANDLE_PACKED_TYPE(SFIXED32, int32, SFixed32)
-        HANDLE_PACKED_TYPE(SFIXED64, int64, SFixed64)
+        HANDLE_PACKED_TYPE(FIXED32, uint32_t, Fixed32)
+        HANDLE_PACKED_TYPE(FIXED64, uint64_t, Fixed64)
+        HANDLE_PACKED_TYPE(SFIXED32, int32_t, SFixed32)
+        HANDLE_PACKED_TYPE(SFIXED64, int64_t, SFixed64)
 
         HANDLE_PACKED_TYPE(FLOAT, float, Float)
         HANDLE_PACKED_TYPE(DOUBLE, double, Double)
@@ -863,7 +874,7 @@ const char* WireFormat::_InternalParseAndMergeField(
             ptr = internal::PackedEnumParser(rep_enum, ptr, ctx);
           } else {
             return ctx->ReadPackedVarint(
-                ptr, [rep_enum, field, reflection, msg](uint64 val) {
+                ptr, [rep_enum, field, reflection, msg](uint64_t val) {
                   if (field->enum_type()->FindValueByNumber(val) != nullptr) {
                     rep_enum->Add(val);
                   } else {
@@ -906,14 +917,14 @@ const char* WireFormat::_InternalParseAndMergeField(
     return ptr;                                           \
   }
 
-    HANDLE_TYPE(BOOL, uint64, Bool)
-    HANDLE_TYPE(INT32, uint32, Int32)
-    HANDLE_TYPE(INT64, uint64, Int64)
-    HANDLE_TYPE(UINT32, uint32, UInt32)
-    HANDLE_TYPE(UINT64, uint64, UInt64)
+    HANDLE_TYPE(BOOL, uint64_t, Bool)
+    HANDLE_TYPE(INT32, uint32_t, Int32)
+    HANDLE_TYPE(INT64, uint64_t, Int64)
+    HANDLE_TYPE(UINT32, uint32_t, UInt32)
+    HANDLE_TYPE(UINT64, uint64_t, UInt64)
 
     case FieldDescriptor::TYPE_SINT32: {
-      int32 value = ReadVarintZigZag32(&ptr);
+      int32_t value = ReadVarintZigZag32(&ptr);
       if (ptr == nullptr) return nullptr;
       if (field->is_repeated()) {
         reflection->AddInt32(msg, field, value);
@@ -923,7 +934,7 @@ const char* WireFormat::_InternalParseAndMergeField(
       return ptr;
     }
     case FieldDescriptor::TYPE_SINT64: {
-      int64 value = ReadVarintZigZag64(&ptr);
+      int64_t value = ReadVarintZigZag64(&ptr);
       if (ptr == nullptr) return nullptr;
       if (field->is_repeated()) {
         reflection->AddInt64(msg, field, value);
@@ -946,10 +957,10 @@ const char* WireFormat::_InternalParseAndMergeField(
     return ptr;                                           \
   }
 
-      HANDLE_TYPE(FIXED32, uint32, UInt32)
-      HANDLE_TYPE(FIXED64, uint64, UInt64)
-      HANDLE_TYPE(SFIXED32, int32, Int32)
-      HANDLE_TYPE(SFIXED64, int64, Int64)
+      HANDLE_TYPE(FIXED32, uint32_t, UInt32)
+      HANDLE_TYPE(FIXED64, uint64_t, UInt64)
+      HANDLE_TYPE(SFIXED32, int32_t, Int32)
+      HANDLE_TYPE(SFIXED64, int64_t, Int64)
 
       HANDLE_TYPE(FLOAT, float, Float)
       HANDLE_TYPE(DOUBLE, double, Double)
@@ -957,7 +968,7 @@ const char* WireFormat::_InternalParseAndMergeField(
 #undef HANDLE_TYPE
 
     case FieldDescriptor::TYPE_ENUM: {
-      uint32 value;
+      uint32_t value;
       ptr = VarintParse(ptr, &value);
       if (ptr == nullptr) return nullptr;
       if (field->is_repeated()) {
@@ -992,9 +1003,9 @@ const char* WireFormat::_InternalParseAndMergeField(
         }
       }
       if (field->is_repeated()) {
-        reflection->AddString(msg, field, value);
+        reflection->AddString(msg, field, std::move(value));
       } else {
-        reflection->SetString(msg, field, value);
+        reflection->SetString(msg, field, std::move(value));
       }
       return ptr;
     }
@@ -1030,8 +1041,8 @@ const char* WireFormat::_InternalParseAndMergeField(
 
 // ===================================================================
 
-uint8* WireFormat::_InternalSerialize(const Message& message, uint8* target,
-                                      io::EpsCopyOutputStream* stream) {
+uint8_t* WireFormat::_InternalSerialize(const Message& message, uint8_t* target,
+                                        io::EpsCopyOutputStream* stream) {
   const Descriptor* descriptor = message.GetDescriptor();
   const Reflection* message_reflection = message.GetReflection();
 
@@ -1059,9 +1070,9 @@ uint8* WireFormat::_InternalSerialize(const Message& message, uint8* target,
   }
 }
 
-uint8* SerializeMapKeyWithCachedSizes(const FieldDescriptor* field,
-                                      const MapKey& value, uint8* target,
-                                      io::EpsCopyOutputStream* stream) {
+uint8_t* SerializeMapKeyWithCachedSizes(const FieldDescriptor* field,
+                                        const MapKey& value, uint8_t* target,
+                                        io::EpsCopyOutputStream* stream) {
   target = stream->EnsureSpace(target);
   switch (field->type()) {
     case FieldDescriptor::TYPE_DOUBLE:
@@ -1096,9 +1107,9 @@ uint8* SerializeMapKeyWithCachedSizes(const FieldDescriptor* field,
   return target;
 }
 
-static uint8* SerializeMapValueRefWithCachedSizes(
-    const FieldDescriptor* field, const MapValueConstRef& value, uint8* target,
-    io::EpsCopyOutputStream* stream) {
+static uint8_t* SerializeMapValueRefWithCachedSizes(
+    const FieldDescriptor* field, const MapValueConstRef& value,
+    uint8_t* target, io::EpsCopyOutputStream* stream) {
   target = stream->EnsureSpace(target);
   switch (field->type()) {
 #define CASE_TYPE(FieldType, CamelFieldType, CamelCppType)   \
@@ -1180,11 +1191,11 @@ class MapKeySorter {
   };
 };
 
-static uint8* InternalSerializeMapEntry(const FieldDescriptor* field,
-                                        const MapKey& key,
-                                        const MapValueConstRef& value,
-                                        uint8* target,
-                                        io::EpsCopyOutputStream* stream) {
+static uint8_t* InternalSerializeMapEntry(const FieldDescriptor* field,
+                                          const MapKey& key,
+                                          const MapValueConstRef& value,
+                                          uint8_t* target,
+                                          io::EpsCopyOutputStream* stream) {
   const FieldDescriptor* key_field = field->message_type()->field(0);
   const FieldDescriptor* value_field = field->message_type()->field(1);
 
@@ -1201,9 +1212,10 @@ static uint8* InternalSerializeMapEntry(const FieldDescriptor* field,
   return target;
 }
 
-uint8* WireFormat::InternalSerializeField(const FieldDescriptor* field,
-                                          const Message& message, uint8* target,
-                                          io::EpsCopyOutputStream* stream) {
+uint8_t* WireFormat::InternalSerializeField(const FieldDescriptor* field,
+                                            const Message& message,
+                                            uint8_t* target,
+                                            io::EpsCopyOutputStream* stream) {
   const Reflection* message_reflection = message.GetReflection();
 
   if (field->is_extension() &&
@@ -1286,12 +1298,12 @@ uint8* WireFormat::InternalSerializeField(const FieldDescriptor* field,
     break;                                                                     \
   }
 
-      HANDLE_PRIMITIVE_TYPE(INT32, int32, Int32, Int32)
-      HANDLE_PRIMITIVE_TYPE(INT64, int64, Int64, Int64)
-      HANDLE_PRIMITIVE_TYPE(SINT32, int32, SInt32, Int32)
-      HANDLE_PRIMITIVE_TYPE(SINT64, int64, SInt64, Int64)
-      HANDLE_PRIMITIVE_TYPE(UINT32, uint32, UInt32, UInt32)
-      HANDLE_PRIMITIVE_TYPE(UINT64, uint64, UInt64, UInt64)
+      HANDLE_PRIMITIVE_TYPE(INT32, int32_t, Int32, Int32)
+      HANDLE_PRIMITIVE_TYPE(INT64, int64_t, Int64, Int64)
+      HANDLE_PRIMITIVE_TYPE(SINT32, int32_t, SInt32, Int32)
+      HANDLE_PRIMITIVE_TYPE(SINT64, int64_t, SInt64, Int64)
+      HANDLE_PRIMITIVE_TYPE(UINT32, uint32_t, UInt32, UInt32)
+      HANDLE_PRIMITIVE_TYPE(UINT64, uint64_t, UInt64, UInt64)
       HANDLE_PRIMITIVE_TYPE(ENUM, int, Enum, Enum)
 
 #undef HANDLE_PRIMITIVE_TYPE
@@ -1303,10 +1315,10 @@ uint8* WireFormat::InternalSerializeField(const FieldDescriptor* field,
     break;                                                                     \
   }
 
-      HANDLE_PRIMITIVE_TYPE(FIXED32, uint32, Fixed32, UInt32)
-      HANDLE_PRIMITIVE_TYPE(FIXED64, uint64, Fixed64, UInt64)
-      HANDLE_PRIMITIVE_TYPE(SFIXED32, int32, SFixed32, Int32)
-      HANDLE_PRIMITIVE_TYPE(SFIXED64, int64, SFixed64, Int64)
+      HANDLE_PRIMITIVE_TYPE(FIXED32, uint32_t, Fixed32, UInt32)
+      HANDLE_PRIMITIVE_TYPE(FIXED64, uint64_t, Fixed64, UInt64)
+      HANDLE_PRIMITIVE_TYPE(SFIXED32, int32_t, SFixed32, Int32)
+      HANDLE_PRIMITIVE_TYPE(SFIXED64, int64_t, SFixed64, Int64)
 
       HANDLE_PRIMITIVE_TYPE(FLOAT, float, Float, Float)
       HANDLE_PRIMITIVE_TYPE(DOUBLE, double, Double, Double)
@@ -1319,6 +1331,16 @@ uint8* WireFormat::InternalSerializeField(const FieldDescriptor* field,
     return target;
   }
 
+  auto get_message_from_field = [&message, &map_entries, message_reflection](
+                                    const FieldDescriptor* field, int j) {
+    if (!field->is_repeated()) {
+      return &message_reflection->GetMessage(message, field);
+    }
+    if (!map_entries.empty()) {
+      return map_entries[j];
+    }
+    return &message_reflection->GetRepeatedMessage(message, field, j);
+  };
   for (int j = 0; j < count; j++) {
     target = stream->EnsureSpace(target);
     switch (field->type()) {
@@ -1334,17 +1356,17 @@ uint8* WireFormat::InternalSerializeField(const FieldDescriptor* field,
     break;                                                                    \
   }
 
-      HANDLE_PRIMITIVE_TYPE(INT32, int32, Int32, Int32)
-      HANDLE_PRIMITIVE_TYPE(INT64, int64, Int64, Int64)
-      HANDLE_PRIMITIVE_TYPE(SINT32, int32, SInt32, Int32)
-      HANDLE_PRIMITIVE_TYPE(SINT64, int64, SInt64, Int64)
-      HANDLE_PRIMITIVE_TYPE(UINT32, uint32, UInt32, UInt32)
-      HANDLE_PRIMITIVE_TYPE(UINT64, uint64, UInt64, UInt64)
+      HANDLE_PRIMITIVE_TYPE(INT32, int32_t, Int32, Int32)
+      HANDLE_PRIMITIVE_TYPE(INT64, int64_t, Int64, Int64)
+      HANDLE_PRIMITIVE_TYPE(SINT32, int32_t, SInt32, Int32)
+      HANDLE_PRIMITIVE_TYPE(SINT64, int64_t, SInt64, Int64)
+      HANDLE_PRIMITIVE_TYPE(UINT32, uint32_t, UInt32, UInt32)
+      HANDLE_PRIMITIVE_TYPE(UINT64, uint64_t, UInt64, UInt64)
 
-      HANDLE_PRIMITIVE_TYPE(FIXED32, uint32, Fixed32, UInt32)
-      HANDLE_PRIMITIVE_TYPE(FIXED64, uint64, Fixed64, UInt64)
-      HANDLE_PRIMITIVE_TYPE(SFIXED32, int32, SFixed32, Int32)
-      HANDLE_PRIMITIVE_TYPE(SFIXED64, int64, SFixed64, Int64)
+      HANDLE_PRIMITIVE_TYPE(FIXED32, uint32_t, Fixed32, UInt32)
+      HANDLE_PRIMITIVE_TYPE(FIXED64, uint64_t, Fixed64, UInt64)
+      HANDLE_PRIMITIVE_TYPE(SFIXED32, int32_t, SFixed32, Int32)
+      HANDLE_PRIMITIVE_TYPE(SFIXED64, int64_t, SFixed64, Int64)
 
       HANDLE_PRIMITIVE_TYPE(FLOAT, float, Float, Float)
       HANDLE_PRIMITIVE_TYPE(DOUBLE, double, Double, Double)
@@ -1418,8 +1440,8 @@ uint8* WireFormat::InternalSerializeField(const FieldDescriptor* field,
   return target;
 }
 
-uint8* WireFormat::InternalSerializeMessageSetItem(
-    const FieldDescriptor* field, const Message& message, uint8* target,
+uint8_t* WireFormat::InternalSerializeMessageSetItem(
+    const FieldDescriptor* field, const Message& message, uint8_t* target,
     io::EpsCopyOutputStream* stream) {
   const Reflection* message_reflection = message.GetReflection();
 
diff --git protobuf-3.17.3protobuf-3.17.3/src/google/protobuf/wire_format_lite.h protobuf-3.17.3-patchedprotobuf-3.17.3-patched/src/google/protobuf/wire_format_lite.h
index c1abaf1..e35c891 100644
--- protobuf-3.17.3protobuf-3.17.3/src/google/protobuf/wire_format_lite.h
+++ protobuf-3.17.3-patchedprotobuf-3.17.3-patched/src/google/protobuf/wire_format_lite.h
@@ -40,16 +40,17 @@
 #ifndef GOOGLE_PROTOBUF_WIRE_FORMAT_LITE_H__
 #define GOOGLE_PROTOBUF_WIRE_FORMAT_LITE_H__
 
+
 #include <string>
 
 #include <google/protobuf/stubs/common.h>
 #include <google/protobuf/stubs/logging.h>
 #include <google/protobuf/io/coded_stream.h>
+#include <google/protobuf/port.h>
+#include <google/protobuf/stubs/casts.h>
 #include <google/protobuf/arenastring.h>
 #include <google/protobuf/message_lite.h>
-#include <google/protobuf/port.h>
 #include <google/protobuf/repeated_field.h>
-#include <google/protobuf/stubs/casts.h>
 
 // Do UTF-8 validation on string type in Debug build only
 #ifndef NDEBUG
@@ -66,6 +67,8 @@
 // #pragma pop_macro("TYPE_BOOL")
 #undef TYPE_BOOL
 
+
+// Must be included last.
 #include <google/protobuf/port_def.inc>
 
 namespace google {
@@ -157,16 +160,16 @@ class PROTOBUF_EXPORT WireFormatLite {
   // Number of bits in a tag which identify the wire type.
   static constexpr int kTagTypeBits = 3;
   // Mask for those bits.
-  static constexpr uint32 kTagTypeMask = (1 << kTagTypeBits) - 1;
+  static constexpr uint32_t kTagTypeMask = (1 << kTagTypeBits) - 1;
 
   // Helper functions for encoding and decoding tags.  (Inlined below and in
   // _inl.h)
   //
   // This is different from MakeTag(field->number(), field->type()) in the
   // case of packed repeated fields.
-  constexpr static uint32 MakeTag(int field_number, WireType type);
-  static WireType GetTagWireType(uint32 tag);
-  static int GetTagFieldNumber(uint32 tag);
+  constexpr static uint32_t MakeTag(int field_number, WireType type);
+  static WireType GetTagWireType(uint32_t tag);
+  static int GetTagFieldNumber(uint32_t tag);
 
   // Compute the byte size of a tag.  For groups, this includes both the start
   // and end tags.
@@ -177,12 +180,12 @@ class PROTOBUF_EXPORT WireFormatLite {
   // positioned immediately after the tag.  Skipped values are simply
   // discarded, not recorded anywhere.  See WireFormat::SkipField() for a
   // version that records to an UnknownFieldSet.
-  static bool SkipField(io::CodedInputStream* input, uint32 tag);
+  static bool SkipField(io::CodedInputStream* input, uint32_t tag);
 
   // Skips a field value with the given tag.  The input should start
   // positioned immediately after the tag. Skipped values are recorded to a
   // CodedOutputStream.
-  static bool SkipField(io::CodedInputStream* input, uint32 tag,
+  static bool SkipField(io::CodedInputStream* input, uint32_t tag,
                         io::CodedOutputStream* output);
 
   // Reads and ignores a message from the input.  Skipped values are simply
@@ -200,7 +203,7 @@ class PROTOBUF_EXPORT WireFormatLite {
   // as a switch case or a template input.  WireFormatLite::MakeTag() is more
   // type-safe, though, so prefer it if possible.
 #define GOOGLE_PROTOBUF_WIRE_FORMAT_MAKE_TAG(FIELD_NUMBER, TYPE) \
-  static_cast<uint32>((static_cast<uint32>(FIELD_NUMBER) << 3) | (TYPE))
+  static_cast<uint32_t>((static_cast<uint32_t>(FIELD_NUMBER) << 3) | (TYPE))
 
   // These are the tags for the old MessageSet format, which was defined as:
   //   message MessageSet {
@@ -227,10 +230,10 @@ class PROTOBUF_EXPORT WireFormatLite {
   // Helper functions for converting between floats/doubles and IEEE-754
   // uint32s/uint64s so that they can be written.  (Assumes your platform
   // uses IEEE-754 floats.)
-  static uint32 EncodeFloat(float value);
-  static float DecodeFloat(uint32 value);
-  static uint64 EncodeDouble(double value);
-  static double DecodeDouble(uint64 value);
+  static uint32_t EncodeFloat(float value);
+  static float DecodeFloat(uint32_t value);
+  static uint64_t EncodeDouble(double value);
+  static double DecodeDouble(uint64_t value);
 
   // Helper functions for mapping signed integers to unsigned integers in
   // such a way that numbers with small magnitudes will encode to smaller
@@ -238,10 +241,10 @@ class PROTOBUF_EXPORT WireFormatLite {
   // number and varint-encode it, it will always take 10 bytes, defeating
   // the purpose of varint.  So, for the "sint32" and "sint64" field types,
   // we ZigZag-encode the values.
-  static uint32 ZigZagEncode32(int32 n);
-  static int32 ZigZagDecode32(uint32 n);
-  static uint64 ZigZagEncode64(int64 n);
-  static int64 ZigZagDecode64(uint64 n);
+  static uint32_t ZigZagEncode32(int32_t n);
+  static int32_t ZigZagDecode32(uint32_t n);
+  static uint64_t ZigZagEncode64(int64_t n);
+  static int64_t ZigZagDecode64(uint64_t n);
 
   // =================================================================
   // Methods for reading/writing individual field.
@@ -261,13 +264,13 @@ class PROTOBUF_EXPORT WireFormatLite {
   // protocol compiler.
   template <typename CType, enum FieldType DeclaredType>
   PROTOBUF_NDEBUG_INLINE static bool ReadRepeatedPrimitive(
-      int tag_size, uint32 tag, io::CodedInputStream* input,
+      int tag_size, uint32_t tag, io::CodedInputStream* input,
       RepeatedField<CType>* value);
 
   // Identical to ReadRepeatedPrimitive, except will not inline the
   // implementation.
   template <typename CType, enum FieldType DeclaredType>
-  static bool ReadRepeatedPrimitiveNoInline(int tag_size, uint32 tag,
+  static bool ReadRepeatedPrimitiveNoInline(int tag_size, uint32_t tag,
                                             io::CodedInputStream* input,
                                             RepeatedField<CType>* value);
 
@@ -277,8 +280,8 @@ class PROTOBUF_EXPORT WireFormatLite {
   // This is only implemented for the types with fixed wire size, e.g.
   // float, double, and the (s)fixed* types.
   template <typename CType, enum FieldType DeclaredType>
-  PROTOBUF_NDEBUG_INLINE static const uint8* ReadPrimitiveFromArray(
-      const uint8* buffer, CType* value);
+  PROTOBUF_NDEBUG_INLINE static const uint8_t* ReadPrimitiveFromArray(
+      const uint8_t* buffer, CType* value);
 
   // Reads a primitive packed field.
   //
@@ -293,14 +296,15 @@ class PROTOBUF_EXPORT WireFormatLite {
   static bool ReadPackedPrimitiveNoInline(io::CodedInputStream* input,
                                           RepeatedField<CType>* value);
 
-  // Read a packed enum field. If the is_valid function is not NULL, values for
-  // which is_valid(value) returns false are silently dropped.
+  // Read a packed enum field. If the is_valid function is not nullptr, values
+  // for which is_valid(value) returns false are silently dropped.
   static bool ReadPackedEnumNoInline(io::CodedInputStream* input,
                                      bool (*is_valid)(int),
                                      RepeatedField<int>* values);
 
-  // Read a packed enum field. If the is_valid function is not NULL, values for
-  // which is_valid(value) returns false are appended to unknown_fields_stream.
+  // Read a packed enum field. If the is_valid function is not nullptr, values
+  // for which is_valid(value) returns false are appended to
+  // unknown_fields_stream.
   static bool ReadPackedEnumPreserveUnknowns(
       io::CodedInputStream* input, int field_number, bool (*is_valid)(int),
       io::CodedOutputStream* unknown_fields_stream, RepeatedField<int>* values);
@@ -350,25 +354,25 @@ class PROTOBUF_EXPORT WireFormatLite {
 
   // Write fields, without tags.
   PROTOBUF_NDEBUG_INLINE static void WriteInt32NoTag(
-      int32 value, io::CodedOutputStream* output);
+      int32_t value, io::CodedOutputStream* output);
   PROTOBUF_NDEBUG_INLINE static void WriteInt64NoTag(
-      int64 value, io::CodedOutputStream* output);
+      int64_t value, io::CodedOutputStream* output);
   PROTOBUF_NDEBUG_INLINE static void WriteUInt32NoTag(
-      uint32 value, io::CodedOutputStream* output);
+      uint32_t value, io::CodedOutputStream* output);
   PROTOBUF_NDEBUG_INLINE static void WriteUInt64NoTag(
-      uint64 value, io::CodedOutputStream* output);
+      uint64_t value, io::CodedOutputStream* output);
   PROTOBUF_NDEBUG_INLINE static void WriteSInt32NoTag(
-      int32 value, io::CodedOutputStream* output);
+      int32_t value, io::CodedOutputStream* output);
   PROTOBUF_NDEBUG_INLINE static void WriteSInt64NoTag(
-      int64 value, io::CodedOutputStream* output);
+      int64_t value, io::CodedOutputStream* output);
   PROTOBUF_NDEBUG_INLINE static void WriteFixed32NoTag(
-      uint32 value, io::CodedOutputStream* output);
+      uint32_t value, io::CodedOutputStream* output);
   PROTOBUF_NDEBUG_INLINE static void WriteFixed64NoTag(
-      uint64 value, io::CodedOutputStream* output);
+      uint64_t value, io::CodedOutputStream* output);
   PROTOBUF_NDEBUG_INLINE static void WriteSFixed32NoTag(
-      int32 value, io::CodedOutputStream* output);
+      int32_t value, io::CodedOutputStream* output);
   PROTOBUF_NDEBUG_INLINE static void WriteSFixed64NoTag(
-      int64 value, io::CodedOutputStream* output);
+      int64_t value, io::CodedOutputStream* output);
   PROTOBUF_NDEBUG_INLINE static void WriteFloatNoTag(
       float value, io::CodedOutputStream* output);
   PROTOBUF_NDEBUG_INLINE static void WriteDoubleNoTag(
@@ -383,37 +387,37 @@ class PROTOBUF_EXPORT WireFormatLite {
                               io::CodedOutputStream* output);
   static void WriteDoubleArray(const double* a, int n,
                                io::CodedOutputStream* output);
-  static void WriteFixed32Array(const uint32* a, int n,
+  static void WriteFixed32Array(const uint32_t* a, int n,
                                 io::CodedOutputStream* output);
-  static void WriteFixed64Array(const uint64* a, int n,
+  static void WriteFixed64Array(const uint64_t* a, int n,
                                 io::CodedOutputStream* output);
-  static void WriteSFixed32Array(const int32* a, int n,
+  static void WriteSFixed32Array(const int32_t* a, int n,
                                  io::CodedOutputStream* output);
-  static void WriteSFixed64Array(const int64* a, int n,
+  static void WriteSFixed64Array(const int64_t* a, int n,
                                  io::CodedOutputStream* output);
   static void WriteBoolArray(const bool* a, int n,
                              io::CodedOutputStream* output);
 
   // Write fields, including tags.
-  static void WriteInt32(int field_number, int32 value,
+  static void WriteInt32(int field_number, int32_t value,
                          io::CodedOutputStream* output);
-  static void WriteInt64(int field_number, int64 value,
+  static void WriteInt64(int field_number, int64_t value,
                          io::CodedOutputStream* output);
-  static void WriteUInt32(int field_number, uint32 value,
+  static void WriteUInt32(int field_number, uint32_t value,
                           io::CodedOutputStream* output);
-  static void WriteUInt64(int field_number, uint64 value,
+  static void WriteUInt64(int field_number, uint64_t value,
                           io::CodedOutputStream* output);
-  static void WriteSInt32(int field_number, int32 value,
+  static void WriteSInt32(int field_number, int32_t value,
                           io::CodedOutputStream* output);
-  static void WriteSInt64(int field_number, int64 value,
+  static void WriteSInt64(int field_number, int64_t value,
                           io::CodedOutputStream* output);
-  static void WriteFixed32(int field_number, uint32 value,
+  static void WriteFixed32(int field_number, uint32_t value,
                            io::CodedOutputStream* output);
-  static void WriteFixed64(int field_number, uint64 value,
+  static void WriteFixed64(int field_number, uint64_t value,
                            io::CodedOutputStream* output);
-  static void WriteSFixed32(int field_number, int32 value,
+  static void WriteSFixed32(int field_number, int32_t value,
                             io::CodedOutputStream* output);
-  static void WriteSFixed64(int field_number, int64 value,
+  static void WriteSFixed64(int field_number, int64_t value,
                             io::CodedOutputStream* output);
   static void WriteFloat(int field_number, float value,
                          io::CodedOutputStream* output);
@@ -459,161 +463,161 @@ class PROTOBUF_EXPORT WireFormatLite {
                                            io::CodedOutputStream* output);
 
   // Like above, but use only *ToArray methods of CodedOutputStream.
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteTagToArray(int field_number,
-                                                       WireType type,
-                                                       uint8* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteTagToArray(int field_number,
+                                                         WireType type,
+                                                         uint8_t* target);
 
   // Write fields, without tags.
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteInt32NoTagToArray(int32 value,
-                                                              uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteInt64NoTagToArray(int64 value,
-                                                              uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteUInt32NoTagToArray(uint32 value,
-                                                               uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteUInt64NoTagToArray(uint64 value,
-                                                               uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSInt32NoTagToArray(int32 value,
-                                                               uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSInt64NoTagToArray(int64 value,
-                                                               uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteFixed32NoTagToArray(uint32 value,
-                                                                uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteFixed64NoTagToArray(uint64 value,
-                                                                uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSFixed32NoTagToArray(int32 value,
-                                                                 uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSFixed64NoTagToArray(int64 value,
-                                                                 uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteFloatNoTagToArray(float value,
-                                                              uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteDoubleNoTagToArray(double value,
-                                                               uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteBoolNoTagToArray(bool value,
-                                                             uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteEnumNoTagToArray(int value,
-                                                             uint8* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteInt32NoTagToArray(
+      int32_t value, uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteInt64NoTagToArray(
+      int64_t value, uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteUInt32NoTagToArray(
+      uint32_t value, uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteUInt64NoTagToArray(
+      uint64_t value, uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSInt32NoTagToArray(
+      int32_t value, uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSInt64NoTagToArray(
+      int64_t value, uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteFixed32NoTagToArray(
+      uint32_t value, uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteFixed64NoTagToArray(
+      uint64_t value, uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSFixed32NoTagToArray(
+      int32_t value, uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSFixed64NoTagToArray(
+      int64_t value, uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteFloatNoTagToArray(
+      float value, uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteDoubleNoTagToArray(
+      double value, uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteBoolNoTagToArray(bool value,
+                                                               uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteEnumNoTagToArray(int value,
+                                                               uint8_t* target);
 
   // Write fields, without tags.  These require that value.size() > 0.
   template <typename T>
-  PROTOBUF_NDEBUG_INLINE static uint8* WritePrimitiveNoTagToArray(
-      const RepeatedField<T>& value, uint8* (*Writer)(T, uint8*),
-      uint8* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WritePrimitiveNoTagToArray(
+      const RepeatedField<T>& value, uint8_t* (*Writer)(T, uint8_t*),
+      uint8_t* target);
   template <typename T>
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteFixedNoTagToArray(
-      const RepeatedField<T>& value, uint8* (*Writer)(T, uint8*),
-      uint8* target);
-
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteInt32NoTagToArray(
-      const RepeatedField<int32>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteInt64NoTagToArray(
-      const RepeatedField<int64>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteUInt32NoTagToArray(
-      const RepeatedField<uint32>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteUInt64NoTagToArray(
-      const RepeatedField<uint64>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSInt32NoTagToArray(
-      const RepeatedField<int32>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSInt64NoTagToArray(
-      const RepeatedField<int64>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteFixed32NoTagToArray(
-      const RepeatedField<uint32>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteFixed64NoTagToArray(
-      const RepeatedField<uint64>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSFixed32NoTagToArray(
-      const RepeatedField<int32>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSFixed64NoTagToArray(
-      const RepeatedField<int64>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteFloatNoTagToArray(
-      const RepeatedField<float>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteDoubleNoTagToArray(
-      const RepeatedField<double>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteBoolNoTagToArray(
-      const RepeatedField<bool>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteEnumNoTagToArray(
-      const RepeatedField<int>& value, uint8* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteFixedNoTagToArray(
+      const RepeatedField<T>& value, uint8_t* (*Writer)(T, uint8_t*),
+      uint8_t* target);
+
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteInt32NoTagToArray(
+      const RepeatedField<int32_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteInt64NoTagToArray(
+      const RepeatedField<int64_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteUInt32NoTagToArray(
+      const RepeatedField<uint32_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteUInt64NoTagToArray(
+      const RepeatedField<uint64_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSInt32NoTagToArray(
+      const RepeatedField<int32_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSInt64NoTagToArray(
+      const RepeatedField<int64_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteFixed32NoTagToArray(
+      const RepeatedField<uint32_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteFixed64NoTagToArray(
+      const RepeatedField<uint64_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSFixed32NoTagToArray(
+      const RepeatedField<int32_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSFixed64NoTagToArray(
+      const RepeatedField<int64_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteFloatNoTagToArray(
+      const RepeatedField<float>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteDoubleNoTagToArray(
+      const RepeatedField<double>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteBoolNoTagToArray(
+      const RepeatedField<bool>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteEnumNoTagToArray(
+      const RepeatedField<int>& value, uint8_t* output);
 
   // Write fields, including tags.
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteInt32ToArray(int field_number,
-                                                         int32 value,
-                                                         uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteInt64ToArray(int field_number,
-                                                         int64 value,
-                                                         uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteUInt32ToArray(int field_number,
-                                                          uint32 value,
-                                                          uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteUInt64ToArray(int field_number,
-                                                          uint64 value,
-                                                          uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSInt32ToArray(int field_number,
-                                                          int32 value,
-                                                          uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSInt64ToArray(int field_number,
-                                                          int64 value,
-                                                          uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteFixed32ToArray(int field_number,
-                                                           uint32 value,
-                                                           uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteFixed64ToArray(int field_number,
-                                                           uint64 value,
-                                                           uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSFixed32ToArray(int field_number,
-                                                            int32 value,
-                                                            uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSFixed64ToArray(int field_number,
-                                                            int64 value,
-                                                            uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteFloatToArray(int field_number,
-                                                         float value,
-                                                         uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteDoubleToArray(int field_number,
-                                                          double value,
-                                                          uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteBoolToArray(int field_number,
-                                                        bool value,
-                                                        uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteEnumToArray(int field_number,
-                                                        int value,
-                                                        uint8* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteInt32ToArray(int field_number,
+                                                           int32_t value,
+                                                           uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteInt64ToArray(int field_number,
+                                                           int64_t value,
+                                                           uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteUInt32ToArray(int field_number,
+                                                            uint32_t value,
+                                                            uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteUInt64ToArray(int field_number,
+                                                            uint64_t value,
+                                                            uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSInt32ToArray(int field_number,
+                                                            int32_t value,
+                                                            uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSInt64ToArray(int field_number,
+                                                            int64_t value,
+                                                            uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteFixed32ToArray(int field_number,
+                                                             uint32_t value,
+                                                             uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteFixed64ToArray(int field_number,
+                                                             uint64_t value,
+                                                             uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSFixed32ToArray(int field_number,
+                                                              int32_t value,
+                                                              uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSFixed64ToArray(int field_number,
+                                                              int64_t value,
+                                                              uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteFloatToArray(int field_number,
+                                                           float value,
+                                                           uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteDoubleToArray(int field_number,
+                                                            double value,
+                                                            uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteBoolToArray(int field_number,
+                                                          bool value,
+                                                          uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteEnumToArray(int field_number,
+                                                          int value,
+                                                          uint8_t* target);
 
   template <typename T>
-  PROTOBUF_NDEBUG_INLINE static uint8* WritePrimitiveToArray(
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WritePrimitiveToArray(
       int field_number, const RepeatedField<T>& value,
-      uint8* (*Writer)(int, T, uint8*), uint8* target);
-
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteInt32ToArray(
-      int field_number, const RepeatedField<int32>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteInt64ToArray(
-      int field_number, const RepeatedField<int64>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteUInt32ToArray(
-      int field_number, const RepeatedField<uint32>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteUInt64ToArray(
-      int field_number, const RepeatedField<uint64>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSInt32ToArray(
-      int field_number, const RepeatedField<int32>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSInt64ToArray(
-      int field_number, const RepeatedField<int64>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteFixed32ToArray(
-      int field_number, const RepeatedField<uint32>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteFixed64ToArray(
-      int field_number, const RepeatedField<uint64>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSFixed32ToArray(
-      int field_number, const RepeatedField<int32>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSFixed64ToArray(
-      int field_number, const RepeatedField<int64>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteFloatToArray(
-      int field_number, const RepeatedField<float>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteDoubleToArray(
-      int field_number, const RepeatedField<double>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteBoolToArray(
-      int field_number, const RepeatedField<bool>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteEnumToArray(
-      int field_number, const RepeatedField<int>& value, uint8* output);
-
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteStringToArray(
-      int field_number, const std::string& value, uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteBytesToArray(
-      int field_number, const std::string& value, uint8* target);
+      uint8_t* (*Writer)(int, T, uint8_t*), uint8_t* target);
+
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteInt32ToArray(
+      int field_number, const RepeatedField<int32_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteInt64ToArray(
+      int field_number, const RepeatedField<int64_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteUInt32ToArray(
+      int field_number, const RepeatedField<uint32_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteUInt64ToArray(
+      int field_number, const RepeatedField<uint64_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSInt32ToArray(
+      int field_number, const RepeatedField<int32_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSInt64ToArray(
+      int field_number, const RepeatedField<int64_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteFixed32ToArray(
+      int field_number, const RepeatedField<uint32_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteFixed64ToArray(
+      int field_number, const RepeatedField<uint64_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSFixed32ToArray(
+      int field_number, const RepeatedField<int32_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSFixed64ToArray(
+      int field_number, const RepeatedField<int64_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteFloatToArray(
+      int field_number, const RepeatedField<float>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteDoubleToArray(
+      int field_number, const RepeatedField<double>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteBoolToArray(
+      int field_number, const RepeatedField<bool>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteEnumToArray(
+      int field_number, const RepeatedField<int>& value, uint8_t* output);
+
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteStringToArray(
+      int field_number, const std::string& value, uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteBytesToArray(
+      int field_number, const std::string& value, uint8_t* target);
 
   // Whether to serialize deterministically (e.g., map keys are
   // sorted) is a property of a CodedOutputStream, and in the process
@@ -633,31 +637,31 @@ class PROTOBUF_EXPORT WireFormatLite {
   // pointer must point at an instance of MessageType, *not* a subclass (or
   // the subclass must not override SerializeWithCachedSizes()).
   template <typename MessageType>
-  PROTOBUF_NDEBUG_INLINE static uint8* InternalWriteGroupNoVirtualToArray(
-      int field_number, const MessageType& value, uint8* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* InternalWriteGroupNoVirtualToArray(
+      int field_number, const MessageType& value, uint8_t* target);
   template <typename MessageType>
-  PROTOBUF_NDEBUG_INLINE static uint8* InternalWriteMessageNoVirtualToArray(
-      int field_number, const MessageType& value, uint8* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* InternalWriteMessageNoVirtualToArray(
+      int field_number, const MessageType& value, uint8_t* target);
 
   // For backward-compatibility, the last four methods also have versions
   // that are non-deterministic always.
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteGroupToArray(
-      int field_number, const MessageLite& value, uint8* target) {
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteGroupToArray(
+      int field_number, const MessageLite& value, uint8_t* target) {
     io::EpsCopyOutputStream stream(
         target,
         value.GetCachedSize() +
             static_cast<int>(2 * io::CodedOutputStream::VarintSize32(
-                                     static_cast<uint32>(field_number) << 3)),
+                                     static_cast<uint32_t>(field_number) << 3)),
         io::CodedOutputStream::IsDefaultSerializationDeterministic());
     return InternalWriteGroup(field_number, value, target, &stream);
   }
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteMessageToArray(
-      int field_number, const MessageLite& value, uint8* target) {
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteMessageToArray(
+      int field_number, const MessageLite& value, uint8_t* target) {
     int size = value.GetCachedSize();
     io::EpsCopyOutputStream stream(
         target,
         size + static_cast<int>(io::CodedOutputStream::VarintSize32(
-                                    static_cast<uint32>(field_number) << 3) +
+                                    static_cast<uint32_t>(field_number) << 3) +
                                 io::CodedOutputStream::VarintSize32(size)),
         io::CodedOutputStream::IsDefaultSerializationDeterministic());
     return InternalWriteMessage(field_number, value, target, &stream);
@@ -667,20 +671,27 @@ class PROTOBUF_EXPORT WireFormatLite {
   // the tag, so you must also call TagSize().  (This is because, for repeated
   // fields, you should only call TagSize() once and multiply it by the element
   // count, but you may have to call XxSize() for each individual element.)
-  static inline size_t Int32Size(int32 value);
-  static inline size_t Int64Size(int64 value);
-  static inline size_t UInt32Size(uint32 value);
-  static inline size_t UInt64Size(uint64 value);
-  static inline size_t SInt32Size(int32 value);
-  static inline size_t SInt64Size(int64 value);
+  static inline size_t Int32Size(int32_t value);
+  static inline size_t Int64Size(int64_t value);
+  static inline size_t UInt32Size(uint32_t value);
+  static inline size_t UInt64Size(uint64_t value);
+  static inline size_t SInt32Size(int32_t value);
+  static inline size_t SInt64Size(int64_t value);
   static inline size_t EnumSize(int value);
-
-  static size_t Int32Size(const RepeatedField<int32>& value);
-  static size_t Int64Size(const RepeatedField<int64>& value);
-  static size_t UInt32Size(const RepeatedField<uint32>& value);
-  static size_t UInt64Size(const RepeatedField<uint64>& value);
-  static size_t SInt32Size(const RepeatedField<int32>& value);
-  static size_t SInt64Size(const RepeatedField<int64>& value);
+  static inline size_t Int32SizePlusOne(int32_t value);
+  static inline size_t Int64SizePlusOne(int64_t value);
+  static inline size_t UInt32SizePlusOne(uint32_t value);
+  static inline size_t UInt64SizePlusOne(uint64_t value);
+  static inline size_t SInt32SizePlusOne(int32_t value);
+  static inline size_t SInt64SizePlusOne(int64_t value);
+  static inline size_t EnumSizePlusOne(int value);
+
+  static size_t Int32Size(const RepeatedField<int32_t>& value);
+  static size_t Int64Size(const RepeatedField<int64_t>& value);
+  static size_t UInt32Size(const RepeatedField<uint32_t>& value);
+  static size_t UInt64Size(const RepeatedField<uint64_t>& value);
+  static size_t SInt32Size(const RepeatedField<int32_t>& value);
+  static size_t SInt64Size(const RepeatedField<int64_t>& value);
   static size_t EnumSize(const RepeatedField<int>& value);
 
   // These types always have the same size.
@@ -718,7 +729,7 @@ class PROTOBUF_EXPORT WireFormatLite {
   // can be read using potentially faster paths.
   template <typename CType, enum FieldType DeclaredType>
   PROTOBUF_NDEBUG_INLINE static bool ReadRepeatedFixedSizePrimitive(
-      int tag_size, uint32 tag, io::CodedInputStream* input,
+      int tag_size, uint32_t tag, io::CodedInputStream* input,
       RepeatedField<CType>* value);
 
   // Like ReadRepeatedFixedSizePrimitive but for packed primitive fields.
@@ -744,7 +755,7 @@ class PROTOBUF_EXPORT FieldSkipper {
   virtual ~FieldSkipper() {}
 
   // Skip a field whose tag has already been consumed.
-  virtual bool SkipField(io::CodedInputStream* input, uint32 tag);
+  virtual bool SkipField(io::CodedInputStream* input, uint32_t tag);
 
   // Skip an entire message or group, up to an end-group tag (which is consumed)
   // or end-of-stream.
@@ -765,7 +776,7 @@ class PROTOBUF_EXPORT CodedOutputStreamFieldSkipper : public FieldSkipper {
   ~CodedOutputStreamFieldSkipper() override {}
 
   // implements FieldSkipper -----------------------------------------
-  bool SkipField(io::CodedInputStream* input, uint32 tag) override;
+  bool SkipField(io::CodedInputStream* input, uint32_t tag) override;
   bool SkipMessage(io::CodedInputStream* input) override;
   void SkipUnknownEnum(int field_number, int value) override;
 
@@ -780,23 +791,23 @@ inline WireFormatLite::CppType WireFormatLite::FieldTypeToCppType(
   return kFieldTypeToCppTypeMap[type];
 }
 
-constexpr inline uint32 WireFormatLite::MakeTag(int field_number,
-                                                WireType type) {
+constexpr inline uint32_t WireFormatLite::MakeTag(int field_number,
+                                                  WireType type) {
   return GOOGLE_PROTOBUF_WIRE_FORMAT_MAKE_TAG(field_number, type);
 }
 
-inline WireFormatLite::WireType WireFormatLite::GetTagWireType(uint32 tag) {
+inline WireFormatLite::WireType WireFormatLite::GetTagWireType(uint32_t tag) {
   return static_cast<WireType>(tag & kTagTypeMask);
 }
 
-inline int WireFormatLite::GetTagFieldNumber(uint32 tag) {
+inline int WireFormatLite::GetTagFieldNumber(uint32_t tag) {
   return static_cast<int>(tag >> kTagTypeBits);
 }
 
 inline size_t WireFormatLite::TagSize(int field_number,
                                       WireFormatLite::FieldType type) {
   size_t result = io::CodedOutputStream::VarintSize32(
-      static_cast<uint32>(field_number << kTagTypeBits));
+      static_cast<uint32_t>(field_number << kTagTypeBits));
   if (type == TYPE_GROUP) {
     // Groups have both a start and an end tag.
     return result * 2;
@@ -805,19 +816,19 @@ inline size_t WireFormatLite::TagSize(int field_number,
   }
 }
 
-inline uint32 WireFormatLite::EncodeFloat(float value) {
-  return bit_cast<uint32>(value);
+inline uint32_t WireFormatLite::EncodeFloat(float value) {
+  return bit_cast<uint32_t>(value);
 }
 
-inline float WireFormatLite::DecodeFloat(uint32 value) {
+inline float WireFormatLite::DecodeFloat(uint32_t value) {
   return bit_cast<float>(value);
 }
 
-inline uint64 WireFormatLite::EncodeDouble(double value) {
-  return bit_cast<uint64>(value);
+inline uint64_t WireFormatLite::EncodeDouble(double value) {
+  return bit_cast<uint64_t>(value);
 }
 
-inline double WireFormatLite::DecodeDouble(uint64 value) {
+inline double WireFormatLite::DecodeDouble(uint64_t value) {
   return bit_cast<double>(value);
 }
 
@@ -832,7 +843,7 @@ inline double WireFormatLite::DecodeDouble(uint64 value) {
 // in such a way that those with a small absolute value will have smaller
 // encoded values, making them appropriate for encoding using varint.
 //
-//       int32 ->     uint32
+//       int32_t ->     uint32_t
 // -------------------------
 //           0 ->          0
 //          -1 ->          1
@@ -845,26 +856,26 @@ inline double WireFormatLite::DecodeDouble(uint64 value) {
 //        >> encode >>
 //        << decode <<
 
-inline uint32 WireFormatLite::ZigZagEncode32(int32 n) {
+inline uint32_t WireFormatLite::ZigZagEncode32(int32_t n) {
   // Note:  the right-shift must be arithmetic
   // Note:  left shift must be unsigned because of overflow
-  return (static_cast<uint32>(n) << 1) ^ static_cast<uint32>(n >> 31);
+  return (static_cast<uint32_t>(n) << 1) ^ static_cast<uint32_t>(n >> 31);
 }
 
-inline int32 WireFormatLite::ZigZagDecode32(uint32 n) {
+inline int32_t WireFormatLite::ZigZagDecode32(uint32_t n) {
   // Note:  Using unsigned types prevent undefined behavior
-  return static_cast<int32>((n >> 1) ^ (~(n & 1) + 1));
+  return static_cast<int32_t>((n >> 1) ^ (~(n & 1) + 1));
 }
 
-inline uint64 WireFormatLite::ZigZagEncode64(int64 n) {
+inline uint64_t WireFormatLite::ZigZagEncode64(int64_t n) {
   // Note:  the right-shift must be arithmetic
   // Note:  left shift must be unsigned because of overflow
-  return (static_cast<uint64>(n) << 1) ^ static_cast<uint64>(n >> 63);
+  return (static_cast<uint64_t>(n) << 1) ^ static_cast<uint64_t>(n >> 63);
 }
 
-inline int64 WireFormatLite::ZigZagDecode64(uint64 n) {
+inline int64_t WireFormatLite::ZigZagDecode64(uint64_t n) {
   // Note:  Using unsigned types prevent undefined behavior
-  return static_cast<int64>((n >> 1) ^ (~(n & 1) + 1));
+  return static_cast<int64_t>((n >> 1) ^ (~(n & 1) + 1));
 }
 
 // String is for UTF-8 text only, but, even so, ReadString() can simply
@@ -880,8 +891,8 @@ inline bool WireFormatLite::ReadString(io::CodedInputStream* input,
   return ReadBytes(input, p);
 }
 
-inline uint8* InternalSerializeUnknownMessageSetItemsToArray(
-    const std::string& unknown_fields, uint8* target,
+inline uint8_t* InternalSerializeUnknownMessageSetItemsToArray(
+    const std::string& unknown_fields, uint8_t* target,
     io::EpsCopyOutputStream* stream) {
   return stream->WriteRaw(unknown_fields.data(),
                           static_cast<int>(unknown_fields.size()), target);
@@ -895,77 +906,83 @@ inline size_t ComputeUnknownMessageSetItemsSize(
 // Implementation details of ReadPrimitive.
 
 template <>
-inline bool WireFormatLite::ReadPrimitive<int32, WireFormatLite::TYPE_INT32>(
-    io::CodedInputStream* input, int32* value) {
-  uint32 temp;
+inline bool WireFormatLite::ReadPrimitive<int32_t, WireFormatLite::TYPE_INT32>(
+    io::CodedInputStream* input, int32_t* value) {
+  uint32_t temp;
   if (!input->ReadVarint32(&temp)) return false;
-  *value = static_cast<int32>(temp);
+  *value = static_cast<int32_t>(temp);
   return true;
 }
 template <>
-inline bool WireFormatLite::ReadPrimitive<int64, WireFormatLite::TYPE_INT64>(
-    io::CodedInputStream* input, int64* value) {
-  uint64 temp;
+inline bool WireFormatLite::ReadPrimitive<int64_t, WireFormatLite::TYPE_INT64>(
+    io::CodedInputStream* input, int64_t* value) {
+  uint64_t temp;
   if (!input->ReadVarint64(&temp)) return false;
-  *value = static_cast<int64>(temp);
+  *value = static_cast<int64_t>(temp);
   return true;
 }
 template <>
-inline bool WireFormatLite::ReadPrimitive<uint32, WireFormatLite::TYPE_UINT32>(
-    io::CodedInputStream* input, uint32* value) {
+inline bool
+WireFormatLite::ReadPrimitive<uint32_t, WireFormatLite::TYPE_UINT32>(
+    io::CodedInputStream* input, uint32_t* value) {
   return input->ReadVarint32(value);
 }
 template <>
-inline bool WireFormatLite::ReadPrimitive<uint64, WireFormatLite::TYPE_UINT64>(
-    io::CodedInputStream* input, uint64* value) {
+inline bool
+WireFormatLite::ReadPrimitive<uint64_t, WireFormatLite::TYPE_UINT64>(
+    io::CodedInputStream* input, uint64_t* value) {
   return input->ReadVarint64(value);
 }
 template <>
-inline bool WireFormatLite::ReadPrimitive<int32, WireFormatLite::TYPE_SINT32>(
-    io::CodedInputStream* input, int32* value) {
-  uint32 temp;
+inline bool WireFormatLite::ReadPrimitive<int32_t, WireFormatLite::TYPE_SINT32>(
+    io::CodedInputStream* input, int32_t* value) {
+  uint32_t temp;
   if (!input->ReadVarint32(&temp)) return false;
   *value = ZigZagDecode32(temp);
   return true;
 }
 template <>
-inline bool WireFormatLite::ReadPrimitive<int64, WireFormatLite::TYPE_SINT64>(
-    io::CodedInputStream* input, int64* value) {
-  uint64 temp;
+inline bool WireFormatLite::ReadPrimitive<int64_t, WireFormatLite::TYPE_SINT64>(
+    io::CodedInputStream* input, int64_t* value) {
+  uint64_t temp;
   if (!input->ReadVarint64(&temp)) return false;
   *value = ZigZagDecode64(temp);
   return true;
 }
 template <>
-inline bool WireFormatLite::ReadPrimitive<uint32, WireFormatLite::TYPE_FIXED32>(
-    io::CodedInputStream* input, uint32* value) {
+inline bool
+WireFormatLite::ReadPrimitive<uint32_t, WireFormatLite::TYPE_FIXED32>(
+    io::CodedInputStream* input, uint32_t* value) {
   return input->ReadLittleEndian32(value);
 }
 template <>
-inline bool WireFormatLite::ReadPrimitive<uint64, WireFormatLite::TYPE_FIXED64>(
-    io::CodedInputStream* input, uint64* value) {
+inline bool
+WireFormatLite::ReadPrimitive<uint64_t, WireFormatLite::TYPE_FIXED64>(
+    io::CodedInputStream* input, uint64_t* value) {
   return input->ReadLittleEndian64(value);
 }
 template <>
-inline bool WireFormatLite::ReadPrimitive<int32, WireFormatLite::TYPE_SFIXED32>(
-    io::CodedInputStream* input, int32* value) {
-  uint32 temp;
+inline bool
+WireFormatLite::ReadPrimitive<int32_t, WireFormatLite::TYPE_SFIXED32>(
+    io::CodedInputStream* input, int32_t* value) {
+  uint32_t temp;
   if (!input->ReadLittleEndian32(&temp)) return false;
-  *value = static_cast<int32>(temp);
+  *value = static_cast<int32_t>(temp);
   return true;
 }
 template <>
-inline bool WireFormatLite::ReadPrimitive<int64, WireFormatLite::TYPE_SFIXED64>(
-    io::CodedInputStream* input, int64* value) {
-  uint64 temp;
+inline bool
+WireFormatLite::ReadPrimitive<int64_t, WireFormatLite::TYPE_SFIXED64>(
+    io::CodedInputStream* input, int64_t* value) {
+  uint64_t temp;
   if (!input->ReadLittleEndian64(&temp)) return false;
-  *value = static_cast<int64>(temp);
+  *value = static_cast<int64_t>(temp);
   return true;
 }
 template <>
 inline bool WireFormatLite::ReadPrimitive<float, WireFormatLite::TYPE_FLOAT>(
     io::CodedInputStream* input, float* value) {
-  uint32 temp;
+  uint32_t temp;
   if (!input->ReadLittleEndian32(&temp)) return false;
   *value = DecodeFloat(temp);
   return true;
@@ -973,7 +990,7 @@ inline bool WireFormatLite::ReadPrimitive<float, WireFormatLite::TYPE_FLOAT>(
 template <>
 inline bool WireFormatLite::ReadPrimitive<double, WireFormatLite::TYPE_DOUBLE>(
     io::CodedInputStream* input, double* value) {
-  uint64 temp;
+  uint64_t temp;
   if (!input->ReadLittleEndian64(&temp)) return false;
   *value = DecodeDouble(temp);
   return true;
@@ -981,7 +998,7 @@ inline bool WireFormatLite::ReadPrimitive<double, WireFormatLite::TYPE_DOUBLE>(
 template <>
 inline bool WireFormatLite::ReadPrimitive<bool, WireFormatLite::TYPE_BOOL>(
     io::CodedInputStream* input, bool* value) {
-  uint64 temp;
+  uint64_t temp;
   if (!input->ReadVarint64(&temp)) return false;
   *value = temp != 0;
   return true;
@@ -989,56 +1006,56 @@ inline bool WireFormatLite::ReadPrimitive<bool, WireFormatLite::TYPE_BOOL>(
 template <>
 inline bool WireFormatLite::ReadPrimitive<int, WireFormatLite::TYPE_ENUM>(
     io::CodedInputStream* input, int* value) {
-  uint32 temp;
+  uint32_t temp;
   if (!input->ReadVarint32(&temp)) return false;
   *value = static_cast<int>(temp);
   return true;
 }
 
 template <>
-inline const uint8*
-WireFormatLite::ReadPrimitiveFromArray<uint32, WireFormatLite::TYPE_FIXED32>(
-    const uint8* buffer, uint32* value) {
+inline const uint8_t*
+WireFormatLite::ReadPrimitiveFromArray<uint32_t, WireFormatLite::TYPE_FIXED32>(
+    const uint8_t* buffer, uint32_t* value) {
   return io::CodedInputStream::ReadLittleEndian32FromArray(buffer, value);
 }
 template <>
-inline const uint8*
-WireFormatLite::ReadPrimitiveFromArray<uint64, WireFormatLite::TYPE_FIXED64>(
-    const uint8* buffer, uint64* value) {
+inline const uint8_t*
+WireFormatLite::ReadPrimitiveFromArray<uint64_t, WireFormatLite::TYPE_FIXED64>(
+    const uint8_t* buffer, uint64_t* value) {
   return io::CodedInputStream::ReadLittleEndian64FromArray(buffer, value);
 }
 template <>
-inline const uint8*
-WireFormatLite::ReadPrimitiveFromArray<int32, WireFormatLite::TYPE_SFIXED32>(
-    const uint8* buffer, int32* value) {
-  uint32 temp;
+inline const uint8_t*
+WireFormatLite::ReadPrimitiveFromArray<int32_t, WireFormatLite::TYPE_SFIXED32>(
+    const uint8_t* buffer, int32_t* value) {
+  uint32_t temp;
   buffer = io::CodedInputStream::ReadLittleEndian32FromArray(buffer, &temp);
-  *value = static_cast<int32>(temp);
+  *value = static_cast<int32_t>(temp);
   return buffer;
 }
 template <>
-inline const uint8*
-WireFormatLite::ReadPrimitiveFromArray<int64, WireFormatLite::TYPE_SFIXED64>(
-    const uint8* buffer, int64* value) {
-  uint64 temp;
+inline const uint8_t*
+WireFormatLite::ReadPrimitiveFromArray<int64_t, WireFormatLite::TYPE_SFIXED64>(
+    const uint8_t* buffer, int64_t* value) {
+  uint64_t temp;
   buffer = io::CodedInputStream::ReadLittleEndian64FromArray(buffer, &temp);
-  *value = static_cast<int64>(temp);
+  *value = static_cast<int64_t>(temp);
   return buffer;
 }
 template <>
-inline const uint8*
+inline const uint8_t*
 WireFormatLite::ReadPrimitiveFromArray<float, WireFormatLite::TYPE_FLOAT>(
-    const uint8* buffer, float* value) {
-  uint32 temp;
+    const uint8_t* buffer, float* value) {
+  uint32_t temp;
   buffer = io::CodedInputStream::ReadLittleEndian32FromArray(buffer, &temp);
   *value = DecodeFloat(temp);
   return buffer;
 }
 template <>
-inline const uint8*
+inline const uint8_t*
 WireFormatLite::ReadPrimitiveFromArray<double, WireFormatLite::TYPE_DOUBLE>(
-    const uint8* buffer, double* value) {
-  uint64 temp;
+    const uint8_t* buffer, double* value) {
+  uint64_t temp;
   buffer = io::CodedInputStream::ReadLittleEndian64FromArray(buffer, &temp);
   *value = DecodeDouble(temp);
   return buffer;
@@ -1047,7 +1064,7 @@ WireFormatLite::ReadPrimitiveFromArray<double, WireFormatLite::TYPE_DOUBLE>(
 template <typename CType, enum WireFormatLite::FieldType DeclaredType>
 inline bool WireFormatLite::ReadRepeatedPrimitive(
     int,  // tag_size, unused.
-    uint32 tag, io::CodedInputStream* input, RepeatedField<CType>* values) {
+    uint32_t tag, io::CodedInputStream* input, RepeatedField<CType>* values) {
   CType value;
   if (!ReadPrimitive<CType, DeclaredType>(input, &value)) return false;
   values->Add(value);
@@ -1062,7 +1079,7 @@ inline bool WireFormatLite::ReadRepeatedPrimitive(
 
 template <typename CType, enum WireFormatLite::FieldType DeclaredType>
 inline bool WireFormatLite::ReadRepeatedFixedSizePrimitive(
-    int tag_size, uint32 tag, io::CodedInputStream* input,
+    int tag_size, uint32_t tag, io::CodedInputStream* input,
     RepeatedField<CType>* values) {
   GOOGLE_DCHECK_EQ(UInt32Size(tag), static_cast<size_t>(tag_size));
   CType value;
@@ -1082,7 +1099,7 @@ inline bool WireFormatLite::ReadRepeatedFixedSizePrimitive(
   int size;
   input->GetDirectBufferPointerInline(&void_pointer, &size);
   if (size > 0) {
-    const uint8* buffer = reinterpret_cast<const uint8*>(void_pointer);
+    const uint8_t* buffer = reinterpret_cast<const uint8_t*>(void_pointer);
     // The number of bytes each type occupies on the wire.
     const int per_value_size = tag_size + static_cast<int>(sizeof(value));
 
@@ -1092,7 +1109,7 @@ inline bool WireFormatLite::ReadRepeatedFixedSizePrimitive(
     int num_read = 0;
     while (num_read < elements_available &&
            (buffer = io::CodedInputStream::ExpectTagFromArray(buffer, tag)) !=
-               NULL) {
+               nullptr) {
       buffer = ReadPrimitiveFromArray<CType, DeclaredType>(buffer, &value);
       values->AddAlreadyReserved(value);
       ++num_read;
@@ -1111,17 +1128,17 @@ inline bool WireFormatLite::ReadRepeatedFixedSizePrimitive(
   template <>                                                             \
   inline bool WireFormatLite::ReadRepeatedPrimitive<                      \
       CPPTYPE, WireFormatLite::DECLARED_TYPE>(                            \
-      int tag_size, uint32 tag, io::CodedInputStream* input,              \
+      int tag_size, uint32_t tag, io::CodedInputStream* input,            \
       RepeatedField<CPPTYPE>* values) {                                   \
     return ReadRepeatedFixedSizePrimitive<CPPTYPE,                        \
                                           WireFormatLite::DECLARED_TYPE>( \
         tag_size, tag, input, values);                                    \
   }
 
-READ_REPEATED_FIXED_SIZE_PRIMITIVE(uint32, TYPE_FIXED32)
-READ_REPEATED_FIXED_SIZE_PRIMITIVE(uint64, TYPE_FIXED64)
-READ_REPEATED_FIXED_SIZE_PRIMITIVE(int32, TYPE_SFIXED32)
-READ_REPEATED_FIXED_SIZE_PRIMITIVE(int64, TYPE_SFIXED64)
+READ_REPEATED_FIXED_SIZE_PRIMITIVE(uint32_t, TYPE_FIXED32)
+READ_REPEATED_FIXED_SIZE_PRIMITIVE(uint64_t, TYPE_FIXED64)
+READ_REPEATED_FIXED_SIZE_PRIMITIVE(int32_t, TYPE_SFIXED32)
+READ_REPEATED_FIXED_SIZE_PRIMITIVE(int64_t, TYPE_SFIXED64)
 READ_REPEATED_FIXED_SIZE_PRIMITIVE(float, TYPE_FLOAT)
 READ_REPEATED_FIXED_SIZE_PRIMITIVE(double, TYPE_DOUBLE)
 
@@ -1129,7 +1146,7 @@ READ_REPEATED_FIXED_SIZE_PRIMITIVE(double, TYPE_DOUBLE)
 
 template <typename CType, enum WireFormatLite::FieldType DeclaredType>
 bool WireFormatLite::ReadRepeatedPrimitiveNoInline(
-    int tag_size, uint32 tag, io::CodedInputStream* input,
+    int tag_size, uint32_t tag, io::CodedInputStream* input,
     RepeatedField<CType>* value) {
   return ReadRepeatedPrimitive<CType, DeclaredType>(tag_size, tag, input,
                                                     value);
@@ -1171,13 +1188,13 @@ inline bool WireFormatLite::ReadPackedFixedSizePrimitive(
   // -1               >= 0   Use fast path if length <= Limit.
   // >= 0             -1     Use slow path.
   // >= 0             >= 0   Use fast path if length <= min(both limits).
-  int64 bytes_limit = input->BytesUntilTotalBytesLimit();
+  int64_t bytes_limit = input->BytesUntilTotalBytesLimit();
   if (bytes_limit == -1) {
     bytes_limit = input->BytesUntilLimit();
   } else {
     // parentheses around (std::min) prevents macro expansion of min(...)
     bytes_limit =
-        (std::min)(bytes_limit, static_cast<int64>(input->BytesUntilLimit()));
+        (std::min)(bytes_limit, static_cast<int64_t>(input->BytesUntilLimit()));
   }
   if (bytes_limit >= new_bytes) {
     // Fast-path that pre-allocates *values to the final size.
@@ -1222,10 +1239,10 @@ inline bool WireFormatLite::ReadPackedFixedSizePrimitive(
         input, values);                                                        \
   }
 
-READ_REPEATED_PACKED_FIXED_SIZE_PRIMITIVE(uint32, TYPE_FIXED32)
-READ_REPEATED_PACKED_FIXED_SIZE_PRIMITIVE(uint64, TYPE_FIXED64)
-READ_REPEATED_PACKED_FIXED_SIZE_PRIMITIVE(int32, TYPE_SFIXED32)
-READ_REPEATED_PACKED_FIXED_SIZE_PRIMITIVE(int64, TYPE_SFIXED64)
+READ_REPEATED_PACKED_FIXED_SIZE_PRIMITIVE(uint32_t, TYPE_FIXED32)
+READ_REPEATED_PACKED_FIXED_SIZE_PRIMITIVE(uint64_t, TYPE_FIXED64)
+READ_REPEATED_PACKED_FIXED_SIZE_PRIMITIVE(int32_t, TYPE_SFIXED32)
+READ_REPEATED_PACKED_FIXED_SIZE_PRIMITIVE(int64_t, TYPE_SFIXED64)
 READ_REPEATED_PACKED_FIXED_SIZE_PRIMITIVE(float, TYPE_FLOAT)
 READ_REPEATED_PACKED_FIXED_SIZE_PRIMITIVE(double, TYPE_DOUBLE)
 
@@ -1271,45 +1288,45 @@ inline void WireFormatLite::WriteTag(int field_number, WireType type,
   output->WriteTag(MakeTag(field_number, type));
 }
 
-inline void WireFormatLite::WriteInt32NoTag(int32 value,
+inline void WireFormatLite::WriteInt32NoTag(int32_t value,
                                             io::CodedOutputStream* output) {
   output->WriteVarint32SignExtended(value);
 }
-inline void WireFormatLite::WriteInt64NoTag(int64 value,
+inline void WireFormatLite::WriteInt64NoTag(int64_t value,
                                             io::CodedOutputStream* output) {
-  output->WriteVarint64(static_cast<uint64>(value));
+  output->WriteVarint64(static_cast<uint64_t>(value));
 }
-inline void WireFormatLite::WriteUInt32NoTag(uint32 value,
+inline void WireFormatLite::WriteUInt32NoTag(uint32_t value,
                                              io::CodedOutputStream* output) {
   output->WriteVarint32(value);
 }
-inline void WireFormatLite::WriteUInt64NoTag(uint64 value,
+inline void WireFormatLite::WriteUInt64NoTag(uint64_t value,
                                              io::CodedOutputStream* output) {
   output->WriteVarint64(value);
 }
-inline void WireFormatLite::WriteSInt32NoTag(int32 value,
+inline void WireFormatLite::WriteSInt32NoTag(int32_t value,
                                              io::CodedOutputStream* output) {
   output->WriteVarint32(ZigZagEncode32(value));
 }
-inline void WireFormatLite::WriteSInt64NoTag(int64 value,
+inline void WireFormatLite::WriteSInt64NoTag(int64_t value,
                                              io::CodedOutputStream* output) {
   output->WriteVarint64(ZigZagEncode64(value));
 }
-inline void WireFormatLite::WriteFixed32NoTag(uint32 value,
+inline void WireFormatLite::WriteFixed32NoTag(uint32_t value,
                                               io::CodedOutputStream* output) {
   output->WriteLittleEndian32(value);
 }
-inline void WireFormatLite::WriteFixed64NoTag(uint64 value,
+inline void WireFormatLite::WriteFixed64NoTag(uint64_t value,
                                               io::CodedOutputStream* output) {
   output->WriteLittleEndian64(value);
 }
-inline void WireFormatLite::WriteSFixed32NoTag(int32 value,
+inline void WireFormatLite::WriteSFixed32NoTag(int32_t value,
                                                io::CodedOutputStream* output) {
-  output->WriteLittleEndian32(static_cast<uint32>(value));
+  output->WriteLittleEndian32(static_cast<uint32_t>(value));
 }
-inline void WireFormatLite::WriteSFixed64NoTag(int64 value,
+inline void WireFormatLite::WriteSFixed64NoTag(int64_t value,
                                                io::CodedOutputStream* output) {
-  output->WriteLittleEndian64(static_cast<uint64>(value));
+  output->WriteLittleEndian64(static_cast<uint64_t>(value));
 }
 inline void WireFormatLite::WriteFloatNoTag(float value,
                                             io::CodedOutputStream* output) {
@@ -1350,77 +1367,80 @@ inline void WireFormatLite::WriteMessageNoVirtual(
 
 // ===================================================================
 
-inline uint8* WireFormatLite::WriteTagToArray(int field_number, WireType type,
-                                              uint8* target) {
+inline uint8_t* WireFormatLite::WriteTagToArray(int field_number, WireType type,
+                                                uint8_t* target) {
   return io::CodedOutputStream::WriteTagToArray(MakeTag(field_number, type),
                                                 target);
 }
 
-inline uint8* WireFormatLite::WriteInt32NoTagToArray(int32 value,
-                                                     uint8* target) {
+inline uint8_t* WireFormatLite::WriteInt32NoTagToArray(int32_t value,
+                                                       uint8_t* target) {
   return io::CodedOutputStream::WriteVarint32SignExtendedToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteInt64NoTagToArray(int64 value,
-                                                     uint8* target) {
-  return io::CodedOutputStream::WriteVarint64ToArray(static_cast<uint64>(value),
-                                                     target);
+inline uint8_t* WireFormatLite::WriteInt64NoTagToArray(int64_t value,
+                                                       uint8_t* target) {
+  return io::CodedOutputStream::WriteVarint64ToArray(
+      static_cast<uint64_t>(value), target);
 }
-inline uint8* WireFormatLite::WriteUInt32NoTagToArray(uint32 value,
-                                                      uint8* target) {
+inline uint8_t* WireFormatLite::WriteUInt32NoTagToArray(uint32_t value,
+                                                        uint8_t* target) {
   return io::CodedOutputStream::WriteVarint32ToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteUInt64NoTagToArray(uint64 value,
-                                                      uint8* target) {
+inline uint8_t* WireFormatLite::WriteUInt64NoTagToArray(uint64_t value,
+                                                        uint8_t* target) {
   return io::CodedOutputStream::WriteVarint64ToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteSInt32NoTagToArray(int32 value,
-                                                      uint8* target) {
+inline uint8_t* WireFormatLite::WriteSInt32NoTagToArray(int32_t value,
+                                                        uint8_t* target) {
   return io::CodedOutputStream::WriteVarint32ToArray(ZigZagEncode32(value),
                                                      target);
 }
-inline uint8* WireFormatLite::WriteSInt64NoTagToArray(int64 value,
-                                                      uint8* target) {
+inline uint8_t* WireFormatLite::WriteSInt64NoTagToArray(int64_t value,
+                                                        uint8_t* target) {
   return io::CodedOutputStream::WriteVarint64ToArray(ZigZagEncode64(value),
                                                      target);
 }
-inline uint8* WireFormatLite::WriteFixed32NoTagToArray(uint32 value,
-                                                       uint8* target) {
+inline uint8_t* WireFormatLite::WriteFixed32NoTagToArray(uint32_t value,
+                                                         uint8_t* target) {
   return io::CodedOutputStream::WriteLittleEndian32ToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteFixed64NoTagToArray(uint64 value,
-                                                       uint8* target) {
+inline uint8_t* WireFormatLite::WriteFixed64NoTagToArray(uint64_t value,
+                                                         uint8_t* target) {
   return io::CodedOutputStream::WriteLittleEndian64ToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteSFixed32NoTagToArray(int32 value,
-                                                        uint8* target) {
+inline uint8_t* WireFormatLite::WriteSFixed32NoTagToArray(int32_t value,
+                                                          uint8_t* target) {
   return io::CodedOutputStream::WriteLittleEndian32ToArray(
-      static_cast<uint32>(value), target);
+      static_cast<uint32_t>(value), target);
 }
-inline uint8* WireFormatLite::WriteSFixed64NoTagToArray(int64 value,
-                                                        uint8* target) {
+inline uint8_t* WireFormatLite::WriteSFixed64NoTagToArray(int64_t value,
+                                                          uint8_t* target) {
   return io::CodedOutputStream::WriteLittleEndian64ToArray(
-      static_cast<uint64>(value), target);
+      static_cast<uint64_t>(value), target);
 }
-inline uint8* WireFormatLite::WriteFloatNoTagToArray(float value,
-                                                     uint8* target) {
+inline uint8_t* WireFormatLite::WriteFloatNoTagToArray(float value,
+                                                       uint8_t* target) {
   return io::CodedOutputStream::WriteLittleEndian32ToArray(EncodeFloat(value),
                                                            target);
 }
-inline uint8* WireFormatLite::WriteDoubleNoTagToArray(double value,
-                                                      uint8* target) {
+inline uint8_t* WireFormatLite::WriteDoubleNoTagToArray(double value,
+                                                        uint8_t* target) {
   return io::CodedOutputStream::WriteLittleEndian64ToArray(EncodeDouble(value),
                                                            target);
 }
-inline uint8* WireFormatLite::WriteBoolNoTagToArray(bool value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteBoolNoTagToArray(bool value,
+                                                      uint8_t* target) {
   return io::CodedOutputStream::WriteVarint32ToArray(value ? 1 : 0, target);
 }
-inline uint8* WireFormatLite::WriteEnumNoTagToArray(int value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteEnumNoTagToArray(int value,
+                                                      uint8_t* target) {
   return io::CodedOutputStream::WriteVarint32SignExtendedToArray(value, target);
 }
 
 template <typename T>
-inline uint8* WireFormatLite::WritePrimitiveNoTagToArray(
-    const RepeatedField<T>& value, uint8* (*Writer)(T, uint8*), uint8* target) {
+inline uint8_t* WireFormatLite::WritePrimitiveNoTagToArray(
+    const RepeatedField<T>& value, uint8_t* (*Writer)(T, uint8_t*),
+    uint8_t* target) {
   const int n = value.size();
   GOOGLE_DCHECK_GT(n, 0);
 
@@ -1434,8 +1454,9 @@ inline uint8* WireFormatLite::WritePrimitiveNoTagToArray(
 }
 
 template <typename T>
-inline uint8* WireFormatLite::WriteFixedNoTagToArray(
-    const RepeatedField<T>& value, uint8* (*Writer)(T, uint8*), uint8* target) {
+inline uint8_t* WireFormatLite::WriteFixedNoTagToArray(
+    const RepeatedField<T>& value, uint8_t* (*Writer)(T, uint8_t*),
+    uint8_t* target) {
 #if defined(PROTOBUF_LITTLE_ENDIAN)
   (void)Writer;
 
@@ -1451,138 +1472,149 @@ inline uint8* WireFormatLite::WriteFixedNoTagToArray(
 #endif
 }
 
-inline uint8* WireFormatLite::WriteInt32NoTagToArray(
-    const RepeatedField<int32>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteInt32NoTagToArray(
+    const RepeatedField<int32_t>& value, uint8_t* target) {
   return WritePrimitiveNoTagToArray(value, WriteInt32NoTagToArray, target);
 }
-inline uint8* WireFormatLite::WriteInt64NoTagToArray(
-    const RepeatedField<int64>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteInt64NoTagToArray(
+    const RepeatedField<int64_t>& value, uint8_t* target) {
   return WritePrimitiveNoTagToArray(value, WriteInt64NoTagToArray, target);
 }
-inline uint8* WireFormatLite::WriteUInt32NoTagToArray(
-    const RepeatedField<uint32>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteUInt32NoTagToArray(
+    const RepeatedField<uint32_t>& value, uint8_t* target) {
   return WritePrimitiveNoTagToArray(value, WriteUInt32NoTagToArray, target);
 }
-inline uint8* WireFormatLite::WriteUInt64NoTagToArray(
-    const RepeatedField<uint64>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteUInt64NoTagToArray(
+    const RepeatedField<uint64_t>& value, uint8_t* target) {
   return WritePrimitiveNoTagToArray(value, WriteUInt64NoTagToArray, target);
 }
-inline uint8* WireFormatLite::WriteSInt32NoTagToArray(
-    const RepeatedField<int32>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteSInt32NoTagToArray(
+    const RepeatedField<int32_t>& value, uint8_t* target) {
   return WritePrimitiveNoTagToArray(value, WriteSInt32NoTagToArray, target);
 }
-inline uint8* WireFormatLite::WriteSInt64NoTagToArray(
-    const RepeatedField<int64>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteSInt64NoTagToArray(
+    const RepeatedField<int64_t>& value, uint8_t* target) {
   return WritePrimitiveNoTagToArray(value, WriteSInt64NoTagToArray, target);
 }
-inline uint8* WireFormatLite::WriteFixed32NoTagToArray(
-    const RepeatedField<uint32>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteFixed32NoTagToArray(
+    const RepeatedField<uint32_t>& value, uint8_t* target) {
   return WriteFixedNoTagToArray(value, WriteFixed32NoTagToArray, target);
 }
-inline uint8* WireFormatLite::WriteFixed64NoTagToArray(
-    const RepeatedField<uint64>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteFixed64NoTagToArray(
+    const RepeatedField<uint64_t>& value, uint8_t* target) {
   return WriteFixedNoTagToArray(value, WriteFixed64NoTagToArray, target);
 }
-inline uint8* WireFormatLite::WriteSFixed32NoTagToArray(
-    const RepeatedField<int32>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteSFixed32NoTagToArray(
+    const RepeatedField<int32_t>& value, uint8_t* target) {
   return WriteFixedNoTagToArray(value, WriteSFixed32NoTagToArray, target);
 }
-inline uint8* WireFormatLite::WriteSFixed64NoTagToArray(
-    const RepeatedField<int64>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteSFixed64NoTagToArray(
+    const RepeatedField<int64_t>& value, uint8_t* target) {
   return WriteFixedNoTagToArray(value, WriteSFixed64NoTagToArray, target);
 }
-inline uint8* WireFormatLite::WriteFloatNoTagToArray(
-    const RepeatedField<float>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteFloatNoTagToArray(
+    const RepeatedField<float>& value, uint8_t* target) {
   return WriteFixedNoTagToArray(value, WriteFloatNoTagToArray, target);
 }
-inline uint8* WireFormatLite::WriteDoubleNoTagToArray(
-    const RepeatedField<double>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteDoubleNoTagToArray(
+    const RepeatedField<double>& value, uint8_t* target) {
   return WriteFixedNoTagToArray(value, WriteDoubleNoTagToArray, target);
 }
-inline uint8* WireFormatLite::WriteBoolNoTagToArray(
-    const RepeatedField<bool>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteBoolNoTagToArray(
+    const RepeatedField<bool>& value, uint8_t* target) {
   return WritePrimitiveNoTagToArray(value, WriteBoolNoTagToArray, target);
 }
-inline uint8* WireFormatLite::WriteEnumNoTagToArray(
-    const RepeatedField<int>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteEnumNoTagToArray(
+    const RepeatedField<int>& value, uint8_t* target) {
   return WritePrimitiveNoTagToArray(value, WriteEnumNoTagToArray, target);
 }
 
-inline uint8* WireFormatLite::WriteInt32ToArray(int field_number, int32 value,
-                                                uint8* target) {
+inline uint8_t* WireFormatLite::WriteInt32ToArray(int field_number,
+                                                  int32_t value,
+                                                  uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_VARINT, target);
   return WriteInt32NoTagToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteInt64ToArray(int field_number, int64 value,
-                                                uint8* target) {
+inline uint8_t* WireFormatLite::WriteInt64ToArray(int field_number,
+                                                  int64_t value,
+                                                  uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_VARINT, target);
   return WriteInt64NoTagToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteUInt32ToArray(int field_number, uint32 value,
-                                                 uint8* target) {
+inline uint8_t* WireFormatLite::WriteUInt32ToArray(int field_number,
+                                                   uint32_t value,
+                                                   uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_VARINT, target);
   return WriteUInt32NoTagToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteUInt64ToArray(int field_number, uint64 value,
-                                                 uint8* target) {
+inline uint8_t* WireFormatLite::WriteUInt64ToArray(int field_number,
+                                                   uint64_t value,
+                                                   uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_VARINT, target);
   return WriteUInt64NoTagToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteSInt32ToArray(int field_number, int32 value,
-                                                 uint8* target) {
+inline uint8_t* WireFormatLite::WriteSInt32ToArray(int field_number,
+                                                   int32_t value,
+                                                   uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_VARINT, target);
   return WriteSInt32NoTagToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteSInt64ToArray(int field_number, int64 value,
-                                                 uint8* target) {
+inline uint8_t* WireFormatLite::WriteSInt64ToArray(int field_number,
+                                                   int64_t value,
+                                                   uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_VARINT, target);
   return WriteSInt64NoTagToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteFixed32ToArray(int field_number,
-                                                  uint32 value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteFixed32ToArray(int field_number,
+                                                    uint32_t value,
+                                                    uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_FIXED32, target);
   return WriteFixed32NoTagToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteFixed64ToArray(int field_number,
-                                                  uint64 value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteFixed64ToArray(int field_number,
+                                                    uint64_t value,
+                                                    uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_FIXED64, target);
   return WriteFixed64NoTagToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteSFixed32ToArray(int field_number,
-                                                   int32 value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteSFixed32ToArray(int field_number,
+                                                     int32_t value,
+                                                     uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_FIXED32, target);
   return WriteSFixed32NoTagToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteSFixed64ToArray(int field_number,
-                                                   int64 value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteSFixed64ToArray(int field_number,
+                                                     int64_t value,
+                                                     uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_FIXED64, target);
   return WriteSFixed64NoTagToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteFloatToArray(int field_number, float value,
-                                                uint8* target) {
+inline uint8_t* WireFormatLite::WriteFloatToArray(int field_number, float value,
+                                                  uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_FIXED32, target);
   return WriteFloatNoTagToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteDoubleToArray(int field_number, double value,
-                                                 uint8* target) {
+inline uint8_t* WireFormatLite::WriteDoubleToArray(int field_number,
+                                                   double value,
+                                                   uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_FIXED64, target);
   return WriteDoubleNoTagToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteBoolToArray(int field_number, bool value,
-                                               uint8* target) {
+inline uint8_t* WireFormatLite::WriteBoolToArray(int field_number, bool value,
+                                                 uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_VARINT, target);
   return WriteBoolNoTagToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteEnumToArray(int field_number, int value,
-                                               uint8* target) {
+inline uint8_t* WireFormatLite::WriteEnumToArray(int field_number, int value,
+                                                 uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_VARINT, target);
   return WriteEnumNoTagToArray(value, target);
 }
 
 template <typename T>
-inline uint8* WireFormatLite::WritePrimitiveToArray(
+inline uint8_t* WireFormatLite::WritePrimitiveToArray(
     int field_number, const RepeatedField<T>& value,
-    uint8* (*Writer)(int, T, uint8*), uint8* target) {
+    uint8_t* (*Writer)(int, T, uint8_t*), uint8_t* target) {
   const int n = value.size();
   if (n == 0) {
     return target;
@@ -1597,71 +1629,69 @@ inline uint8* WireFormatLite::WritePrimitiveToArray(
   return target;
 }
 
-inline uint8* WireFormatLite::WriteInt32ToArray(
-    int field_number, const RepeatedField<int32>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteInt32ToArray(
+    int field_number, const RepeatedField<int32_t>& value, uint8_t* target) {
   return WritePrimitiveToArray(field_number, value, WriteInt32ToArray, target);
 }
-inline uint8* WireFormatLite::WriteInt64ToArray(
-    int field_number, const RepeatedField<int64>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteInt64ToArray(
+    int field_number, const RepeatedField<int64_t>& value, uint8_t* target) {
   return WritePrimitiveToArray(field_number, value, WriteInt64ToArray, target);
 }
-inline uint8* WireFormatLite::WriteUInt32ToArray(
-    int field_number, const RepeatedField<uint32>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteUInt32ToArray(
+    int field_number, const RepeatedField<uint32_t>& value, uint8_t* target) {
   return WritePrimitiveToArray(field_number, value, WriteUInt32ToArray, target);
 }
-inline uint8* WireFormatLite::WriteUInt64ToArray(
-    int field_number, const RepeatedField<uint64>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteUInt64ToArray(
+    int field_number, const RepeatedField<uint64_t>& value, uint8_t* target) {
   return WritePrimitiveToArray(field_number, value, WriteUInt64ToArray, target);
 }
-inline uint8* WireFormatLite::WriteSInt32ToArray(
-    int field_number, const RepeatedField<int32>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteSInt32ToArray(
+    int field_number, const RepeatedField<int32_t>& value, uint8_t* target) {
   return WritePrimitiveToArray(field_number, value, WriteSInt32ToArray, target);
 }
-inline uint8* WireFormatLite::WriteSInt64ToArray(
-    int field_number, const RepeatedField<int64>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteSInt64ToArray(
+    int field_number, const RepeatedField<int64_t>& value, uint8_t* target) {
   return WritePrimitiveToArray(field_number, value, WriteSInt64ToArray, target);
 }
-inline uint8* WireFormatLite::WriteFixed32ToArray(
-    int field_number, const RepeatedField<uint32>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteFixed32ToArray(
+    int field_number, const RepeatedField<uint32_t>& value, uint8_t* target) {
   return WritePrimitiveToArray(field_number, value, WriteFixed32ToArray,
                                target);
 }
-inline uint8* WireFormatLite::WriteFixed64ToArray(
-    int field_number, const RepeatedField<uint64>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteFixed64ToArray(
+    int field_number, const RepeatedField<uint64_t>& value, uint8_t* target) {
   return WritePrimitiveToArray(field_number, value, WriteFixed64ToArray,
                                target);
 }
-inline uint8* WireFormatLite::WriteSFixed32ToArray(
-    int field_number, const RepeatedField<int32>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteSFixed32ToArray(
+    int field_number, const RepeatedField<int32_t>& value, uint8_t* target) {
   return WritePrimitiveToArray(field_number, value, WriteSFixed32ToArray,
                                target);
 }
-inline uint8* WireFormatLite::WriteSFixed64ToArray(
-    int field_number, const RepeatedField<int64>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteSFixed64ToArray(
+    int field_number, const RepeatedField<int64_t>& value, uint8_t* target) {
   return WritePrimitiveToArray(field_number, value, WriteSFixed64ToArray,
                                target);
 }
-inline uint8* WireFormatLite::WriteFloatToArray(
-    int field_number, const RepeatedField<float>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteFloatToArray(
+    int field_number, const RepeatedField<float>& value, uint8_t* target) {
   return WritePrimitiveToArray(field_number, value, WriteFloatToArray, target);
 }
-inline uint8* WireFormatLite::WriteDoubleToArray(
-    int field_number, const RepeatedField<double>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteDoubleToArray(
+    int field_number, const RepeatedField<double>& value, uint8_t* target) {
   return WritePrimitiveToArray(field_number, value, WriteDoubleToArray, target);
 }
-inline uint8* WireFormatLite::WriteBoolToArray(int field_number,
-                                               const RepeatedField<bool>& value,
-                                               uint8* target) {
+inline uint8_t* WireFormatLite::WriteBoolToArray(
+    int field_number, const RepeatedField<bool>& value, uint8_t* target) {
   return WritePrimitiveToArray(field_number, value, WriteBoolToArray, target);
 }
-inline uint8* WireFormatLite::WriteEnumToArray(int field_number,
-                                               const RepeatedField<int>& value,
-                                               uint8* target) {
+inline uint8_t* WireFormatLite::WriteEnumToArray(
+    int field_number, const RepeatedField<int>& value, uint8_t* target) {
   return WritePrimitiveToArray(field_number, value, WriteEnumToArray, target);
 }
-inline uint8* WireFormatLite::WriteStringToArray(int field_number,
-                                                 const std::string& value,
-                                                 uint8* target) {
+inline uint8_t* WireFormatLite::WriteStringToArray(int field_number,
+                                                   const std::string& value,
+                                                   uint8_t* target) {
   // String is for UTF-8 text only
   // WARNING:  In wire_format.cc, both strings and bytes are handled by
   //   WriteString() to avoid code duplication.  If the implementations become
@@ -1669,9 +1699,9 @@ inline uint8* WireFormatLite::WriteStringToArray(int field_number,
   target = WriteTagToArray(field_number, WIRETYPE_LENGTH_DELIMITED, target);
   return io::CodedOutputStream::WriteStringWithSizeToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteBytesToArray(int field_number,
-                                                const std::string& value,
-                                                uint8* target) {
+inline uint8_t* WireFormatLite::WriteBytesToArray(int field_number,
+                                                  const std::string& value,
+                                                  uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_LENGTH_DELIMITED, target);
   return io::CodedOutputStream::WriteStringWithSizeToArray(value, target);
 }
@@ -1699,21 +1729,21 @@ inline uint8* WireFormatLite::InternalWriteMessage(
 // See comment on ReadGroupNoVirtual to understand the need for this template
 // parameter name.
 template <typename MessageType_WorkAroundCppLookupDefect>
-inline uint8* WireFormatLite::InternalWriteGroupNoVirtualToArray(
+inline uint8_t* WireFormatLite::InternalWriteGroupNoVirtualToArray(
     int field_number, const MessageType_WorkAroundCppLookupDefect& value,
-    uint8* target) {
+    uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_START_GROUP, target);
   target = value.MessageType_WorkAroundCppLookupDefect::
                SerializeWithCachedSizesToArray(target);
   return WriteTagToArray(field_number, WIRETYPE_END_GROUP, target);
 }
 template <typename MessageType_WorkAroundCppLookupDefect>
-inline uint8* WireFormatLite::InternalWriteMessageNoVirtualToArray(
+inline uint8_t* WireFormatLite::InternalWriteMessageNoVirtualToArray(
     int field_number, const MessageType_WorkAroundCppLookupDefect& value,
-    uint8* target) {
+    uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_LENGTH_DELIMITED, target);
   target = io::CodedOutputStream::WriteVarint32ToArray(
-      static_cast<uint32>(
+      static_cast<uint32_t>(
           value.MessageType_WorkAroundCppLookupDefect::GetCachedSize()),
       target);
   return value
@@ -1723,27 +1753,49 @@ inline uint8* WireFormatLite::InternalWriteMessageNoVirtualToArray(
 
 // ===================================================================
 
-inline size_t WireFormatLite::Int32Size(int32 value) {
+inline size_t WireFormatLite::Int32Size(int32_t value) {
   return io::CodedOutputStream::VarintSize32SignExtended(value);
 }
-inline size_t WireFormatLite::Int64Size(int64 value) {
-  return io::CodedOutputStream::VarintSize64(static_cast<uint64>(value));
+inline size_t WireFormatLite::Int64Size(int64_t value) {
+  return io::CodedOutputStream::VarintSize64(static_cast<uint64_t>(value));
 }
-inline size_t WireFormatLite::UInt32Size(uint32 value) {
+inline size_t WireFormatLite::UInt32Size(uint32_t value) {
   return io::CodedOutputStream::VarintSize32(value);
 }
-inline size_t WireFormatLite::UInt64Size(uint64 value) {
+inline size_t WireFormatLite::UInt64Size(uint64_t value) {
   return io::CodedOutputStream::VarintSize64(value);
 }
-inline size_t WireFormatLite::SInt32Size(int32 value) {
+inline size_t WireFormatLite::SInt32Size(int32_t value) {
   return io::CodedOutputStream::VarintSize32(ZigZagEncode32(value));
 }
-inline size_t WireFormatLite::SInt64Size(int64 value) {
+inline size_t WireFormatLite::SInt64Size(int64_t value) {
   return io::CodedOutputStream::VarintSize64(ZigZagEncode64(value));
 }
 inline size_t WireFormatLite::EnumSize(int value) {
   return io::CodedOutputStream::VarintSize32SignExtended(value);
 }
+inline size_t WireFormatLite::Int32SizePlusOne(int32_t value) {
+  return io::CodedOutputStream::VarintSize32SignExtendedPlusOne(value);
+}
+inline size_t WireFormatLite::Int64SizePlusOne(int64_t value) {
+  return io::CodedOutputStream::VarintSize64PlusOne(
+      static_cast<uint64_t>(value));
+}
+inline size_t WireFormatLite::UInt32SizePlusOne(uint32_t value) {
+  return io::CodedOutputStream::VarintSize32PlusOne(value);
+}
+inline size_t WireFormatLite::UInt64SizePlusOne(uint64_t value) {
+  return io::CodedOutputStream::VarintSize64PlusOne(value);
+}
+inline size_t WireFormatLite::SInt32SizePlusOne(int32_t value) {
+  return io::CodedOutputStream::VarintSize32PlusOne(ZigZagEncode32(value));
+}
+inline size_t WireFormatLite::SInt64SizePlusOne(int64_t value) {
+  return io::CodedOutputStream::VarintSize64PlusOne(ZigZagEncode64(value));
+}
+inline size_t WireFormatLite::EnumSizePlusOne(int value) {
+  return io::CodedOutputStream::VarintSize32SignExtendedPlusOne(value);
+}
 
 inline size_t WireFormatLite::StringSize(const std::string& value) {
   return LengthDelimitedSize(value.size());
@@ -1778,11 +1830,11 @@ inline size_t WireFormatLite::MessageSizeNoVirtual(
 
 inline size_t WireFormatLite::LengthDelimitedSize(size_t length) {
   // The static_cast here prevents an error in certain compiler configurations
-  // but is not technically correct--if length is too large to fit in a uint32
+  // but is not technically correct--if length is too large to fit in a uint32_t
   // then it will be silently truncated. We will need to fix this if we ever
   // decide to start supporting serialized messages greater than 2 GiB in size.
   return length +
-         io::CodedOutputStream::VarintSize32(static_cast<uint32>(length));
+         io::CodedOutputStream::VarintSize32(static_cast<uint32_t>(length));
 }
 
 template <typename MS>
@@ -1791,55 +1843,64 @@ bool ParseMessageSetItemImpl(io::CodedInputStream* input, MS ms) {
   //   required int32 type_id = 2;
   //   required data message = 3;
 
-  uint32 last_type_id = 0;
+  uint32_t last_type_id = 0;
 
   // If we see message data before the type_id, we'll append it to this so
   // we can parse it later.
   std::string message_data;
 
+  enum class State { kNoTag, kHasType, kHasPayload, kDone };
+  State state = State::kNoTag;
+
   while (true) {
-    const uint32 tag = input->ReadTagNoLastTag();
+    const uint32_t tag = input->ReadTagNoLastTag();
     if (tag == 0) return false;
 
     switch (tag) {
       case WireFormatLite::kMessageSetTypeIdTag: {
-        uint32 type_id;
+        uint32_t type_id;
         if (!input->ReadVarint32(&type_id)) return false;
-        last_type_id = type_id;
-
-        if (!message_data.empty()) {
+        if (state == State::kNoTag) {
+          last_type_id = type_id;
+          state = State::kHasType;
+        } else if (state == State::kHasPayload) {
           // We saw some message data before the type_id.  Have to parse it
           // now.
           io::CodedInputStream sub_input(
-              reinterpret_cast<const uint8*>(message_data.data()),
+              reinterpret_cast<const uint8_t*>(message_data.data()),
               static_cast<int>(message_data.size()));
           sub_input.SetRecursionLimit(input->RecursionBudget());
-          if (!ms.ParseField(last_type_id, &sub_input)) {
+          if (!ms.ParseField(type_id, &sub_input)) {
             return false;
           }
           message_data.clear();
+          state = State::kDone;
         }
 
         break;
       }
 
       case WireFormatLite::kMessageSetMessageTag: {
-        if (last_type_id == 0) {
+        if (state == State::kHasType) {
+          // Already saw type_id, so we can parse this directly.
+          if (!ms.ParseField(last_type_id, input)) {
+            return false;
+          }
+          state = State::kDone;
+        } else if (state == State::kNoTag) {
           // We haven't seen a type_id yet.  Append this data to message_data.
-          uint32 length;
+          uint32_t length;
           if (!input->ReadVarint32(&length)) return false;
-          if (static_cast<int32>(length) < 0) return false;
-          uint32 size = static_cast<uint32>(
+          if (static_cast<int32_t>(length) < 0) return false;
+          uint32_t size = static_cast<uint32_t>(
               length + io::CodedOutputStream::VarintSize32(length));
           message_data.resize(size);
-          auto ptr = reinterpret_cast<uint8*>(&message_data[0]);
+          auto ptr = reinterpret_cast<uint8_t*>(&message_data[0]);
           ptr = io::CodedOutputStream::WriteVarint32ToArray(length, ptr);
           if (!input->ReadRaw(ptr, length)) return false;
+          state = State::kHasPayload;
         } else {
-          // Already saw type_id, so we can parse this directly.
-          if (!ms.ParseField(last_type_id, input)) {
-            return false;
-          }
+          if (!ms.SkipField(tag, input)) return false;
         }
 
         break;
diff --git protobuf-3.17.3protobuf-3.17.3/src/google/protobuf/wire_format_unittest.cc protobuf-3.17.3-patchedprotobuf-3.17.3-patched/src/google/protobuf/wire_format_unittest.cc
index 4393066..f1ed951 100644
--- protobuf-3.17.3protobuf-3.17.3/src/google/protobuf/wire_format_unittest.cc
+++ protobuf-3.17.3-patchedprotobuf-3.17.3-patched/src/google/protobuf/wire_format_unittest.cc
@@ -34,1553 +34,33 @@
 
 #include <google/protobuf/wire_format.h>
 
-#include <google/protobuf/stubs/logging.h>
-#include <google/protobuf/stubs/common.h>
-#include <google/protobuf/test_util.h>
-#include <google/protobuf/test_util2.h>
 #include <google/protobuf/unittest.pb.h>
 #include <google/protobuf/unittest_mset.pb.h>
 #include <google/protobuf/unittest_mset_wire_format.pb.h>
 #include <google/protobuf/unittest_proto3_arena.pb.h>
-#include <google/protobuf/io/coded_stream.h>
-#include <google/protobuf/io/zero_copy_stream_impl.h>
-#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
-#include <google/protobuf/descriptor.h>
-#include <google/protobuf/wire_format_lite.h>
-#include <google/protobuf/testing/googletest.h>
-#include <google/protobuf/stubs/logging.h>
 #include <gmock/gmock.h>
 #include <gtest/gtest.h>
-#include <google/protobuf/stubs/casts.h>
-#include <google/protobuf/stubs/strutil.h>
-#include <google/protobuf/stubs/stl_util.h>
 
+#define UNITTEST ::protobuf_unittest
+#define UNITTEST_IMPORT ::protobuf_unittest_import
+#define UNITTEST_PACKAGE_NAME "protobuf_unittest"
+#define PROTO2_WIREFORMAT_UNITTEST ::proto2_wireformat_unittest
+#define PROTO3_ARENA_UNITTEST ::proto3_arena_unittest
+
+// Must include after defining UNITTEST, etc.
 // clang-format off
-#include <google/protobuf/port_def.inc>
+#include <google/protobuf/test_util.inc>
+#include <google/protobuf/wire_format_unittest.inc>
 // clang-format on
 
+// Must be included last.
+#include <google/protobuf/port_def.inc>
+
 namespace google {
 namespace protobuf {
 namespace internal {
 namespace {
 
-TEST(WireFormatTest, EnumsInSync) {
-  // Verify that WireFormatLite::FieldType and WireFormatLite::CppType match
-  // FieldDescriptor::Type and FieldDescriptor::CppType.
-
-  EXPECT_EQ(implicit_cast<int>(FieldDescriptor::MAX_TYPE),
-            implicit_cast<int>(WireFormatLite::MAX_FIELD_TYPE));
-  EXPECT_EQ(implicit_cast<int>(FieldDescriptor::MAX_CPPTYPE),
-            implicit_cast<int>(WireFormatLite::MAX_CPPTYPE));
-
-  for (int i = 1; i <= WireFormatLite::MAX_FIELD_TYPE; i++) {
-    EXPECT_EQ(implicit_cast<int>(FieldDescriptor::TypeToCppType(
-                  static_cast<FieldDescriptor::Type>(i))),
-              implicit_cast<int>(WireFormatLite::FieldTypeToCppType(
-                  static_cast<WireFormatLite::FieldType>(i))));
-  }
-}
-
-TEST(WireFormatTest, MaxFieldNumber) {
-  // Make sure the max field number constant is accurate.
-  EXPECT_EQ((1 << (32 - WireFormatLite::kTagTypeBits)) - 1,
-            FieldDescriptor::kMaxNumber);
-}
-
-TEST(WireFormatTest, Parse) {
-  unittest::TestAllTypes source, dest;
-  std::string data;
-
-  // Serialize using the generated code.
-  TestUtil::SetAllFields(&source);
-  source.SerializeToString(&data);
-
-  // Parse using WireFormat.
-  io::ArrayInputStream raw_input(data.data(), data.size());
-  io::CodedInputStream input(&raw_input);
-  WireFormat::ParseAndMergePartial(&input, &dest);
-
-  // Check.
-  TestUtil::ExpectAllFieldsSet(dest);
-}
-
-TEST(WireFormatTest, ParseExtensions) {
-  unittest::TestAllExtensions source, dest;
-  std::string data;
-
-  // Serialize using the generated code.
-  TestUtil::SetAllExtensions(&source);
-  source.SerializeToString(&data);
-
-  // Parse using WireFormat.
-  io::ArrayInputStream raw_input(data.data(), data.size());
-  io::CodedInputStream input(&raw_input);
-  WireFormat::ParseAndMergePartial(&input, &dest);
-
-  // Check.
-  TestUtil::ExpectAllExtensionsSet(dest);
-}
-
-TEST(WireFormatTest, ParsePacked) {
-  unittest::TestPackedTypes source, dest;
-  std::string data;
-
-  // Serialize using the generated code.
-  TestUtil::SetPackedFields(&source);
-  source.SerializeToString(&data);
-
-  // Parse using WireFormat.
-  io::ArrayInputStream raw_input(data.data(), data.size());
-  io::CodedInputStream input(&raw_input);
-  WireFormat::ParseAndMergePartial(&input, &dest);
-
-  // Check.
-  TestUtil::ExpectPackedFieldsSet(dest);
-}
-
-TEST(WireFormatTest, ParsePackedFromUnpacked) {
-  // Serialize using the generated code.
-  unittest::TestUnpackedTypes source;
-  TestUtil::SetUnpackedFields(&source);
-  std::string data = source.SerializeAsString();
-
-  // Parse using WireFormat.
-  unittest::TestPackedTypes dest;
-  io::ArrayInputStream raw_input(data.data(), data.size());
-  io::CodedInputStream input(&raw_input);
-  WireFormat::ParseAndMergePartial(&input, &dest);
-
-  // Check.
-  TestUtil::ExpectPackedFieldsSet(dest);
-}
-
-TEST(WireFormatTest, ParseUnpackedFromPacked) {
-  // Serialize using the generated code.
-  unittest::TestPackedTypes source;
-  TestUtil::SetPackedFields(&source);
-  std::string data = source.SerializeAsString();
-
-  // Parse using WireFormat.
-  unittest::TestUnpackedTypes dest;
-  io::ArrayInputStream raw_input(data.data(), data.size());
-  io::CodedInputStream input(&raw_input);
-  WireFormat::ParseAndMergePartial(&input, &dest);
-
-  // Check.
-  TestUtil::ExpectUnpackedFieldsSet(dest);
-}
-
-TEST(WireFormatTest, ParsePackedExtensions) {
-  unittest::TestPackedExtensions source, dest;
-  std::string data;
-
-  // Serialize using the generated code.
-  TestUtil::SetPackedExtensions(&source);
-  source.SerializeToString(&data);
-
-  // Parse using WireFormat.
-  io::ArrayInputStream raw_input(data.data(), data.size());
-  io::CodedInputStream input(&raw_input);
-  WireFormat::ParseAndMergePartial(&input, &dest);
-
-  // Check.
-  TestUtil::ExpectPackedExtensionsSet(dest);
-}
-
-TEST(WireFormatTest, ParseOneof) {
-  unittest::TestOneof2 source, dest;
-  std::string data;
-
-  // Serialize using the generated code.
-  TestUtil::SetOneof1(&source);
-  source.SerializeToString(&data);
-
-  // Parse using WireFormat.
-  io::ArrayInputStream raw_input(data.data(), data.size());
-  io::CodedInputStream input(&raw_input);
-  WireFormat::ParseAndMergePartial(&input, &dest);
-
-  // Check.
-  TestUtil::ExpectOneofSet1(dest);
-}
-
-TEST(WireFormatTest, OneofOnlySetLast) {
-  unittest::TestOneofBackwardsCompatible source;
-  unittest::TestOneof oneof_dest;
-  std::string data;
-
-  // Set two fields
-  source.set_foo_int(100);
-  source.set_foo_string("101");
-
-  // Serialize and parse to oneof message. Generated serializer may not order
-  // fields in tag order. Use WireFormat::SerializeWithCachedSizes instead as
-  // it sorts fields beforehand.
-  {
-    io::StringOutputStream raw_output(&data);
-    io::CodedOutputStream output(&raw_output);
-    WireFormat::SerializeWithCachedSizes(source, source.ByteSizeLong(),
-                                         &output);
-    ASSERT_FALSE(output.HadError());
-  }
-  io::ArrayInputStream raw_input(data.data(), data.size());
-  io::CodedInputStream input(&raw_input);
-  WireFormat::ParseAndMergePartial(&input, &oneof_dest);
-
-  // Only the last field is set.
-  EXPECT_FALSE(oneof_dest.has_foo_int());
-  EXPECT_TRUE(oneof_dest.has_foo_string());
-}
-
-TEST(WireFormatTest, ByteSize) {
-  unittest::TestAllTypes message;
-  TestUtil::SetAllFields(&message);
-
-  EXPECT_EQ(message.ByteSizeLong(), WireFormat::ByteSize(message));
-  message.Clear();
-  EXPECT_EQ(0, message.ByteSizeLong());
-  EXPECT_EQ(0, WireFormat::ByteSize(message));
-}
-
-TEST(WireFormatTest, ByteSizeExtensions) {
-  unittest::TestAllExtensions message;
-  TestUtil::SetAllExtensions(&message);
-
-  EXPECT_EQ(message.ByteSizeLong(), WireFormat::ByteSize(message));
-  message.Clear();
-  EXPECT_EQ(0, message.ByteSizeLong());
-  EXPECT_EQ(0, WireFormat::ByteSize(message));
-}
-
-TEST(WireFormatTest, ByteSizePacked) {
-  unittest::TestPackedTypes message;
-  TestUtil::SetPackedFields(&message);
-
-  EXPECT_EQ(message.ByteSizeLong(), WireFormat::ByteSize(message));
-  message.Clear();
-  EXPECT_EQ(0, message.ByteSizeLong());
-  EXPECT_EQ(0, WireFormat::ByteSize(message));
-}
-
-TEST(WireFormatTest, ByteSizePackedExtensions) {
-  unittest::TestPackedExtensions message;
-  TestUtil::SetPackedExtensions(&message);
-
-  EXPECT_EQ(message.ByteSizeLong(), WireFormat::ByteSize(message));
-  message.Clear();
-  EXPECT_EQ(0, message.ByteSizeLong());
-  EXPECT_EQ(0, WireFormat::ByteSize(message));
-}
-
-TEST(WireFormatTest, ByteSizeOneof) {
-  unittest::TestOneof2 message;
-  TestUtil::SetOneof1(&message);
-
-  EXPECT_EQ(message.ByteSizeLong(), WireFormat::ByteSize(message));
-  message.Clear();
-
-  EXPECT_EQ(0, message.ByteSizeLong());
-  EXPECT_EQ(0, WireFormat::ByteSize(message));
-}
-
-TEST(WireFormatTest, Serialize) {
-  unittest::TestAllTypes message;
-  std::string generated_data;
-  std::string dynamic_data;
-
-  TestUtil::SetAllFields(&message);
-  size_t size = message.ByteSizeLong();
-
-  // Serialize using the generated code.
-  {
-    io::StringOutputStream raw_output(&generated_data);
-    io::CodedOutputStream output(&raw_output);
-    message.SerializeWithCachedSizes(&output);
-    ASSERT_FALSE(output.HadError());
-  }
-
-  // Serialize using WireFormat.
-  {
-    io::StringOutputStream raw_output(&dynamic_data);
-    io::CodedOutputStream output(&raw_output);
-    WireFormat::SerializeWithCachedSizes(message, size, &output);
-    ASSERT_FALSE(output.HadError());
-  }
-
-  // Should parse to the same message.
-  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, generated_data));
-  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, dynamic_data));
-}
-
-TEST(WireFormatTest, SerializeExtensions) {
-  unittest::TestAllExtensions message;
-  std::string generated_data;
-  std::string dynamic_data;
-
-  TestUtil::SetAllExtensions(&message);
-  size_t size = message.ByteSizeLong();
-
-  // Serialize using the generated code.
-  {
-    io::StringOutputStream raw_output(&generated_data);
-    io::CodedOutputStream output(&raw_output);
-    message.SerializeWithCachedSizes(&output);
-    ASSERT_FALSE(output.HadError());
-  }
-
-  // Serialize using WireFormat.
-  {
-    io::StringOutputStream raw_output(&dynamic_data);
-    io::CodedOutputStream output(&raw_output);
-    WireFormat::SerializeWithCachedSizes(message, size, &output);
-    ASSERT_FALSE(output.HadError());
-  }
-
-  // Should parse to the same message.
-  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, generated_data));
-  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, dynamic_data));
-}
-
-TEST(WireFormatTest, SerializeFieldsAndExtensions) {
-  unittest::TestFieldOrderings message;
-  std::string generated_data;
-  std::string dynamic_data;
-
-  TestUtil::SetAllFieldsAndExtensions(&message);
-  size_t size = message.ByteSizeLong();
-
-  // Serialize using the generated code.
-  {
-    io::StringOutputStream raw_output(&generated_data);
-    io::CodedOutputStream output(&raw_output);
-    message.SerializeWithCachedSizes(&output);
-    ASSERT_FALSE(output.HadError());
-  }
-
-  // Serialize using WireFormat.
-  {
-    io::StringOutputStream raw_output(&dynamic_data);
-    io::CodedOutputStream output(&raw_output);
-    WireFormat::SerializeWithCachedSizes(message, size, &output);
-    ASSERT_FALSE(output.HadError());
-  }
-
-  // Should parse to the same message.
-  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, generated_data));
-  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, dynamic_data));
-}
-
-TEST(WireFormatTest, SerializeOneof) {
-  unittest::TestOneof2 message;
-  std::string generated_data;
-  std::string dynamic_data;
-
-  TestUtil::SetOneof1(&message);
-  size_t size = message.ByteSizeLong();
-
-  // Serialize using the generated code.
-  {
-    io::StringOutputStream raw_output(&generated_data);
-    io::CodedOutputStream output(&raw_output);
-    message.SerializeWithCachedSizes(&output);
-    ASSERT_FALSE(output.HadError());
-  }
-
-  // Serialize using WireFormat.
-  {
-    io::StringOutputStream raw_output(&dynamic_data);
-    io::CodedOutputStream output(&raw_output);
-    WireFormat::SerializeWithCachedSizes(message, size, &output);
-    ASSERT_FALSE(output.HadError());
-  }
-
-  // Should parse to the same message.
-  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, generated_data));
-  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, dynamic_data));
-}
-
-TEST(WireFormatTest, ParseMultipleExtensionRanges) {
-  // Make sure we can parse a message that contains multiple extensions ranges.
-  unittest::TestFieldOrderings source;
-  std::string data;
-
-  TestUtil::SetAllFieldsAndExtensions(&source);
-  source.SerializeToString(&data);
-
-  {
-    unittest::TestFieldOrderings dest;
-    EXPECT_TRUE(dest.ParseFromString(data));
-    EXPECT_EQ(source.DebugString(), dest.DebugString());
-  }
-
-  // Also test using reflection-based parsing.
-  {
-    unittest::TestFieldOrderings dest;
-    io::ArrayInputStream raw_input(data.data(), data.size());
-    io::CodedInputStream coded_input(&raw_input);
-    EXPECT_TRUE(WireFormat::ParseAndMergePartial(&coded_input, &dest));
-    EXPECT_EQ(source.DebugString(), dest.DebugString());
-  }
-}
-
-const int kUnknownTypeId = 1550055;
-
-TEST(WireFormatTest, SerializeMessageSet) {
-  // Set up a TestMessageSet with two known messages and an unknown one.
-  proto2_wireformat_unittest::TestMessageSet message_set;
-  message_set
-      .MutableExtension(
-          unittest::TestMessageSetExtension1::message_set_extension)
-      ->set_i(123);
-  message_set
-      .MutableExtension(
-          unittest::TestMessageSetExtension2::message_set_extension)
-      ->set_str("foo");
-  message_set.mutable_unknown_fields()->AddLengthDelimited(kUnknownTypeId,
-                                                           "bar");
-
-  std::string data;
-  ASSERT_TRUE(message_set.SerializeToString(&data));
-
-  // Parse back using RawMessageSet and check the contents.
-  unittest::RawMessageSet raw;
-  ASSERT_TRUE(raw.ParseFromString(data));
-
-  EXPECT_EQ(0, raw.unknown_fields().field_count());
-
-  ASSERT_EQ(3, raw.item_size());
-  EXPECT_EQ(
-      unittest::TestMessageSetExtension1::descriptor()->extension(0)->number(),
-      raw.item(0).type_id());
-  EXPECT_EQ(
-      unittest::TestMessageSetExtension2::descriptor()->extension(0)->number(),
-      raw.item(1).type_id());
-  EXPECT_EQ(kUnknownTypeId, raw.item(2).type_id());
-
-  unittest::TestMessageSetExtension1 message1;
-  EXPECT_TRUE(message1.ParseFromString(raw.item(0).message()));
-  EXPECT_EQ(123, message1.i());
-
-  unittest::TestMessageSetExtension2 message2;
-  EXPECT_TRUE(message2.ParseFromString(raw.item(1).message()));
-  EXPECT_EQ("foo", message2.str());
-
-  EXPECT_EQ("bar", raw.item(2).message());
-}
-
-TEST(WireFormatTest, SerializeMessageSetVariousWaysAreEqual) {
-  // Serialize a MessageSet to a stream and to a flat array using generated
-  // code, and also using WireFormat, and check that the results are equal.
-  // Set up a TestMessageSet with two known messages and an unknown one, as
-  // above.
-
-  proto2_wireformat_unittest::TestMessageSet message_set;
-  message_set
-      .MutableExtension(
-          unittest::TestMessageSetExtension1::message_set_extension)
-      ->set_i(123);
-  message_set
-      .MutableExtension(
-          unittest::TestMessageSetExtension2::message_set_extension)
-      ->set_str("foo");
-  message_set.mutable_unknown_fields()->AddLengthDelimited(kUnknownTypeId,
-                                                           "bar");
-
-  size_t size = message_set.ByteSizeLong();
-  EXPECT_EQ(size, message_set.GetCachedSize());
-  ASSERT_EQ(size, WireFormat::ByteSize(message_set));
-
-  std::string flat_data;
-  std::string stream_data;
-  std::string dynamic_data;
-  flat_data.resize(size);
-  stream_data.resize(size);
-
-  // Serialize to flat array
-  {
-    uint8* target = reinterpret_cast<uint8*>(::google::protobuf::string_as_array(&flat_data));
-    uint8* end = message_set.SerializeWithCachedSizesToArray(target);
-    EXPECT_EQ(size, end - target);
-  }
-
-  // Serialize to buffer
-  {
-    io::ArrayOutputStream array_stream(::google::protobuf::string_as_array(&stream_data), size,
-                                       1);
-    io::CodedOutputStream output_stream(&array_stream);
-    message_set.SerializeWithCachedSizes(&output_stream);
-    ASSERT_FALSE(output_stream.HadError());
-  }
-
-  // Serialize to buffer with WireFormat.
-  {
-    io::StringOutputStream string_stream(&dynamic_data);
-    io::CodedOutputStream output_stream(&string_stream);
-    WireFormat::SerializeWithCachedSizes(message_set, size, &output_stream);
-    ASSERT_FALSE(output_stream.HadError());
-  }
-
-  EXPECT_TRUE(flat_data == stream_data);
-  EXPECT_TRUE(flat_data == dynamic_data);
-}
-
-TEST(WireFormatTest, ParseMessageSet) {
-  // Set up a RawMessageSet with two known messages and an unknown one.
-  unittest::RawMessageSet raw;
-
-  {
-    unittest::RawMessageSet::Item* item = raw.add_item();
-    item->set_type_id(unittest::TestMessageSetExtension1::descriptor()
-                          ->extension(0)
-                          ->number());
-    unittest::TestMessageSetExtension1 message;
-    message.set_i(123);
-    message.SerializeToString(item->mutable_message());
-  }
-
-  {
-    unittest::RawMessageSet::Item* item = raw.add_item();
-    item->set_type_id(unittest::TestMessageSetExtension2::descriptor()
-                          ->extension(0)
-                          ->number());
-    unittest::TestMessageSetExtension2 message;
-    message.set_str("foo");
-    message.SerializeToString(item->mutable_message());
-  }
-
-  {
-    unittest::RawMessageSet::Item* item = raw.add_item();
-    item->set_type_id(kUnknownTypeId);
-    item->set_message("bar");
-  }
-
-  std::string data;
-  ASSERT_TRUE(raw.SerializeToString(&data));
-
-  // Parse as a TestMessageSet and check the contents.
-  proto2_wireformat_unittest::TestMessageSet message_set;
-  ASSERT_TRUE(message_set.ParseFromString(data));
-
-  EXPECT_EQ(123,
-            message_set
-                .GetExtension(
-                    unittest::TestMessageSetExtension1::message_set_extension)
-                .i());
-  EXPECT_EQ("foo",
-            message_set
-                .GetExtension(
-                    unittest::TestMessageSetExtension2::message_set_extension)
-                .str());
-
-  ASSERT_EQ(1, message_set.unknown_fields().field_count());
-  ASSERT_EQ(UnknownField::TYPE_LENGTH_DELIMITED,
-            message_set.unknown_fields().field(0).type());
-  EXPECT_EQ("bar", message_set.unknown_fields().field(0).length_delimited());
-
-  // Also parse using WireFormat.
-  proto2_wireformat_unittest::TestMessageSet dynamic_message_set;
-  io::CodedInputStream input(reinterpret_cast<const uint8*>(data.data()),
-                             data.size());
-  ASSERT_TRUE(WireFormat::ParseAndMergePartial(&input, &dynamic_message_set));
-  EXPECT_EQ(message_set.DebugString(), dynamic_message_set.DebugString());
-}
-
-TEST(WireFormatTest, ParseMessageSetWithReverseTagOrder) {
-  std::string data;
-  {
-    unittest::TestMessageSetExtension1 message;
-    message.set_i(123);
-    // Build a MessageSet manually with its message content put before its
-    // type_id.
-    io::StringOutputStream output_stream(&data);
-    io::CodedOutputStream coded_output(&output_stream);
-    coded_output.WriteTag(WireFormatLite::kMessageSetItemStartTag);
-    // Write the message content first.
-    WireFormatLite::WriteTag(WireFormatLite::kMessageSetMessageNumber,
-                             WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
-                             &coded_output);
-    coded_output.WriteVarint32(message.ByteSizeLong());
-    message.SerializeWithCachedSizes(&coded_output);
-    // Write the type id.
-    uint32 type_id = message.GetDescriptor()->extension(0)->number();
-    WireFormatLite::WriteUInt32(WireFormatLite::kMessageSetTypeIdNumber,
-                                type_id, &coded_output);
-    coded_output.WriteTag(WireFormatLite::kMessageSetItemEndTag);
-  }
-  {
-    proto2_wireformat_unittest::TestMessageSet message_set;
-    ASSERT_TRUE(message_set.ParseFromString(data));
-
-    EXPECT_EQ(123,
-              message_set
-                  .GetExtension(
-                      unittest::TestMessageSetExtension1::message_set_extension)
-                  .i());
-  }
-  {
-    // Test parse the message via Reflection.
-    proto2_wireformat_unittest::TestMessageSet message_set;
-    io::CodedInputStream input(reinterpret_cast<const uint8*>(data.data()),
-                               data.size());
-    EXPECT_TRUE(WireFormat::ParseAndMergePartial(&input, &message_set));
-    EXPECT_TRUE(input.ConsumedEntireMessage());
-
-    EXPECT_EQ(123,
-              message_set
-                  .GetExtension(
-                      unittest::TestMessageSetExtension1::message_set_extension)
-                  .i());
-  }
-}
-
-void SerializeReverseOrder(
-    const proto2_wireformat_unittest::TestMessageSet& mset,
-    io::CodedOutputStream* coded_output);
-
-void SerializeReverseOrder(const unittest::TestMessageSetExtension1& message,
-                           io::CodedOutputStream* coded_output) {
-  WireFormatLite::WriteTag(15,  // i
-                           WireFormatLite::WIRETYPE_VARINT, coded_output);
-  coded_output->WriteVarint64(message.i());
-  WireFormatLite::WriteTag(16,  // recursive
-                           WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
-                           coded_output);
-  coded_output->WriteVarint32(message.recursive().GetCachedSize());
-  SerializeReverseOrder(message.recursive(), coded_output);
-}
-
-void SerializeReverseOrder(
-    const proto2_wireformat_unittest::TestMessageSet& mset,
-    io::CodedOutputStream* coded_output) {
-  if (!mset.HasExtension(
-          unittest::TestMessageSetExtension1::message_set_extension))
-    return;
-  coded_output->WriteTag(WireFormatLite::kMessageSetItemStartTag);
-  // Write the message content first.
-  WireFormatLite::WriteTag(WireFormatLite::kMessageSetMessageNumber,
-                           WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
-                           coded_output);
-  auto& message = mset.GetExtension(
-      unittest::TestMessageSetExtension1::message_set_extension);
-  coded_output->WriteVarint32(message.GetCachedSize());
-  SerializeReverseOrder(message, coded_output);
-  // Write the type id.
-  uint32 type_id = message.GetDescriptor()->extension(0)->number();
-  WireFormatLite::WriteUInt32(WireFormatLite::kMessageSetTypeIdNumber, type_id,
-                              coded_output);
-  coded_output->WriteTag(WireFormatLite::kMessageSetItemEndTag);
-}
-
-TEST(WireFormatTest, ParseMessageSetWithDeepRecReverseOrder) {
-  std::string data;
-  {
-    proto2_wireformat_unittest::TestMessageSet message_set;
-    proto2_wireformat_unittest::TestMessageSet* mset = &message_set;
-    for (int i = 0; i < 200; i++) {
-      auto m = mset->MutableExtension(
-          unittest::TestMessageSetExtension1::message_set_extension);
-      m->set_i(i);
-      mset = m->mutable_recursive();
-    }
-    message_set.ByteSizeLong();
-    // Serialize with reverse payload tag order
-    io::StringOutputStream output_stream(&data);
-    io::CodedOutputStream coded_output(&output_stream);
-    SerializeReverseOrder(message_set, &coded_output);
-  }
-  proto2_wireformat_unittest::TestMessageSet message_set;
-  EXPECT_FALSE(message_set.ParseFromString(data));
-}
-
-TEST(WireFormatTest, ParseFailMalformedMessageSet) {
-  constexpr int kDepth = 5;
-  std::string data;
-  {
-    proto2_wireformat_unittest::TestMessageSet message_set;
-    proto2_wireformat_unittest::TestMessageSet* mset = &message_set;
-    for (int i = 0; i < kDepth; i++) {
-      auto m = mset->MutableExtension(
-          unittest::TestMessageSetExtension1::message_set_extension);
-      m->set_i(i);
-      mset = m->mutable_recursive();
-    }
-    auto m = mset->MutableExtension(
-        unittest::TestMessageSetExtension1::message_set_extension);
-    // -1 becomes \xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x1
-    m->set_i(-1);
-
-    EXPECT_TRUE(message_set.SerializeToString(&data));
-    // Make the proto mal-formed.
-    data[data.size() - 2 - kDepth] = 0xFF;
-  }
-
-  proto2_wireformat_unittest::TestMessageSet message_set;
-  EXPECT_FALSE(message_set.ParseFromString(data));
-}
-
-TEST(WireFormatTest, ParseFailMalformedMessageSetReverseOrder) {
-  constexpr int kDepth = 5;
-  std::string data;
-  {
-    proto2_wireformat_unittest::TestMessageSet message_set;
-    proto2_wireformat_unittest::TestMessageSet* mset = &message_set;
-    for (int i = 0; i < kDepth; i++) {
-      auto m = mset->MutableExtension(
-          unittest::TestMessageSetExtension1::message_set_extension);
-      m->set_i(i);
-      mset = m->mutable_recursive();
-    }
-    auto m = mset->MutableExtension(
-        unittest::TestMessageSetExtension1::message_set_extension);
-    // -1 becomes \xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x1
-    m->set_i(-1);
-    // SerializeReverseOrder() assumes "recursive" is always present.
-    m->mutable_recursive();
-
-    message_set.ByteSizeLong();
-
-    // Serialize with reverse payload tag order
-    io::StringOutputStream output_stream(&data);
-    io::CodedOutputStream coded_output(&output_stream);
-    SerializeReverseOrder(message_set, &coded_output);
-  }
-
-  // Make varint for -1 malformed.
-  data[data.size() - 5 * (kDepth + 1) - 4] = 0xFF;
-
-  proto2_wireformat_unittest::TestMessageSet message_set;
-  EXPECT_FALSE(message_set.ParseFromString(data));
-}
-
-TEST(WireFormatTest, ParseBrokenMessageSet) {
-  proto2_wireformat_unittest::TestMessageSet message_set;
-  std::string input("goodbye");  // Invalid wire format data.
-  EXPECT_FALSE(message_set.ParseFromString(input));
-}
-
-TEST(WireFormatTest, RecursionLimit) {
-  unittest::TestRecursiveMessage message;
-  message.mutable_a()->mutable_a()->mutable_a()->mutable_a()->set_i(1);
-  std::string data;
-  message.SerializeToString(&data);
-
-  {
-    io::ArrayInputStream raw_input(data.data(), data.size());
-    io::CodedInputStream input(&raw_input);
-    input.SetRecursionLimit(4);
-    unittest::TestRecursiveMessage message2;
-    EXPECT_TRUE(message2.ParseFromCodedStream(&input));
-  }
-
-  {
-    io::ArrayInputStream raw_input(data.data(), data.size());
-    io::CodedInputStream input(&raw_input);
-    input.SetRecursionLimit(3);
-    unittest::TestRecursiveMessage message2;
-    EXPECT_FALSE(message2.ParseFromCodedStream(&input));
-  }
-}
-
-TEST(WireFormatTest, UnknownFieldRecursionLimit) {
-  unittest::TestEmptyMessage message;
-  message.mutable_unknown_fields()
-      ->AddGroup(1234)
-      ->AddGroup(1234)
-      ->AddGroup(1234)
-      ->AddGroup(1234)
-      ->AddVarint(1234, 123);
-  std::string data;
-  message.SerializeToString(&data);
-
-  {
-    io::ArrayInputStream raw_input(data.data(), data.size());
-    io::CodedInputStream input(&raw_input);
-    input.SetRecursionLimit(4);
-    unittest::TestEmptyMessage message2;
-    EXPECT_TRUE(message2.ParseFromCodedStream(&input));
-  }
-
-  {
-    io::ArrayInputStream raw_input(data.data(), data.size());
-    io::CodedInputStream input(&raw_input);
-    input.SetRecursionLimit(3);
-    unittest::TestEmptyMessage message2;
-    EXPECT_FALSE(message2.ParseFromCodedStream(&input));
-  }
-}
-
-TEST(WireFormatTest, ZigZag) {
-// avoid line-wrapping
-#define LL(x) static_cast<int64_t>(ULL(x))
-#define ULL(x) uint64_t{x##u}
-#define ZigZagEncode32(x) WireFormatLite::ZigZagEncode32(x)
-#define ZigZagDecode32(x) WireFormatLite::ZigZagDecode32(x)
-#define ZigZagEncode64(x) WireFormatLite::ZigZagEncode64(x)
-#define ZigZagDecode64(x) WireFormatLite::ZigZagDecode64(x)
-
-  EXPECT_EQ(0u, ZigZagEncode32(0));
-  EXPECT_EQ(1u, ZigZagEncode32(-1));
-  EXPECT_EQ(2u, ZigZagEncode32(1));
-  EXPECT_EQ(3u, ZigZagEncode32(-2));
-  EXPECT_EQ(0x7FFFFFFEu, ZigZagEncode32(0x3FFFFFFF));
-  EXPECT_EQ(0x7FFFFFFFu, ZigZagEncode32(0xC0000000));
-  EXPECT_EQ(0xFFFFFFFEu, ZigZagEncode32(0x7FFFFFFF));
-  EXPECT_EQ(0xFFFFFFFFu, ZigZagEncode32(0x80000000));
-
-  EXPECT_EQ(0, ZigZagDecode32(0u));
-  EXPECT_EQ(-1, ZigZagDecode32(1u));
-  EXPECT_EQ(1, ZigZagDecode32(2u));
-  EXPECT_EQ(-2, ZigZagDecode32(3u));
-  EXPECT_EQ(0x3FFFFFFF, ZigZagDecode32(0x7FFFFFFEu));
-  EXPECT_EQ(0xC0000000, ZigZagDecode32(0x7FFFFFFFu));
-  EXPECT_EQ(0x7FFFFFFF, ZigZagDecode32(0xFFFFFFFEu));
-  EXPECT_EQ(0x80000000, ZigZagDecode32(0xFFFFFFFFu));
-
-  EXPECT_EQ(0u, ZigZagEncode64(0));
-  EXPECT_EQ(1u, ZigZagEncode64(-1));
-  EXPECT_EQ(2u, ZigZagEncode64(1));
-  EXPECT_EQ(3u, ZigZagEncode64(-2));
-  EXPECT_EQ(ULL(0x000000007FFFFFFE), ZigZagEncode64(LL(0x000000003FFFFFFF)));
-  EXPECT_EQ(ULL(0x000000007FFFFFFF), ZigZagEncode64(LL(0xFFFFFFFFC0000000)));
-  EXPECT_EQ(ULL(0x00000000FFFFFFFE), ZigZagEncode64(LL(0x000000007FFFFFFF)));
-  EXPECT_EQ(ULL(0x00000000FFFFFFFF), ZigZagEncode64(LL(0xFFFFFFFF80000000)));
-  EXPECT_EQ(ULL(0xFFFFFFFFFFFFFFFE), ZigZagEncode64(LL(0x7FFFFFFFFFFFFFFF)));
-  EXPECT_EQ(ULL(0xFFFFFFFFFFFFFFFF), ZigZagEncode64(LL(0x8000000000000000)));
-
-  EXPECT_EQ(0, ZigZagDecode64(0u));
-  EXPECT_EQ(-1, ZigZagDecode64(1u));
-  EXPECT_EQ(1, ZigZagDecode64(2u));
-  EXPECT_EQ(-2, ZigZagDecode64(3u));
-  EXPECT_EQ(LL(0x000000003FFFFFFF), ZigZagDecode64(ULL(0x000000007FFFFFFE)));
-  EXPECT_EQ(LL(0xFFFFFFFFC0000000), ZigZagDecode64(ULL(0x000000007FFFFFFF)));
-  EXPECT_EQ(LL(0x000000007FFFFFFF), ZigZagDecode64(ULL(0x00000000FFFFFFFE)));
-  EXPECT_EQ(LL(0xFFFFFFFF80000000), ZigZagDecode64(ULL(0x00000000FFFFFFFF)));
-  EXPECT_EQ(LL(0x7FFFFFFFFFFFFFFF), ZigZagDecode64(ULL(0xFFFFFFFFFFFFFFFE)));
-  EXPECT_EQ(LL(0x8000000000000000), ZigZagDecode64(ULL(0xFFFFFFFFFFFFFFFF)));
-
-  // Some easier-to-verify round-trip tests.  The inputs (other than 0, 1, -1)
-  // were chosen semi-randomly via keyboard bashing.
-  EXPECT_EQ(0, ZigZagDecode32(ZigZagEncode32(0)));
-  EXPECT_EQ(1, ZigZagDecode32(ZigZagEncode32(1)));
-  EXPECT_EQ(-1, ZigZagDecode32(ZigZagEncode32(-1)));
-  EXPECT_EQ(14927, ZigZagDecode32(ZigZagEncode32(14927)));
-  EXPECT_EQ(-3612, ZigZagDecode32(ZigZagEncode32(-3612)));
-
-  EXPECT_EQ(0, ZigZagDecode64(ZigZagEncode64(0)));
-  EXPECT_EQ(1, ZigZagDecode64(ZigZagEncode64(1)));
-  EXPECT_EQ(-1, ZigZagDecode64(ZigZagEncode64(-1)));
-  EXPECT_EQ(14927, ZigZagDecode64(ZigZagEncode64(14927)));
-  EXPECT_EQ(-3612, ZigZagDecode64(ZigZagEncode64(-3612)));
-
-  EXPECT_EQ(LL(856912304801416),
-            ZigZagDecode64(ZigZagEncode64(LL(856912304801416))));
-  EXPECT_EQ(LL(-75123905439571256),
-            ZigZagDecode64(ZigZagEncode64(LL(-75123905439571256))));
-}
-
-TEST(WireFormatTest, RepeatedScalarsDifferentTagSizes) {
-  // At one point checks would trigger when parsing repeated fixed scalar
-  // fields.
-  protobuf_unittest::TestRepeatedScalarDifferentTagSizes msg1, msg2;
-  for (int i = 0; i < 100; ++i) {
-    msg1.add_repeated_fixed32(i);
-    msg1.add_repeated_int32(i);
-    msg1.add_repeated_fixed64(i);
-    msg1.add_repeated_int64(i);
-    msg1.add_repeated_float(i);
-    msg1.add_repeated_uint64(i);
-  }
-
-  // Make sure that we have a variety of tag sizes.
-  const Descriptor* desc = msg1.GetDescriptor();
-  const FieldDescriptor* field;
-  field = desc->FindFieldByName("repeated_fixed32");
-  ASSERT_TRUE(field != NULL);
-  ASSERT_EQ(1, WireFormat::TagSize(field->number(), field->type()));
-  field = desc->FindFieldByName("repeated_int32");
-  ASSERT_TRUE(field != NULL);
-  ASSERT_EQ(1, WireFormat::TagSize(field->number(), field->type()));
-  field = desc->FindFieldByName("repeated_fixed64");
-  ASSERT_TRUE(field != NULL);
-  ASSERT_EQ(2, WireFormat::TagSize(field->number(), field->type()));
-  field = desc->FindFieldByName("repeated_int64");
-  ASSERT_TRUE(field != NULL);
-  ASSERT_EQ(2, WireFormat::TagSize(field->number(), field->type()));
-  field = desc->FindFieldByName("repeated_float");
-  ASSERT_TRUE(field != NULL);
-  ASSERT_EQ(3, WireFormat::TagSize(field->number(), field->type()));
-  field = desc->FindFieldByName("repeated_uint64");
-  ASSERT_TRUE(field != NULL);
-  ASSERT_EQ(3, WireFormat::TagSize(field->number(), field->type()));
-
-  EXPECT_TRUE(msg2.ParseFromString(msg1.SerializeAsString()));
-  EXPECT_EQ(msg1.DebugString(), msg2.DebugString());
-}
-
-TEST(WireFormatTest, CompatibleTypes) {
-  const int64 data = 0x100000000LL;
-  unittest::Int64Message msg1;
-  msg1.set_data(data);
-  std::string serialized;
-  msg1.SerializeToString(&serialized);
-
-  // Test int64 is compatible with bool
-  unittest::BoolMessage msg2;
-  ASSERT_TRUE(msg2.ParseFromString(serialized));
-  ASSERT_EQ(static_cast<bool>(data), msg2.data());
-
-  // Test int64 is compatible with uint64
-  unittest::Uint64Message msg3;
-  ASSERT_TRUE(msg3.ParseFromString(serialized));
-  ASSERT_EQ(static_cast<uint64>(data), msg3.data());
-
-  // Test int64 is compatible with int32
-  unittest::Int32Message msg4;
-  ASSERT_TRUE(msg4.ParseFromString(serialized));
-  ASSERT_EQ(static_cast<int32>(data), msg4.data());
-
-  // Test int64 is compatible with uint32
-  unittest::Uint32Message msg5;
-  ASSERT_TRUE(msg5.ParseFromString(serialized));
-  ASSERT_EQ(static_cast<uint32>(data), msg5.data());
-}
-
-class Proto3PrimitiveRepeatedWireFormatTest : public ::testing::Test {
- protected:
-  Proto3PrimitiveRepeatedWireFormatTest()
-      : packedTestAllTypes_(
-            "\xFA\x01\x01\x01"
-            "\x82\x02\x01\x01"
-            "\x8A\x02\x01\x01"
-            "\x92\x02\x01\x01"
-            "\x9A\x02\x01\x02"
-            "\xA2\x02\x01\x02"
-            "\xAA\x02\x04\x01\x00\x00\x00"
-            "\xB2\x02\x08\x01\x00\x00\x00\x00\x00\x00\x00"
-            "\xBA\x02\x04\x01\x00\x00\x00"
-            "\xC2\x02\x08\x01\x00\x00\x00\x00\x00\x00\x00"
-            "\xCA\x02\x04\x00\x00\x80\x3f"
-            "\xD2\x02\x08\x00\x00\x00\x00\x00\x00\xf0\x3f"
-            "\xDA\x02\x01\x01"
-            "\x9A\x03\x01\x01",
-            86),
-        packedTestUnpackedTypes_(
-            "\x0A\x01\x01"
-            "\x12\x01\x01"
-            "\x1A\x01\x01"
-            "\x22\x01\x01"
-            "\x2A\x01\x02"
-            "\x32\x01\x02"
-            "\x3A\x04\x01\x00\x00\x00"
-            "\x42\x08\x01\x00\x00\x00\x00\x00\x00\x00"
-            "\x4A\x04\x01\x00\x00\x00"
-            "\x52\x08\x01\x00\x00\x00\x00\x00\x00\x00"
-            "\x5A\x04\x00\x00\x80\x3f"
-            "\x62\x08\x00\x00\x00\x00\x00\x00\xf0\x3f"
-            "\x6A\x01\x01"
-            "\x72\x01\x01",
-            72),
-        unpackedTestAllTypes_(
-            "\xF8\x01\x01"
-            "\x80\x02\x01"
-            "\x88\x02\x01"
-            "\x90\x02\x01"
-            "\x98\x02\x02"
-            "\xA0\x02\x02"
-            "\xAD\x02\x01\x00\x00\x00"
-            "\xB1\x02\x01\x00\x00\x00\x00\x00\x00\x00"
-            "\xBD\x02\x01\x00\x00\x00"
-            "\xC1\x02\x01\x00\x00\x00\x00\x00\x00\x00"
-            "\xCD\x02\x00\x00\x80\x3f"
-            "\xD1\x02\x00\x00\x00\x00\x00\x00\xf0\x3f"
-            "\xD8\x02\x01"
-            "\x98\x03\x01",
-            72),
-        unpackedTestUnpackedTypes_(
-            "\x08\x01"
-            "\x10\x01"
-            "\x18\x01"
-            "\x20\x01"
-            "\x28\x02"
-            "\x30\x02"
-            "\x3D\x01\x00\x00\x00"
-            "\x41\x01\x00\x00\x00\x00\x00\x00\x00"
-            "\x4D\x01\x00\x00\x00"
-            "\x51\x01\x00\x00\x00\x00\x00\x00\x00"
-            "\x5D\x00\x00\x80\x3f"
-            "\x61\x00\x00\x00\x00\x00\x00\xf0\x3f"
-            "\x68\x01"
-            "\x70\x01",
-            58) {}
-  template <class Proto>
-  void SetProto3PrimitiveRepeatedFields(Proto* message) {
-    message->add_repeated_int32(1);
-    message->add_repeated_int64(1);
-    message->add_repeated_uint32(1);
-    message->add_repeated_uint64(1);
-    message->add_repeated_sint32(1);
-    message->add_repeated_sint64(1);
-    message->add_repeated_fixed32(1);
-    message->add_repeated_fixed64(1);
-    message->add_repeated_sfixed32(1);
-    message->add_repeated_sfixed64(1);
-    message->add_repeated_float(1.0);
-    message->add_repeated_double(1.0);
-    message->add_repeated_bool(true);
-    message->add_repeated_nested_enum(proto3_arena_unittest::TestAllTypes::FOO);
-  }
-
-  template <class Proto>
-  void ExpectProto3PrimitiveRepeatedFieldsSet(const Proto& message) {
-    EXPECT_EQ(1, message.repeated_int32(0));
-    EXPECT_EQ(1, message.repeated_int64(0));
-    EXPECT_EQ(1, message.repeated_uint32(0));
-    EXPECT_EQ(1, message.repeated_uint64(0));
-    EXPECT_EQ(1, message.repeated_sint32(0));
-    EXPECT_EQ(1, message.repeated_sint64(0));
-    EXPECT_EQ(1, message.repeated_fixed32(0));
-    EXPECT_EQ(1, message.repeated_fixed64(0));
-    EXPECT_EQ(1, message.repeated_sfixed32(0));
-    EXPECT_EQ(1, message.repeated_sfixed64(0));
-    EXPECT_EQ(1.0, message.repeated_float(0));
-    EXPECT_EQ(1.0, message.repeated_double(0));
-    EXPECT_EQ(true, message.repeated_bool(0));
-    EXPECT_EQ(proto3_arena_unittest::TestAllTypes::FOO,
-              message.repeated_nested_enum(0));
-  }
-
-  template <class Proto>
-  void TestSerialization(Proto* message, const std::string& expected) {
-    SetProto3PrimitiveRepeatedFields(message);
-
-    size_t size = message->ByteSizeLong();
-
-    // Serialize using the generated code.
-    std::string generated_data;
-    {
-      io::StringOutputStream raw_output(&generated_data);
-      io::CodedOutputStream output(&raw_output);
-      message->SerializeWithCachedSizes(&output);
-      ASSERT_FALSE(output.HadError());
-    }
-    EXPECT_TRUE(TestUtil::EqualsToSerialized(*message, generated_data));
-
-    // Serialize using the dynamic code.
-    std::string dynamic_data;
-    {
-      io::StringOutputStream raw_output(&dynamic_data);
-      io::CodedOutputStream output(&raw_output);
-      WireFormat::SerializeWithCachedSizes(*message, size, &output);
-      ASSERT_FALSE(output.HadError());
-    }
-    EXPECT_TRUE(expected == dynamic_data);
-  }
-
-  template <class Proto>
-  void TestParsing(Proto* message, const std::string& compatible_data) {
-    message->Clear();
-    message->ParseFromString(compatible_data);
-    ExpectProto3PrimitiveRepeatedFieldsSet(*message);
-
-    message->Clear();
-    io::CodedInputStream input(
-        reinterpret_cast<const uint8*>(compatible_data.data()),
-        compatible_data.size());
-    WireFormat::ParseAndMergePartial(&input, message);
-    ExpectProto3PrimitiveRepeatedFieldsSet(*message);
-  }
-
-  const std::string packedTestAllTypes_;
-  const std::string packedTestUnpackedTypes_;
-  const std::string unpackedTestAllTypes_;
-  const std::string unpackedTestUnpackedTypes_;
-};
-
-TEST_F(Proto3PrimitiveRepeatedWireFormatTest, Proto3PrimitiveRepeated) {
-  proto3_arena_unittest::TestAllTypes packed_message;
-  proto3_arena_unittest::TestUnpackedTypes unpacked_message;
-  TestSerialization(&packed_message, packedTestAllTypes_);
-  TestParsing(&packed_message, packedTestAllTypes_);
-  TestParsing(&packed_message, unpackedTestAllTypes_);
-  TestSerialization(&unpacked_message, unpackedTestUnpackedTypes_);
-  TestParsing(&unpacked_message, packedTestUnpackedTypes_);
-  TestParsing(&unpacked_message, unpackedTestUnpackedTypes_);
-}
-
-class WireFormatInvalidInputTest : public testing::Test {
- protected:
-  // Make a serialized TestAllTypes in which the field optional_nested_message
-  // contains exactly the given bytes, which may be invalid.
-  std::string MakeInvalidEmbeddedMessage(const char* bytes, int size) {
-    const FieldDescriptor* field =
-        unittest::TestAllTypes::descriptor()->FindFieldByName(
-            "optional_nested_message");
-    GOOGLE_CHECK(field != NULL);
-
-    std::string result;
-
-    {
-      io::StringOutputStream raw_output(&result);
-      io::CodedOutputStream output(&raw_output);
-
-      WireFormatLite::WriteBytes(field->number(), std::string(bytes, size),
-                                 &output);
-    }
-
-    return result;
-  }
-
-  // Make a serialized TestAllTypes in which the field optionalgroup
-  // contains exactly the given bytes -- which may be invalid -- and
-  // possibly no end tag.
-  std::string MakeInvalidGroup(const char* bytes, int size,
-                               bool include_end_tag) {
-    const FieldDescriptor* field =
-        unittest::TestAllTypes::descriptor()->FindFieldByName("optionalgroup");
-    GOOGLE_CHECK(field != NULL);
-
-    std::string result;
-
-    {
-      io::StringOutputStream raw_output(&result);
-      io::CodedOutputStream output(&raw_output);
-
-      output.WriteVarint32(WireFormat::MakeTag(field));
-      output.WriteString(std::string(bytes, size));
-      if (include_end_tag) {
-        output.WriteVarint32(WireFormatLite::MakeTag(
-            field->number(), WireFormatLite::WIRETYPE_END_GROUP));
-      }
-    }
-
-    return result;
-  }
-};
-
-TEST_F(WireFormatInvalidInputTest, InvalidSubMessage) {
-  unittest::TestAllTypes message;
-
-  // Control case.
-  EXPECT_TRUE(message.ParseFromString(MakeInvalidEmbeddedMessage("", 0)));
-
-  // The byte is a valid varint, but not a valid tag (zero).
-  EXPECT_FALSE(message.ParseFromString(MakeInvalidEmbeddedMessage("\0", 1)));
-
-  // The byte is a malformed varint.
-  EXPECT_FALSE(message.ParseFromString(MakeInvalidEmbeddedMessage("\200", 1)));
-
-  // The byte is an endgroup tag, but we aren't parsing a group.
-  EXPECT_FALSE(message.ParseFromString(MakeInvalidEmbeddedMessage("\014", 1)));
-
-  // The byte is a valid varint but not a valid tag (bad wire type).
-  EXPECT_FALSE(message.ParseFromString(MakeInvalidEmbeddedMessage("\017", 1)));
-}
-
-TEST_F(WireFormatInvalidInputTest, InvalidMessageWithExtraZero) {
-  std::string data;
-  {
-    // Serialize a valid proto
-    unittest::TestAllTypes message;
-    message.set_optional_int32(1);
-    message.SerializeToString(&data);
-    data.push_back(0);  // Append invalid zero tag
-  }
-
-  // Control case.
-  {
-    io::ArrayInputStream ais(data.data(), data.size());
-    io::CodedInputStream is(&ais);
-    unittest::TestAllTypes message;
-    // It should fail but currently passes.
-    EXPECT_TRUE(message.MergePartialFromCodedStream(&is));
-    // Parsing from the string should fail.
-    EXPECT_FALSE(message.ParseFromString(data));
-  }
-}
-
-TEST_F(WireFormatInvalidInputTest, InvalidGroup) {
-  unittest::TestAllTypes message;
-
-  // Control case.
-  EXPECT_TRUE(message.ParseFromString(MakeInvalidGroup("", 0, true)));
-
-  // Missing end tag.  Groups cannot end at EOF.
-  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("", 0, false)));
-
-  // The byte is a valid varint, but not a valid tag (zero).
-  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("\0", 1, false)));
-
-  // The byte is a malformed varint.
-  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("\200", 1, false)));
-
-  // The byte is an endgroup tag, but not the right one for this group.
-  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("\014", 1, false)));
-
-  // The byte is a valid varint but not a valid tag (bad wire type).
-  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("\017", 1, true)));
-}
-
-TEST_F(WireFormatInvalidInputTest, InvalidUnknownGroup) {
-  // Use TestEmptyMessage so that the group made by MakeInvalidGroup will not
-  // be a known tag number.
-  unittest::TestEmptyMessage message;
-
-  // Control case.
-  EXPECT_TRUE(message.ParseFromString(MakeInvalidGroup("", 0, true)));
-
-  // Missing end tag.  Groups cannot end at EOF.
-  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("", 0, false)));
-
-  // The byte is a valid varint, but not a valid tag (zero).
-  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("\0", 1, false)));
-
-  // The byte is a malformed varint.
-  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("\200", 1, false)));
-
-  // The byte is an endgroup tag, but not the right one for this group.
-  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("\014", 1, false)));
-
-  // The byte is a valid varint but not a valid tag (bad wire type).
-  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("\017", 1, true)));
-}
-
-TEST_F(WireFormatInvalidInputTest, InvalidStringInUnknownGroup) {
-  // Test a bug fix:  SkipMessage should fail if the message contains a
-  // string whose length would extend beyond the message end.
-
-  unittest::TestAllTypes message;
-  message.set_optional_string("foo foo foo foo");
-  std::string data;
-  message.SerializeToString(&data);
-
-  // Chop some bytes off the end.
-  data.resize(data.size() - 4);
-
-  // Try to skip it.  Note that the bug was only present when parsing to an
-  // UnknownFieldSet.
-  io::ArrayInputStream raw_input(data.data(), data.size());
-  io::CodedInputStream coded_input(&raw_input);
-  UnknownFieldSet unknown_fields;
-  EXPECT_FALSE(WireFormat::SkipMessage(&coded_input, &unknown_fields));
-}
-
-// Test differences between string and bytes.
-// Value of a string type must be valid UTF-8 string.  When UTF-8
-// validation is enabled (GOOGLE_PROTOBUF_UTF8_VALIDATION_ENABLED):
-// WriteInvalidUTF8String:  see error message.
-// ReadInvalidUTF8String:  see error message.
-// WriteValidUTF8String: fine.
-// ReadValidUTF8String:  fine.
-// WriteAnyBytes: fine.
-// ReadAnyBytes: fine.
-const char* kInvalidUTF8String = "Invalid UTF-8: \xA0\xB0\xC0\xD0";
-// This used to be "Valid UTF-8: \x01\x02\u8C37\u6B4C", but MSVC seems to
-// interpret \u differently from GCC.
-const char* kValidUTF8String = "Valid UTF-8: \x01\x02\350\260\267\346\255\214";
-
-template <typename T>
-bool WriteMessage(const char* value, T* message, std::string* wire_buffer) {
-  message->set_data(value);
-  wire_buffer->clear();
-  message->AppendToString(wire_buffer);
-  return (wire_buffer->size() > 0);
-}
-
-template <typename T>
-bool ReadMessage(const std::string& wire_buffer, T* message) {
-  return message->ParseFromArray(wire_buffer.data(), wire_buffer.size());
-}
-
-class Utf8ValidationTest : public ::testing::Test {
- protected:
-  Utf8ValidationTest() {}
-  virtual ~Utf8ValidationTest() {}
-  virtual void SetUp() {
-  }
-
-};
-
-TEST_F(Utf8ValidationTest, WriteInvalidUTF8String) {
-  std::string wire_buffer;
-  protobuf_unittest::OneString input;
-  std::vector<std::string> errors;
-  {
-    ScopedMemoryLog log;
-    WriteMessage(kInvalidUTF8String, &input, &wire_buffer);
-    errors = log.GetMessages(ERROR);
-  }
-#ifdef GOOGLE_PROTOBUF_UTF8_VALIDATION_ENABLED
-  ASSERT_EQ(1, errors.size());
-  EXPECT_TRUE(
-      HasPrefixString(errors[0],
-                       "String field 'protobuf_unittest.OneString.data' "
-                       "contains invalid UTF-8 data when "
-                       "serializing a protocol buffer. Use the "
-                       "'bytes' type if you intend to send raw bytes."));
-#else
-  ASSERT_EQ(0, errors.size());
-#endif  // GOOGLE_PROTOBUF_UTF8_VALIDATION_ENABLED
-}
-
-
-TEST_F(Utf8ValidationTest, ReadInvalidUTF8String) {
-  std::string wire_buffer;
-  protobuf_unittest::OneString input;
-  WriteMessage(kInvalidUTF8String, &input, &wire_buffer);
-  protobuf_unittest::OneString output;
-  std::vector<std::string> errors;
-  {
-    ScopedMemoryLog log;
-    ReadMessage(wire_buffer, &output);
-    errors = log.GetMessages(ERROR);
-  }
-#ifdef GOOGLE_PROTOBUF_UTF8_VALIDATION_ENABLED
-  ASSERT_EQ(1, errors.size());
-  EXPECT_TRUE(
-      HasPrefixString(errors[0],
-                       "String field 'protobuf_unittest.OneString.data' "
-                       "contains invalid UTF-8 data when "
-                       "parsing a protocol buffer. Use the "
-                       "'bytes' type if you intend to send raw bytes."));
-
-#else
-  ASSERT_EQ(0, errors.size());
-#endif  // GOOGLE_PROTOBUF_UTF8_VALIDATION_ENABLED
-}
-
-
-TEST_F(Utf8ValidationTest, WriteValidUTF8String) {
-  std::string wire_buffer;
-  protobuf_unittest::OneString input;
-  std::vector<std::string> errors;
-  {
-    ScopedMemoryLog log;
-    WriteMessage(kValidUTF8String, &input, &wire_buffer);
-    errors = log.GetMessages(ERROR);
-  }
-  ASSERT_EQ(0, errors.size());
-}
-
-TEST_F(Utf8ValidationTest, ReadValidUTF8String) {
-  std::string wire_buffer;
-  protobuf_unittest::OneString input;
-  WriteMessage(kValidUTF8String, &input, &wire_buffer);
-  protobuf_unittest::OneString output;
-  std::vector<std::string> errors;
-  {
-    ScopedMemoryLog log;
-    ReadMessage(wire_buffer, &output);
-    errors = log.GetMessages(ERROR);
-  }
-  ASSERT_EQ(0, errors.size());
-  EXPECT_EQ(input.data(), output.data());
-}
-
-// Bytes: anything can pass as bytes, use invalid UTF-8 string to test
-TEST_F(Utf8ValidationTest, WriteArbitraryBytes) {
-  std::string wire_buffer;
-  protobuf_unittest::OneBytes input;
-  std::vector<std::string> errors;
-  {
-    ScopedMemoryLog log;
-    WriteMessage(kInvalidUTF8String, &input, &wire_buffer);
-    errors = log.GetMessages(ERROR);
-  }
-  ASSERT_EQ(0, errors.size());
-}
-
-TEST_F(Utf8ValidationTest, ReadArbitraryBytes) {
-  std::string wire_buffer;
-  protobuf_unittest::OneBytes input;
-  WriteMessage(kInvalidUTF8String, &input, &wire_buffer);
-  protobuf_unittest::OneBytes output;
-  std::vector<std::string> errors;
-  {
-    ScopedMemoryLog log;
-    ReadMessage(wire_buffer, &output);
-    errors = log.GetMessages(ERROR);
-  }
-  ASSERT_EQ(0, errors.size());
-  EXPECT_EQ(input.data(), output.data());
-}
-
-TEST_F(Utf8ValidationTest, ParseRepeatedString) {
-  protobuf_unittest::MoreBytes input;
-  input.add_data(kValidUTF8String);
-  input.add_data(kInvalidUTF8String);
-  input.add_data(kInvalidUTF8String);
-  std::string wire_buffer = input.SerializeAsString();
-
-  protobuf_unittest::MoreString output;
-  std::vector<std::string> errors;
-  {
-    ScopedMemoryLog log;
-    ReadMessage(wire_buffer, &output);
-    errors = log.GetMessages(ERROR);
-  }
-#ifdef GOOGLE_PROTOBUF_UTF8_VALIDATION_ENABLED
-  ASSERT_EQ(2, errors.size());
-#else
-  ASSERT_EQ(0, errors.size());
-#endif  // GOOGLE_PROTOBUF_UTF8_VALIDATION_ENABLED
-  EXPECT_EQ(wire_buffer, output.SerializeAsString());
-}
-
-// Test the old VerifyUTF8String() function, which may still be called by old
-// generated code.
-TEST_F(Utf8ValidationTest, OldVerifyUTF8String) {
-  std::string data(kInvalidUTF8String);
-
-  std::vector<std::string> errors;
-  {
-    ScopedMemoryLog log;
-    WireFormat::VerifyUTF8String(data.data(), data.size(),
-                                 WireFormat::SERIALIZE);
-    errors = log.GetMessages(ERROR);
-  }
-#ifdef GOOGLE_PROTOBUF_UTF8_VALIDATION_ENABLED
-  ASSERT_EQ(1, errors.size());
-  EXPECT_TRUE(
-      HasPrefixString(errors[0],
-                       "String field contains invalid UTF-8 data when "
-                       "serializing a protocol buffer. Use the "
-                       "'bytes' type if you intend to send raw bytes."));
-#else
-  ASSERT_EQ(0, errors.size());
-#endif
-}
-
-
-TEST(RepeatedVarint, Int32) {
-  RepeatedField<int32> v;
-
-  // Insert -2^n, 2^n and 2^n-1.
-  for (int n = 0; n < 10; n++) {
-    v.Add(-(1 << n));
-    v.Add(1 << n);
-    v.Add((1 << n) - 1);
-  }
-
-  // Check consistency with the scalar Int32Size.
-  size_t expected = 0;
-  for (int i = 0; i < v.size(); i++) {
-    expected += WireFormatLite::Int32Size(v[i]);
-  }
-
-  EXPECT_EQ(expected, WireFormatLite::Int32Size(v));
-}
-
-TEST(RepeatedVarint, Int64) {
-  RepeatedField<int64> v;
-
-  // Insert -2^n, 2^n and 2^n-1.
-  for (int n = 0; n < 10; n++) {
-    v.Add(-(1 << n));
-    v.Add(1 << n);
-    v.Add((1 << n) - 1);
-  }
-
-  // Check consistency with the scalar Int64Size.
-  size_t expected = 0;
-  for (int i = 0; i < v.size(); i++) {
-    expected += WireFormatLite::Int64Size(v[i]);
-  }
-
-  EXPECT_EQ(expected, WireFormatLite::Int64Size(v));
-}
-
-TEST(RepeatedVarint, SInt32) {
-  RepeatedField<int32> v;
-
-  // Insert -2^n, 2^n and 2^n-1.
-  for (int n = 0; n < 10; n++) {
-    v.Add(-(1 << n));
-    v.Add(1 << n);
-    v.Add((1 << n) - 1);
-  }
-
-  // Check consistency with the scalar SInt32Size.
-  size_t expected = 0;
-  for (int i = 0; i < v.size(); i++) {
-    expected += WireFormatLite::SInt32Size(v[i]);
-  }
-
-  EXPECT_EQ(expected, WireFormatLite::SInt32Size(v));
-}
-
-TEST(RepeatedVarint, SInt64) {
-  RepeatedField<int64> v;
-
-  // Insert -2^n, 2^n and 2^n-1.
-  for (int n = 0; n < 10; n++) {
-    v.Add(-(1 << n));
-    v.Add(1 << n);
-    v.Add((1 << n) - 1);
-  }
-
-  // Check consistency with the scalar SInt64Size.
-  size_t expected = 0;
-  for (int i = 0; i < v.size(); i++) {
-    expected += WireFormatLite::SInt64Size(v[i]);
-  }
-
-  EXPECT_EQ(expected, WireFormatLite::SInt64Size(v));
-}
-
-TEST(RepeatedVarint, UInt32) {
-  RepeatedField<uint32> v;
-
-  // Insert 2^n and 2^n-1.
-  for (int n = 0; n < 10; n++) {
-    v.Add(1 << n);
-    v.Add((1 << n) - 1);
-  }
-
-  // Check consistency with the scalar UInt32Size.
-  size_t expected = 0;
-  for (int i = 0; i < v.size(); i++) {
-    expected += WireFormatLite::UInt32Size(v[i]);
-  }
-
-  EXPECT_EQ(expected, WireFormatLite::UInt32Size(v));
-}
-
-TEST(RepeatedVarint, UInt64) {
-  RepeatedField<uint64> v;
-
-  // Insert 2^n and 2^n-1.
-  for (int n = 0; n < 10; n++) {
-    v.Add(1 << n);
-    v.Add((1 << n) - 1);
-  }
-
-  // Check consistency with the scalar UInt64Size.
-  size_t expected = 0;
-  for (int i = 0; i < v.size(); i++) {
-    expected += WireFormatLite::UInt64Size(v[i]);
-  }
-
-  EXPECT_EQ(expected, WireFormatLite::UInt64Size(v));
-}
-
-TEST(RepeatedVarint, Enum) {
-  RepeatedField<int> v;
-
-  // Insert 2^n and 2^n-1.
-  for (int n = 0; n < 10; n++) {
-    v.Add(1 << n);
-    v.Add((1 << n) - 1);
-  }
-
-  // Check consistency with the scalar EnumSize.
-  size_t expected = 0;
-  for (int i = 0; i < v.size(); i++) {
-    expected += WireFormatLite::EnumSize(v[i]);
-  }
-
-  EXPECT_EQ(expected, WireFormatLite::EnumSize(v));
-}
-
 
 }  // namespace
 }  // namespace internal
diff --git protobuf-3.17.3protobuf-3.17.3-patched/src/google/protobuf/wire_format_unittest.inc protobuf-3.17.3-patchedprotobuf-3.17.3-patched/src/google/protobuf/wire_format_unittest.inc
new file mode 100644
index 0000000..4218374
--- /dev/null
+++ protobuf-3.17.3-patchedprotobuf-3.17.3-patched/src/google/protobuf/wire_format_unittest.inc
@@ -0,0 +1,1710 @@
+// Protocol Buffers - Google's data interchange format
+// Copyright 2008 Google Inc.  All rights reserved.
+// https://developers.google.com/protocol-buffers/
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// Author: kenton@google.com (Kenton Varda)
+//  Based on original Protocol Buffers design by
+//  Sanjay Ghemawat, Jeff Dean, and others.
+
+#include <google/protobuf/wire_format.h>
+
+#include <google/protobuf/stubs/logging.h>
+#include <google/protobuf/stubs/common.h>
+#include <google/protobuf/test_util2.h>
+#include <google/protobuf/io/coded_stream.h>
+#include <google/protobuf/io/zero_copy_stream_impl.h>
+#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
+#include <google/protobuf/descriptor.h>
+#include <google/protobuf/wire_format_lite.h>
+#include <google/protobuf/testing/googletest.h>
+#include <google/protobuf/stubs/logging.h>
+#include <gmock/gmock.h>
+#include <gtest/gtest.h>
+#include <google/protobuf/stubs/casts.h>
+#include <google/protobuf/stubs/strutil.h>
+#include <google/protobuf/stubs/stl_util.h>
+#include <google/protobuf/dynamic_message.h>
+
+// clang-format off
+#include <google/protobuf/port_def.inc>
+// clang-format on
+
+namespace google {
+namespace protobuf {
+namespace internal {
+namespace {
+
+TEST(WireFormatTest, EnumsInSync) {
+  // Verify that WireFormatLite::FieldType and WireFormatLite::CppType match
+  // FieldDescriptor::Type and FieldDescriptor::CppType.
+
+  EXPECT_EQ(implicit_cast<int>(FieldDescriptor::MAX_TYPE),
+            implicit_cast<int>(WireFormatLite::MAX_FIELD_TYPE));
+  EXPECT_EQ(implicit_cast<int>(FieldDescriptor::MAX_CPPTYPE),
+            implicit_cast<int>(WireFormatLite::MAX_CPPTYPE));
+
+  for (int i = 1; i <= WireFormatLite::MAX_FIELD_TYPE; i++) {
+    EXPECT_EQ(implicit_cast<int>(FieldDescriptor::TypeToCppType(
+                  static_cast<FieldDescriptor::Type>(i))),
+              implicit_cast<int>(WireFormatLite::FieldTypeToCppType(
+                  static_cast<WireFormatLite::FieldType>(i))));
+  }
+}
+
+TEST(WireFormatTest, MaxFieldNumber) {
+  // Make sure the max field number constant is accurate.
+  EXPECT_EQ((1 << (32 - WireFormatLite::kTagTypeBits)) - 1,
+            FieldDescriptor::kMaxNumber);
+}
+
+TEST(WireFormatTest, Parse) {
+  UNITTEST::TestAllTypes source, dest;
+  std::string data;
+
+  // Serialize using the generated code.
+  TestUtil::SetAllFields(&source);
+  source.SerializeToString(&data);
+
+  // Parse using WireFormat.
+  io::ArrayInputStream raw_input(data.data(), data.size());
+  io::CodedInputStream input(&raw_input);
+  WireFormat::ParseAndMergePartial(&input, &dest);
+
+  // Check.
+  TestUtil::ExpectAllFieldsSet(dest);
+}
+
+TEST(WireFormatTest, ParseExtensions) {
+  UNITTEST::TestAllExtensions source, dest;
+  std::string data;
+
+  // Serialize using the generated code.
+  TestUtil::SetAllExtensions(&source);
+  source.SerializeToString(&data);
+
+  // Parse using WireFormat.
+  io::ArrayInputStream raw_input(data.data(), data.size());
+  io::CodedInputStream input(&raw_input);
+  WireFormat::ParseAndMergePartial(&input, &dest);
+
+  // Check.
+  TestUtil::ExpectAllExtensionsSet(dest);
+}
+
+TEST(WireFormatTest, ParsePacked) {
+  UNITTEST::TestPackedTypes source, dest;
+  std::string data;
+
+  // Serialize using the generated code.
+  TestUtil::SetPackedFields(&source);
+  source.SerializeToString(&data);
+
+  // Parse using WireFormat.
+  io::ArrayInputStream raw_input(data.data(), data.size());
+  io::CodedInputStream input(&raw_input);
+  WireFormat::ParseAndMergePartial(&input, &dest);
+
+  // Check.
+  TestUtil::ExpectPackedFieldsSet(dest);
+}
+
+TEST(WireFormatTest, ParsePackedFromUnpacked) {
+  // Serialize using the generated code.
+  UNITTEST::TestUnpackedTypes source;
+  TestUtil::SetUnpackedFields(&source);
+  std::string data = source.SerializeAsString();
+
+  // Parse using WireFormat.
+  UNITTEST::TestPackedTypes dest;
+  io::ArrayInputStream raw_input(data.data(), data.size());
+  io::CodedInputStream input(&raw_input);
+  WireFormat::ParseAndMergePartial(&input, &dest);
+
+  // Check.
+  TestUtil::ExpectPackedFieldsSet(dest);
+}
+
+TEST(WireFormatTest, ParseUnpackedFromPacked) {
+  // Serialize using the generated code.
+  UNITTEST::TestPackedTypes source;
+  TestUtil::SetPackedFields(&source);
+  std::string data = source.SerializeAsString();
+
+  // Parse using WireFormat.
+  UNITTEST::TestUnpackedTypes dest;
+  io::ArrayInputStream raw_input(data.data(), data.size());
+  io::CodedInputStream input(&raw_input);
+  WireFormat::ParseAndMergePartial(&input, &dest);
+
+  // Check.
+  TestUtil::ExpectUnpackedFieldsSet(dest);
+}
+
+TEST(WireFormatTest, ParsePackedExtensions) {
+  UNITTEST::TestPackedExtensions source, dest;
+  std::string data;
+
+  // Serialize using the generated code.
+  TestUtil::SetPackedExtensions(&source);
+  source.SerializeToString(&data);
+
+  // Parse using WireFormat.
+  io::ArrayInputStream raw_input(data.data(), data.size());
+  io::CodedInputStream input(&raw_input);
+  WireFormat::ParseAndMergePartial(&input, &dest);
+
+  // Check.
+  TestUtil::ExpectPackedExtensionsSet(dest);
+}
+
+TEST(WireFormatTest, ParseOneof) {
+  UNITTEST::TestOneof2 source, dest;
+  std::string data;
+
+  // Serialize using the generated code.
+  TestUtil::SetOneof1(&source);
+  source.SerializeToString(&data);
+
+  // Parse using WireFormat.
+  io::ArrayInputStream raw_input(data.data(), data.size());
+  io::CodedInputStream input(&raw_input);
+  WireFormat::ParseAndMergePartial(&input, &dest);
+
+  // Check.
+  TestUtil::ExpectOneofSet1(dest);
+}
+
+TEST(WireFormatTest, OneofOnlySetLast) {
+  UNITTEST::TestOneofBackwardsCompatible source;
+  UNITTEST::TestOneof oneof_dest;
+  std::string data;
+
+  // Set two fields
+  source.set_foo_int(100);
+  source.set_foo_string("101");
+
+  // Serialize and parse to oneof message. Generated serializer may not order
+  // fields in tag order. Use WireFormat::SerializeWithCachedSizes instead as
+  // it sorts fields beforehand.
+  {
+    io::StringOutputStream raw_output(&data);
+    io::CodedOutputStream output(&raw_output);
+    WireFormat::SerializeWithCachedSizes(source, source.ByteSizeLong(),
+                                         &output);
+    ASSERT_FALSE(output.HadError());
+  }
+  io::ArrayInputStream raw_input(data.data(), data.size());
+  io::CodedInputStream input(&raw_input);
+  WireFormat::ParseAndMergePartial(&input, &oneof_dest);
+
+  // Only the last field is set.
+  EXPECT_FALSE(oneof_dest.has_foo_int());
+  EXPECT_TRUE(oneof_dest.has_foo_string());
+}
+
+TEST(WireFormatTest, ByteSize) {
+  UNITTEST::TestAllTypes message;
+  TestUtil::SetAllFields(&message);
+
+  EXPECT_EQ(message.ByteSizeLong(), WireFormat::ByteSize(message));
+  message.Clear();
+  EXPECT_EQ(0, message.ByteSizeLong());
+  EXPECT_EQ(0, WireFormat::ByteSize(message));
+}
+
+TEST(WireFormatTest, ByteSizeExtensions) {
+  UNITTEST::TestAllExtensions message;
+  TestUtil::SetAllExtensions(&message);
+
+  EXPECT_EQ(message.ByteSizeLong(), WireFormat::ByteSize(message));
+  message.Clear();
+  EXPECT_EQ(0, message.ByteSizeLong());
+  EXPECT_EQ(0, WireFormat::ByteSize(message));
+}
+
+TEST(WireFormatTest, ByteSizePacked) {
+  UNITTEST::TestPackedTypes message;
+  TestUtil::SetPackedFields(&message);
+
+  EXPECT_EQ(message.ByteSizeLong(), WireFormat::ByteSize(message));
+  message.Clear();
+  EXPECT_EQ(0, message.ByteSizeLong());
+  EXPECT_EQ(0, WireFormat::ByteSize(message));
+}
+
+TEST(WireFormatTest, ByteSizePackedExtensions) {
+  UNITTEST::TestPackedExtensions message;
+  TestUtil::SetPackedExtensions(&message);
+
+  EXPECT_EQ(message.ByteSizeLong(), WireFormat::ByteSize(message));
+  message.Clear();
+  EXPECT_EQ(0, message.ByteSizeLong());
+  EXPECT_EQ(0, WireFormat::ByteSize(message));
+}
+
+TEST(WireFormatTest, ByteSizeOneof) {
+  UNITTEST::TestOneof2 message;
+  TestUtil::SetOneof1(&message);
+
+  EXPECT_EQ(message.ByteSizeLong(), WireFormat::ByteSize(message));
+  message.Clear();
+
+  EXPECT_EQ(0, message.ByteSizeLong());
+  EXPECT_EQ(0, WireFormat::ByteSize(message));
+}
+
+TEST(WireFormatTest, Serialize) {
+  UNITTEST::TestAllTypes message;
+  std::string generated_data;
+  std::string dynamic_data;
+
+  TestUtil::SetAllFields(&message);
+  size_t size = message.ByteSizeLong();
+
+  // Serialize using the generated code.
+  {
+    io::StringOutputStream raw_output(&generated_data);
+    io::CodedOutputStream output(&raw_output);
+    message.SerializeWithCachedSizes(&output);
+    ASSERT_FALSE(output.HadError());
+  }
+
+  // Serialize using WireFormat.
+  {
+    io::StringOutputStream raw_output(&dynamic_data);
+    io::CodedOutputStream output(&raw_output);
+    WireFormat::SerializeWithCachedSizes(message, size, &output);
+    ASSERT_FALSE(output.HadError());
+  }
+
+  // Should parse to the same message.
+  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, generated_data));
+  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, dynamic_data));
+}
+
+TEST(WireFormatTest, SerializeExtensions) {
+  UNITTEST::TestAllExtensions message;
+  std::string generated_data;
+  std::string dynamic_data;
+
+  TestUtil::SetAllExtensions(&message);
+  size_t size = message.ByteSizeLong();
+
+  // Serialize using the generated code.
+  {
+    io::StringOutputStream raw_output(&generated_data);
+    io::CodedOutputStream output(&raw_output);
+    message.SerializeWithCachedSizes(&output);
+    ASSERT_FALSE(output.HadError());
+  }
+
+  // Serialize using WireFormat.
+  {
+    io::StringOutputStream raw_output(&dynamic_data);
+    io::CodedOutputStream output(&raw_output);
+    WireFormat::SerializeWithCachedSizes(message, size, &output);
+    ASSERT_FALSE(output.HadError());
+  }
+
+  // Should parse to the same message.
+  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, generated_data));
+  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, dynamic_data));
+}
+
+TEST(WireFormatTest, SerializeFieldsAndExtensions) {
+  UNITTEST::TestFieldOrderings message;
+  std::string generated_data;
+  std::string dynamic_data;
+
+  TestUtil::SetAllFieldsAndExtensions(&message);
+  size_t size = message.ByteSizeLong();
+
+  // Serialize using the generated code.
+  {
+    io::StringOutputStream raw_output(&generated_data);
+    io::CodedOutputStream output(&raw_output);
+    message.SerializeWithCachedSizes(&output);
+    ASSERT_FALSE(output.HadError());
+  }
+
+  // Serialize using WireFormat.
+  {
+    io::StringOutputStream raw_output(&dynamic_data);
+    io::CodedOutputStream output(&raw_output);
+    WireFormat::SerializeWithCachedSizes(message, size, &output);
+    ASSERT_FALSE(output.HadError());
+  }
+
+  // Should parse to the same message.
+  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, generated_data));
+  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, dynamic_data));
+}
+
+TEST(WireFormatTest, SerializeOneof) {
+  UNITTEST::TestOneof2 message;
+  std::string generated_data;
+  std::string dynamic_data;
+
+  TestUtil::SetOneof1(&message);
+  size_t size = message.ByteSizeLong();
+
+  // Serialize using the generated code.
+  {
+    io::StringOutputStream raw_output(&generated_data);
+    io::CodedOutputStream output(&raw_output);
+    message.SerializeWithCachedSizes(&output);
+    ASSERT_FALSE(output.HadError());
+  }
+
+  // Serialize using WireFormat.
+  {
+    io::StringOutputStream raw_output(&dynamic_data);
+    io::CodedOutputStream output(&raw_output);
+    WireFormat::SerializeWithCachedSizes(message, size, &output);
+    ASSERT_FALSE(output.HadError());
+  }
+
+  // Should parse to the same message.
+  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, generated_data));
+  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, dynamic_data));
+}
+
+TEST(WireFormatTest, ParseMultipleExtensionRanges) {
+  // Make sure we can parse a message that contains multiple extensions ranges.
+  UNITTEST::TestFieldOrderings source;
+  std::string data;
+
+  TestUtil::SetAllFieldsAndExtensions(&source);
+  source.SerializeToString(&data);
+
+  {
+    UNITTEST::TestFieldOrderings dest;
+    EXPECT_TRUE(dest.ParseFromString(data));
+    EXPECT_EQ(source.DebugString(), dest.DebugString());
+  }
+
+  // Also test using reflection-based parsing.
+  {
+    UNITTEST::TestFieldOrderings dest;
+    io::ArrayInputStream raw_input(data.data(), data.size());
+    io::CodedInputStream coded_input(&raw_input);
+    EXPECT_TRUE(WireFormat::ParseAndMergePartial(&coded_input, &dest));
+    EXPECT_EQ(source.DebugString(), dest.DebugString());
+  }
+}
+
+const int kUnknownTypeId = 1550055;
+
+TEST(WireFormatTest, SerializeMessageSet) {
+  // Set up a TestMessageSet with two known messages and an unknown one.
+  PROTO2_WIREFORMAT_UNITTEST::TestMessageSet message_set;
+  message_set
+      .MutableExtension(
+          UNITTEST::TestMessageSetExtension1::message_set_extension)
+      ->set_i(123);
+  message_set
+      .MutableExtension(
+          UNITTEST::TestMessageSetExtension2::message_set_extension)
+      ->set_str("foo");
+  message_set.mutable_unknown_fields()->AddLengthDelimited(kUnknownTypeId,
+                                                           "bar");
+
+  std::string data;
+  ASSERT_TRUE(message_set.SerializeToString(&data));
+
+  // Parse back using RawMessageSet and check the contents.
+  UNITTEST::RawMessageSet raw;
+  ASSERT_TRUE(raw.ParseFromString(data));
+
+  EXPECT_EQ(0, raw.unknown_fields().field_count());
+
+  ASSERT_EQ(3, raw.item_size());
+  EXPECT_EQ(
+      UNITTEST::TestMessageSetExtension1::descriptor()->extension(0)->number(),
+      raw.item(0).type_id());
+  EXPECT_EQ(
+      UNITTEST::TestMessageSetExtension2::descriptor()->extension(0)->number(),
+      raw.item(1).type_id());
+  EXPECT_EQ(kUnknownTypeId, raw.item(2).type_id());
+
+  UNITTEST::TestMessageSetExtension1 message1;
+  EXPECT_TRUE(message1.ParseFromString(raw.item(0).message()));
+  EXPECT_EQ(123, message1.i());
+
+  UNITTEST::TestMessageSetExtension2 message2;
+  EXPECT_TRUE(message2.ParseFromString(raw.item(1).message()));
+  EXPECT_EQ("foo", message2.str());
+
+  EXPECT_EQ("bar", raw.item(2).message());
+}
+
+TEST(WireFormatTest, SerializeMessageSetVariousWaysAreEqual) {
+  // Serialize a MessageSet to a stream and to a flat array using generated
+  // code, and also using WireFormat, and check that the results are equal.
+  // Set up a TestMessageSet with two known messages and an unknown one, as
+  // above.
+
+  PROTO2_WIREFORMAT_UNITTEST::TestMessageSet message_set;
+  message_set
+      .MutableExtension(
+          UNITTEST::TestMessageSetExtension1::message_set_extension)
+      ->set_i(123);
+  message_set
+      .MutableExtension(
+          UNITTEST::TestMessageSetExtension2::message_set_extension)
+      ->set_str("foo");
+  message_set.mutable_unknown_fields()->AddLengthDelimited(kUnknownTypeId,
+                                                           "bar");
+
+  size_t size = message_set.ByteSizeLong();
+  EXPECT_EQ(size, message_set.GetCachedSize());
+  ASSERT_EQ(size, WireFormat::ByteSize(message_set));
+
+  std::string flat_data;
+  std::string stream_data;
+  std::string dynamic_data;
+  flat_data.resize(size);
+  stream_data.resize(size);
+
+  // Serialize to flat array
+  {
+    uint8_t* target =
+        reinterpret_cast<uint8_t*>(::google::protobuf::string_as_array(&flat_data));
+    uint8_t* end = message_set.SerializeWithCachedSizesToArray(target);
+    EXPECT_EQ(size, end - target);
+  }
+
+  // Serialize to buffer
+  {
+    io::ArrayOutputStream array_stream(::google::protobuf::string_as_array(&stream_data), size,
+                                       1);
+    io::CodedOutputStream output_stream(&array_stream);
+    message_set.SerializeWithCachedSizes(&output_stream);
+    ASSERT_FALSE(output_stream.HadError());
+  }
+
+  // Serialize to buffer with WireFormat.
+  {
+    io::StringOutputStream string_stream(&dynamic_data);
+    io::CodedOutputStream output_stream(&string_stream);
+    WireFormat::SerializeWithCachedSizes(message_set, size, &output_stream);
+    ASSERT_FALSE(output_stream.HadError());
+  }
+
+  EXPECT_TRUE(flat_data == stream_data);
+  EXPECT_TRUE(flat_data == dynamic_data);
+}
+
+TEST(WireFormatTest, ParseMessageSet) {
+  // Set up a RawMessageSet with two known messages and an unknown one.
+  UNITTEST::RawMessageSet raw;
+
+  {
+    UNITTEST::RawMessageSet::Item* item = raw.add_item();
+    item->set_type_id(UNITTEST::TestMessageSetExtension1::descriptor()
+                          ->extension(0)
+                          ->number());
+    UNITTEST::TestMessageSetExtension1 message;
+    message.set_i(123);
+    message.SerializeToString(item->mutable_message());
+  }
+
+  {
+    UNITTEST::RawMessageSet::Item* item = raw.add_item();
+    item->set_type_id(UNITTEST::TestMessageSetExtension2::descriptor()
+                          ->extension(0)
+                          ->number());
+    UNITTEST::TestMessageSetExtension2 message;
+    message.set_str("foo");
+    message.SerializeToString(item->mutable_message());
+  }
+
+  {
+    UNITTEST::RawMessageSet::Item* item = raw.add_item();
+    item->set_type_id(kUnknownTypeId);
+    item->set_message("bar");
+  }
+
+  std::string data;
+  ASSERT_TRUE(raw.SerializeToString(&data));
+
+  // Parse as a TestMessageSet and check the contents.
+  PROTO2_WIREFORMAT_UNITTEST::TestMessageSet message_set;
+  ASSERT_TRUE(message_set.ParseFromString(data));
+
+  EXPECT_EQ(123,
+            message_set
+                .GetExtension(
+                    UNITTEST::TestMessageSetExtension1::message_set_extension)
+                .i());
+  EXPECT_EQ("foo",
+            message_set
+                .GetExtension(
+                    UNITTEST::TestMessageSetExtension2::message_set_extension)
+                .str());
+
+  ASSERT_EQ(1, message_set.unknown_fields().field_count());
+  ASSERT_EQ(UnknownField::TYPE_LENGTH_DELIMITED,
+            message_set.unknown_fields().field(0).type());
+  EXPECT_EQ("bar", message_set.unknown_fields().field(0).length_delimited());
+
+  // Also parse using WireFormat.
+  PROTO2_WIREFORMAT_UNITTEST::TestMessageSet dynamic_message_set;
+  io::CodedInputStream input(reinterpret_cast<const uint8_t*>(data.data()),
+                             data.size());
+  ASSERT_TRUE(WireFormat::ParseAndMergePartial(&input, &dynamic_message_set));
+  EXPECT_EQ(message_set.DebugString(), dynamic_message_set.DebugString());
+}
+
+namespace {
+std::string BuildMessageSetItemStart() {
+  std::string data;
+  {
+    io::StringOutputStream output_stream(&data);
+    io::CodedOutputStream coded_output(&output_stream);
+    coded_output.WriteTag(WireFormatLite::kMessageSetItemStartTag);
+  }
+  return data;
+}
+std::string BuildMessageSetItemEnd() {
+  std::string data;
+  {
+    io::StringOutputStream output_stream(&data);
+    io::CodedOutputStream coded_output(&output_stream);
+    coded_output.WriteTag(WireFormatLite::kMessageSetItemEndTag);
+  }
+  return data;
+}
+std::string BuildMessageSetTestExtension1(int value = 123) {
+  std::string data;
+  {
+    UNITTEST::TestMessageSetExtension1 message;
+    message.set_i(value);
+    io::StringOutputStream output_stream(&data);
+    io::CodedOutputStream coded_output(&output_stream);
+    // Write the message content first.
+    WireFormatLite::WriteTag(WireFormatLite::kMessageSetMessageNumber,
+                             WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
+                             &coded_output);
+    coded_output.WriteVarint32(message.ByteSizeLong());
+    message.SerializeWithCachedSizes(&coded_output);
+  }
+  return data;
+}
+std::string BuildMessageSetItemTypeId(int extension_number) {
+  std::string data;
+  {
+    io::StringOutputStream output_stream(&data);
+    io::CodedOutputStream coded_output(&output_stream);
+    WireFormatLite::WriteUInt32(WireFormatLite::kMessageSetTypeIdNumber,
+                                extension_number, &coded_output);
+  }
+  return data;
+}
+void ValidateTestMessageSet(const std::string& test_case,
+                            const std::string& data) {
+  SCOPED_TRACE(test_case);
+  {
+    PROTO2_WIREFORMAT_UNITTEST::TestMessageSet message_set;
+    ASSERT_TRUE(message_set.ParseFromString(data));
+
+    EXPECT_EQ(123,
+              message_set
+                  .GetExtension(
+                      UNITTEST::TestMessageSetExtension1::message_set_extension)
+                  .i());
+
+    // Make sure it does not contain anything else.
+    message_set.ClearExtension(
+        UNITTEST::TestMessageSetExtension1::message_set_extension);
+    EXPECT_EQ(message_set.SerializeAsString(), "");
+  }
+  {
+    // Test parse the message via Reflection.
+    PROTO2_WIREFORMAT_UNITTEST::TestMessageSet message_set;
+    io::CodedInputStream input(reinterpret_cast<const uint8_t*>(data.data()),
+                               data.size());
+    EXPECT_TRUE(WireFormat::ParseAndMergePartial(&input, &message_set));
+    EXPECT_TRUE(input.ConsumedEntireMessage());
+
+    EXPECT_EQ(123,
+              message_set
+                  .GetExtension(
+                      UNITTEST::TestMessageSetExtension1::message_set_extension)
+                  .i());
+  }
+  {
+    // Test parse the message via DynamicMessage.
+    DynamicMessageFactory factory;
+    std::unique_ptr<Message> msg(
+        factory
+            .GetPrototype(
+                PROTO2_WIREFORMAT_UNITTEST::TestMessageSet::descriptor())
+            ->New());
+    msg->ParseFromString(data);
+    auto* reflection = msg->GetReflection();
+    std::vector<const FieldDescriptor*> fields;
+    reflection->ListFields(*msg, &fields);
+    ASSERT_EQ(fields.size(), 1);
+    const auto& sub = reflection->GetMessage(*msg, fields[0]);
+    reflection = sub.GetReflection();
+    EXPECT_EQ(123, reflection->GetInt32(
+                       sub, sub.GetDescriptor()->FindFieldByName("i")));
+  }
+}
+}  // namespace
+
+TEST(WireFormatTest, ParseMessageSetWithAnyTagOrder) {
+  std::string start = BuildMessageSetItemStart();
+  std::string end = BuildMessageSetItemEnd();
+  std::string id = BuildMessageSetItemTypeId(
+      UNITTEST::TestMessageSetExtension1::descriptor()->extension(0)->number());
+  std::string message = BuildMessageSetTestExtension1();
+
+  ValidateTestMessageSet("id + message", start + id + message + end);
+  ValidateTestMessageSet("message + id", start + message + id + end);
+}
+
+TEST(WireFormatTest, ParseMessageSetWithDuplicateTags) {
+  std::string start = BuildMessageSetItemStart();
+  std::string end = BuildMessageSetItemEnd();
+  std::string id = BuildMessageSetItemTypeId(
+      UNITTEST::TestMessageSetExtension1::descriptor()->extension(0)->number());
+  std::string other_id = BuildMessageSetItemTypeId(123456);
+  std::string message = BuildMessageSetTestExtension1();
+  std::string other_message = BuildMessageSetTestExtension1(321);
+
+  // Double id
+  ValidateTestMessageSet("id + other_id + message",
+                         start + id + other_id + message + end);
+  ValidateTestMessageSet("id + message + other_id",
+                         start + id + message + other_id + end);
+  ValidateTestMessageSet("message + id + other_id",
+                         start + message + id + other_id + end);
+  // Double message
+  ValidateTestMessageSet("id + message + other_message",
+                         start + id + message + other_message + end);
+  ValidateTestMessageSet("message + id + other_message",
+                         start + message + id + other_message + end);
+  ValidateTestMessageSet("message + other_message + id",
+                         start + message + other_message + id + end);
+}
+
+void SerializeReverseOrder(
+    const PROTO2_WIREFORMAT_UNITTEST::TestMessageSet& mset,
+    io::CodedOutputStream* coded_output);
+
+void SerializeReverseOrder(const UNITTEST::TestMessageSetExtension1& message,
+                           io::CodedOutputStream* coded_output) {
+  WireFormatLite::WriteTag(15,  // i
+                           WireFormatLite::WIRETYPE_VARINT, coded_output);
+  coded_output->WriteVarint64(message.i());
+  WireFormatLite::WriteTag(16,  // recursive
+                           WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
+                           coded_output);
+  coded_output->WriteVarint32(message.recursive().GetCachedSize());
+  SerializeReverseOrder(message.recursive(), coded_output);
+}
+
+void SerializeReverseOrder(
+    const PROTO2_WIREFORMAT_UNITTEST::TestMessageSet& mset,
+    io::CodedOutputStream* coded_output) {
+  if (!mset.HasExtension(
+          UNITTEST::TestMessageSetExtension1::message_set_extension))
+    return;
+  coded_output->WriteTag(WireFormatLite::kMessageSetItemStartTag);
+  // Write the message content first.
+  WireFormatLite::WriteTag(WireFormatLite::kMessageSetMessageNumber,
+                           WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
+                           coded_output);
+  auto& message = mset.GetExtension(
+      UNITTEST::TestMessageSetExtension1::message_set_extension);
+  coded_output->WriteVarint32(message.GetCachedSize());
+  SerializeReverseOrder(message, coded_output);
+  // Write the type id.
+  uint32_t type_id = message.GetDescriptor()->extension(0)->number();
+  WireFormatLite::WriteUInt32(WireFormatLite::kMessageSetTypeIdNumber, type_id,
+                              coded_output);
+  coded_output->WriteTag(WireFormatLite::kMessageSetItemEndTag);
+}
+
+TEST(WireFormatTest, ParseMessageSetWithDeepRecReverseOrder) {
+  std::string data;
+  {
+    PROTO2_WIREFORMAT_UNITTEST::TestMessageSet message_set;
+    PROTO2_WIREFORMAT_UNITTEST::TestMessageSet* mset = &message_set;
+    for (int i = 0; i < 200; i++) {
+      auto m = mset->MutableExtension(
+          UNITTEST::TestMessageSetExtension1::message_set_extension);
+      m->set_i(i);
+      mset = m->mutable_recursive();
+    }
+    message_set.ByteSizeLong();
+    // Serialize with reverse payload tag order
+    io::StringOutputStream output_stream(&data);
+    io::CodedOutputStream coded_output(&output_stream);
+    SerializeReverseOrder(message_set, &coded_output);
+  }
+  PROTO2_WIREFORMAT_UNITTEST::TestMessageSet message_set;
+  EXPECT_FALSE(message_set.ParseFromString(data));
+}
+
+TEST(WireFormatTest, ParseFailMalformedMessageSet) {
+  constexpr int kDepth = 5;
+  std::string data;
+  {
+    PROTO2_WIREFORMAT_UNITTEST::TestMessageSet message_set;
+    PROTO2_WIREFORMAT_UNITTEST::TestMessageSet* mset = &message_set;
+    for (int i = 0; i < kDepth; i++) {
+      auto m = mset->MutableExtension(
+          UNITTEST::TestMessageSetExtension1::message_set_extension);
+      m->set_i(i);
+      mset = m->mutable_recursive();
+    }
+    auto m = mset->MutableExtension(
+        UNITTEST::TestMessageSetExtension1::message_set_extension);
+    // -1 becomes \xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x1
+    m->set_i(-1);
+
+    EXPECT_TRUE(message_set.SerializeToString(&data));
+    // Make the proto mal-formed.
+    data[data.size() - 2 - kDepth] = 0xFF;
+  }
+
+  PROTO2_WIREFORMAT_UNITTEST::TestMessageSet message_set;
+  EXPECT_FALSE(message_set.ParseFromString(data));
+}
+
+TEST(WireFormatTest, ParseFailMalformedMessageSetReverseOrder) {
+  constexpr int kDepth = 5;
+  std::string data;
+  {
+    PROTO2_WIREFORMAT_UNITTEST::TestMessageSet message_set;
+    PROTO2_WIREFORMAT_UNITTEST::TestMessageSet* mset = &message_set;
+    for (int i = 0; i < kDepth; i++) {
+      auto m = mset->MutableExtension(
+          UNITTEST::TestMessageSetExtension1::message_set_extension);
+      m->set_i(i);
+      mset = m->mutable_recursive();
+    }
+    auto m = mset->MutableExtension(
+        UNITTEST::TestMessageSetExtension1::message_set_extension);
+    // -1 becomes \xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x1
+    m->set_i(-1);
+    // SerializeReverseOrder() assumes "recursive" is always present.
+    m->mutable_recursive();
+
+    message_set.ByteSizeLong();
+
+    // Serialize with reverse payload tag order
+    io::StringOutputStream output_stream(&data);
+    io::CodedOutputStream coded_output(&output_stream);
+    SerializeReverseOrder(message_set, &coded_output);
+  }
+
+  // Make varint for -1 malformed.
+  data[data.size() - 5 * (kDepth + 1) - 4] = 0xFF;
+
+  PROTO2_WIREFORMAT_UNITTEST::TestMessageSet message_set;
+  EXPECT_FALSE(message_set.ParseFromString(data));
+}
+
+TEST(WireFormatTest, ParseBrokenMessageSet) {
+  PROTO2_WIREFORMAT_UNITTEST::TestMessageSet message_set;
+  std::string input("goodbye");  // Invalid wire format data.
+  EXPECT_FALSE(message_set.ParseFromString(input));
+}
+
+TEST(WireFormatTest, RecursionLimit) {
+  UNITTEST::TestRecursiveMessage message;
+  message.mutable_a()->mutable_a()->mutable_a()->mutable_a()->set_i(1);
+  std::string data;
+  message.SerializeToString(&data);
+
+  {
+    io::ArrayInputStream raw_input(data.data(), data.size());
+    io::CodedInputStream input(&raw_input);
+    input.SetRecursionLimit(4);
+    UNITTEST::TestRecursiveMessage message2;
+    EXPECT_TRUE(message2.ParseFromCodedStream(&input));
+  }
+
+  {
+    io::ArrayInputStream raw_input(data.data(), data.size());
+    io::CodedInputStream input(&raw_input);
+    input.SetRecursionLimit(3);
+    UNITTEST::TestRecursiveMessage message2;
+    EXPECT_FALSE(message2.ParseFromCodedStream(&input));
+  }
+}
+
+TEST(WireFormatTest, LargeRecursionLimit) {
+  const int kLargeLimit = io::CodedInputStream::GetDefaultRecursionLimit() + 50;
+  UNITTEST::TestRecursiveMessage src, dst, *a;
+  a = src.mutable_a();
+  for (int i = 0; i < kLargeLimit - 1; i++) {
+    a = a->mutable_a();
+  }
+  a->set_i(1);
+
+  std::string data = src.SerializeAsString();
+  {
+    // Parse with default recursion limit. Should fail.
+    io::ArrayInputStream raw_input(data.data(), data.size());
+    io::CodedInputStream input(&raw_input);
+    ASSERT_FALSE(dst.ParseFromCodedStream(&input));
+  }
+
+  {
+    // Parse with custom recursion limit. Should pass.
+    io::ArrayInputStream raw_input(data.data(), data.size());
+    io::CodedInputStream input(&raw_input);
+    input.SetRecursionLimit(kLargeLimit);
+    ASSERT_TRUE(dst.ParseFromCodedStream(&input));
+  }
+
+  // Verifies the recursion depth.
+  int depth = 1;
+  a = dst.mutable_a();
+  while (a->has_a()) {
+    a = a->mutable_a();
+    depth++;
+  }
+
+  EXPECT_EQ(a->i(), 1);
+  EXPECT_EQ(depth, kLargeLimit);
+}
+
+TEST(WireFormatTest, UnknownFieldRecursionLimit) {
+  UNITTEST::TestEmptyMessage message;
+  message.mutable_unknown_fields()
+      ->AddGroup(1234)
+      ->AddGroup(1234)
+      ->AddGroup(1234)
+      ->AddGroup(1234)
+      ->AddVarint(1234, 123);
+  std::string data;
+  message.SerializeToString(&data);
+
+  {
+    io::ArrayInputStream raw_input(data.data(), data.size());
+    io::CodedInputStream input(&raw_input);
+    input.SetRecursionLimit(4);
+    UNITTEST::TestEmptyMessage message2;
+    EXPECT_TRUE(message2.ParseFromCodedStream(&input));
+  }
+
+  {
+    io::ArrayInputStream raw_input(data.data(), data.size());
+    io::CodedInputStream input(&raw_input);
+    input.SetRecursionLimit(3);
+    UNITTEST::TestEmptyMessage message2;
+    EXPECT_FALSE(message2.ParseFromCodedStream(&input));
+  }
+}
+
+TEST(WireFormatTest, ZigZag) {
+// avoid line-wrapping
+#define LL(x) static_cast<int64_t>(ULL(x))
+#define ULL(x) uint64_t{x##u}
+#define ZigZagEncode32(x) WireFormatLite::ZigZagEncode32(x)
+#define ZigZagDecode32(x) WireFormatLite::ZigZagDecode32(x)
+#define ZigZagEncode64(x) WireFormatLite::ZigZagEncode64(x)
+#define ZigZagDecode64(x) WireFormatLite::ZigZagDecode64(x)
+
+  EXPECT_EQ(0u, ZigZagEncode32(0));
+  EXPECT_EQ(1u, ZigZagEncode32(-1));
+  EXPECT_EQ(2u, ZigZagEncode32(1));
+  EXPECT_EQ(3u, ZigZagEncode32(-2));
+  EXPECT_EQ(0x7FFFFFFEu, ZigZagEncode32(0x3FFFFFFF));
+  EXPECT_EQ(0x7FFFFFFFu, ZigZagEncode32(0xC0000000));
+  EXPECT_EQ(0xFFFFFFFEu, ZigZagEncode32(0x7FFFFFFF));
+  EXPECT_EQ(0xFFFFFFFFu, ZigZagEncode32(0x80000000));
+
+  EXPECT_EQ(0, ZigZagDecode32(0u));
+  EXPECT_EQ(-1, ZigZagDecode32(1u));
+  EXPECT_EQ(1, ZigZagDecode32(2u));
+  EXPECT_EQ(-2, ZigZagDecode32(3u));
+  EXPECT_EQ(0x3FFFFFFF, ZigZagDecode32(0x7FFFFFFEu));
+  EXPECT_EQ(0xC0000000, ZigZagDecode32(0x7FFFFFFFu));
+  EXPECT_EQ(0x7FFFFFFF, ZigZagDecode32(0xFFFFFFFEu));
+  EXPECT_EQ(0x80000000, ZigZagDecode32(0xFFFFFFFFu));
+
+  EXPECT_EQ(0u, ZigZagEncode64(0));
+  EXPECT_EQ(1u, ZigZagEncode64(-1));
+  EXPECT_EQ(2u, ZigZagEncode64(1));
+  EXPECT_EQ(3u, ZigZagEncode64(-2));
+  EXPECT_EQ(ULL(0x000000007FFFFFFE), ZigZagEncode64(LL(0x000000003FFFFFFF)));
+  EXPECT_EQ(ULL(0x000000007FFFFFFF), ZigZagEncode64(LL(0xFFFFFFFFC0000000)));
+  EXPECT_EQ(ULL(0x00000000FFFFFFFE), ZigZagEncode64(LL(0x000000007FFFFFFF)));
+  EXPECT_EQ(ULL(0x00000000FFFFFFFF), ZigZagEncode64(LL(0xFFFFFFFF80000000)));
+  EXPECT_EQ(ULL(0xFFFFFFFFFFFFFFFE), ZigZagEncode64(LL(0x7FFFFFFFFFFFFFFF)));
+  EXPECT_EQ(ULL(0xFFFFFFFFFFFFFFFF), ZigZagEncode64(LL(0x8000000000000000)));
+
+  EXPECT_EQ(0, ZigZagDecode64(0u));
+  EXPECT_EQ(-1, ZigZagDecode64(1u));
+  EXPECT_EQ(1, ZigZagDecode64(2u));
+  EXPECT_EQ(-2, ZigZagDecode64(3u));
+  EXPECT_EQ(LL(0x000000003FFFFFFF), ZigZagDecode64(ULL(0x000000007FFFFFFE)));
+  EXPECT_EQ(LL(0xFFFFFFFFC0000000), ZigZagDecode64(ULL(0x000000007FFFFFFF)));
+  EXPECT_EQ(LL(0x000000007FFFFFFF), ZigZagDecode64(ULL(0x00000000FFFFFFFE)));
+  EXPECT_EQ(LL(0xFFFFFFFF80000000), ZigZagDecode64(ULL(0x00000000FFFFFFFF)));
+  EXPECT_EQ(LL(0x7FFFFFFFFFFFFFFF), ZigZagDecode64(ULL(0xFFFFFFFFFFFFFFFE)));
+  EXPECT_EQ(LL(0x8000000000000000), ZigZagDecode64(ULL(0xFFFFFFFFFFFFFFFF)));
+
+  // Some easier-to-verify round-trip tests.  The inputs (other than 0, 1, -1)
+  // were chosen semi-randomly via keyboard bashing.
+  EXPECT_EQ(0, ZigZagDecode32(ZigZagEncode32(0)));
+  EXPECT_EQ(1, ZigZagDecode32(ZigZagEncode32(1)));
+  EXPECT_EQ(-1, ZigZagDecode32(ZigZagEncode32(-1)));
+  EXPECT_EQ(14927, ZigZagDecode32(ZigZagEncode32(14927)));
+  EXPECT_EQ(-3612, ZigZagDecode32(ZigZagEncode32(-3612)));
+
+  EXPECT_EQ(0, ZigZagDecode64(ZigZagEncode64(0)));
+  EXPECT_EQ(1, ZigZagDecode64(ZigZagEncode64(1)));
+  EXPECT_EQ(-1, ZigZagDecode64(ZigZagEncode64(-1)));
+  EXPECT_EQ(14927, ZigZagDecode64(ZigZagEncode64(14927)));
+  EXPECT_EQ(-3612, ZigZagDecode64(ZigZagEncode64(-3612)));
+
+  EXPECT_EQ(LL(856912304801416),
+            ZigZagDecode64(ZigZagEncode64(LL(856912304801416))));
+  EXPECT_EQ(LL(-75123905439571256),
+            ZigZagDecode64(ZigZagEncode64(LL(-75123905439571256))));
+}
+
+TEST(WireFormatTest, RepeatedScalarsDifferentTagSizes) {
+  // At one point checks would trigger when parsing repeated fixed scalar
+  // fields.
+  UNITTEST::TestRepeatedScalarDifferentTagSizes msg1, msg2;
+  for (int i = 0; i < 100; ++i) {
+    msg1.add_repeated_fixed32(i);
+    msg1.add_repeated_int32(i);
+    msg1.add_repeated_fixed64(i);
+    msg1.add_repeated_int64(i);
+    msg1.add_repeated_float(i);
+    msg1.add_repeated_uint64(i);
+  }
+
+  // Make sure that we have a variety of tag sizes.
+  const Descriptor* desc = msg1.GetDescriptor();
+  const FieldDescriptor* field;
+  field = desc->FindFieldByName("repeated_fixed32");
+  ASSERT_TRUE(field != nullptr);
+  ASSERT_EQ(1, WireFormat::TagSize(field->number(), field->type()));
+  field = desc->FindFieldByName("repeated_int32");
+  ASSERT_TRUE(field != nullptr);
+  ASSERT_EQ(1, WireFormat::TagSize(field->number(), field->type()));
+  field = desc->FindFieldByName("repeated_fixed64");
+  ASSERT_TRUE(field != nullptr);
+  ASSERT_EQ(2, WireFormat::TagSize(field->number(), field->type()));
+  field = desc->FindFieldByName("repeated_int64");
+  ASSERT_TRUE(field != nullptr);
+  ASSERT_EQ(2, WireFormat::TagSize(field->number(), field->type()));
+  field = desc->FindFieldByName("repeated_float");
+  ASSERT_TRUE(field != nullptr);
+  ASSERT_EQ(3, WireFormat::TagSize(field->number(), field->type()));
+  field = desc->FindFieldByName("repeated_uint64");
+  ASSERT_TRUE(field != nullptr);
+  ASSERT_EQ(3, WireFormat::TagSize(field->number(), field->type()));
+
+  EXPECT_TRUE(msg2.ParseFromString(msg1.SerializeAsString()));
+  EXPECT_EQ(msg1.DebugString(), msg2.DebugString());
+}
+
+TEST(WireFormatTest, CompatibleTypes) {
+  const int64_t data = 0x100000000LL;
+  UNITTEST::Int64Message msg1;
+  msg1.set_data(data);
+  std::string serialized;
+  msg1.SerializeToString(&serialized);
+
+  // Test int64 is compatible with bool
+  UNITTEST::BoolMessage msg2;
+  ASSERT_TRUE(msg2.ParseFromString(serialized));
+  ASSERT_EQ(static_cast<bool>(data), msg2.data());
+
+  // Test int64 is compatible with uint64
+  UNITTEST::Uint64Message msg3;
+  ASSERT_TRUE(msg3.ParseFromString(serialized));
+  ASSERT_EQ(static_cast<uint64_t>(data), msg3.data());
+
+  // Test int64 is compatible with int32
+  UNITTEST::Int32Message msg4;
+  ASSERT_TRUE(msg4.ParseFromString(serialized));
+  ASSERT_EQ(static_cast<int32_t>(data), msg4.data());
+
+  // Test int64 is compatible with uint32
+  UNITTEST::Uint32Message msg5;
+  ASSERT_TRUE(msg5.ParseFromString(serialized));
+  ASSERT_EQ(static_cast<uint32_t>(data), msg5.data());
+}
+
+class Proto3PrimitiveRepeatedWireFormatTest : public ::testing::Test {
+ protected:
+  Proto3PrimitiveRepeatedWireFormatTest()
+      : packedTestAllTypes_(
+            "\xFA\x01\x01\x01"
+            "\x82\x02\x01\x01"
+            "\x8A\x02\x01\x01"
+            "\x92\x02\x01\x01"
+            "\x9A\x02\x01\x02"
+            "\xA2\x02\x01\x02"
+            "\xAA\x02\x04\x01\x00\x00\x00"
+            "\xB2\x02\x08\x01\x00\x00\x00\x00\x00\x00\x00"
+            "\xBA\x02\x04\x01\x00\x00\x00"
+            "\xC2\x02\x08\x01\x00\x00\x00\x00\x00\x00\x00"
+            "\xCA\x02\x04\x00\x00\x80\x3f"
+            "\xD2\x02\x08\x00\x00\x00\x00\x00\x00\xf0\x3f"
+            "\xDA\x02\x01\x01"
+            "\x9A\x03\x01\x01",
+            86),
+        packedTestUnpackedTypes_(
+            "\x0A\x01\x01"
+            "\x12\x01\x01"
+            "\x1A\x01\x01"
+            "\x22\x01\x01"
+            "\x2A\x01\x02"
+            "\x32\x01\x02"
+            "\x3A\x04\x01\x00\x00\x00"
+            "\x42\x08\x01\x00\x00\x00\x00\x00\x00\x00"
+            "\x4A\x04\x01\x00\x00\x00"
+            "\x52\x08\x01\x00\x00\x00\x00\x00\x00\x00"
+            "\x5A\x04\x00\x00\x80\x3f"
+            "\x62\x08\x00\x00\x00\x00\x00\x00\xf0\x3f"
+            "\x6A\x01\x01"
+            "\x72\x01\x01",
+            72),
+        unpackedTestAllTypes_(
+            "\xF8\x01\x01"
+            "\x80\x02\x01"
+            "\x88\x02\x01"
+            "\x90\x02\x01"
+            "\x98\x02\x02"
+            "\xA0\x02\x02"
+            "\xAD\x02\x01\x00\x00\x00"
+            "\xB1\x02\x01\x00\x00\x00\x00\x00\x00\x00"
+            "\xBD\x02\x01\x00\x00\x00"
+            "\xC1\x02\x01\x00\x00\x00\x00\x00\x00\x00"
+            "\xCD\x02\x00\x00\x80\x3f"
+            "\xD1\x02\x00\x00\x00\x00\x00\x00\xf0\x3f"
+            "\xD8\x02\x01"
+            "\x98\x03\x01",
+            72),
+        unpackedTestUnpackedTypes_(
+            "\x08\x01"
+            "\x10\x01"
+            "\x18\x01"
+            "\x20\x01"
+            "\x28\x02"
+            "\x30\x02"
+            "\x3D\x01\x00\x00\x00"
+            "\x41\x01\x00\x00\x00\x00\x00\x00\x00"
+            "\x4D\x01\x00\x00\x00"
+            "\x51\x01\x00\x00\x00\x00\x00\x00\x00"
+            "\x5D\x00\x00\x80\x3f"
+            "\x61\x00\x00\x00\x00\x00\x00\xf0\x3f"
+            "\x68\x01"
+            "\x70\x01",
+            58) {}
+  template <class Proto>
+  void SetProto3PrimitiveRepeatedFields(Proto* message) {
+    message->add_repeated_int32(1);
+    message->add_repeated_int64(1);
+    message->add_repeated_uint32(1);
+    message->add_repeated_uint64(1);
+    message->add_repeated_sint32(1);
+    message->add_repeated_sint64(1);
+    message->add_repeated_fixed32(1);
+    message->add_repeated_fixed64(1);
+    message->add_repeated_sfixed32(1);
+    message->add_repeated_sfixed64(1);
+    message->add_repeated_float(1.0);
+    message->add_repeated_double(1.0);
+    message->add_repeated_bool(true);
+    message->add_repeated_nested_enum(PROTO3_ARENA_UNITTEST::TestAllTypes::FOO);
+  }
+
+  template <class Proto>
+  void ExpectProto3PrimitiveRepeatedFieldsSet(const Proto& message) {
+    EXPECT_EQ(1, message.repeated_int32(0));
+    EXPECT_EQ(1, message.repeated_int64(0));
+    EXPECT_EQ(1, message.repeated_uint32(0));
+    EXPECT_EQ(1, message.repeated_uint64(0));
+    EXPECT_EQ(1, message.repeated_sint32(0));
+    EXPECT_EQ(1, message.repeated_sint64(0));
+    EXPECT_EQ(1, message.repeated_fixed32(0));
+    EXPECT_EQ(1, message.repeated_fixed64(0));
+    EXPECT_EQ(1, message.repeated_sfixed32(0));
+    EXPECT_EQ(1, message.repeated_sfixed64(0));
+    EXPECT_EQ(1.0, message.repeated_float(0));
+    EXPECT_EQ(1.0, message.repeated_double(0));
+    EXPECT_EQ(true, message.repeated_bool(0));
+    EXPECT_EQ(PROTO3_ARENA_UNITTEST::TestAllTypes::FOO,
+              message.repeated_nested_enum(0));
+  }
+
+  template <class Proto>
+  void TestSerialization(Proto* message, const std::string& expected) {
+    SetProto3PrimitiveRepeatedFields(message);
+
+    size_t size = message->ByteSizeLong();
+
+    // Serialize using the generated code.
+    std::string generated_data;
+    {
+      io::StringOutputStream raw_output(&generated_data);
+      io::CodedOutputStream output(&raw_output);
+      message->SerializeWithCachedSizes(&output);
+      ASSERT_FALSE(output.HadError());
+    }
+    EXPECT_TRUE(TestUtil::EqualsToSerialized(*message, generated_data));
+
+    // Serialize using the dynamic code.
+    std::string dynamic_data;
+    {
+      io::StringOutputStream raw_output(&dynamic_data);
+      io::CodedOutputStream output(&raw_output);
+      WireFormat::SerializeWithCachedSizes(*message, size, &output);
+      ASSERT_FALSE(output.HadError());
+    }
+    EXPECT_TRUE(expected == dynamic_data);
+  }
+
+  template <class Proto>
+  void TestParsing(Proto* message, const std::string& compatible_data) {
+    message->Clear();
+    message->ParseFromString(compatible_data);
+    ExpectProto3PrimitiveRepeatedFieldsSet(*message);
+
+    message->Clear();
+    io::CodedInputStream input(
+        reinterpret_cast<const uint8_t*>(compatible_data.data()),
+        compatible_data.size());
+    WireFormat::ParseAndMergePartial(&input, message);
+    ExpectProto3PrimitiveRepeatedFieldsSet(*message);
+  }
+
+  const std::string packedTestAllTypes_;
+  const std::string packedTestUnpackedTypes_;
+  const std::string unpackedTestAllTypes_;
+  const std::string unpackedTestUnpackedTypes_;
+};
+
+TEST_F(Proto3PrimitiveRepeatedWireFormatTest, Proto3PrimitiveRepeated) {
+  PROTO3_ARENA_UNITTEST::TestAllTypes packed_message;
+  PROTO3_ARENA_UNITTEST::TestUnpackedTypes unpacked_message;
+  TestSerialization(&packed_message, packedTestAllTypes_);
+  TestParsing(&packed_message, packedTestAllTypes_);
+  TestParsing(&packed_message, unpackedTestAllTypes_);
+  TestSerialization(&unpacked_message, unpackedTestUnpackedTypes_);
+  TestParsing(&unpacked_message, packedTestUnpackedTypes_);
+  TestParsing(&unpacked_message, unpackedTestUnpackedTypes_);
+}
+
+class WireFormatInvalidInputTest : public testing::Test {
+ protected:
+  // Make a serialized TestAllTypes in which the field optional_nested_message
+  // contains exactly the given bytes, which may be invalid.
+  std::string MakeInvalidEmbeddedMessage(const char* bytes, int size) {
+    const FieldDescriptor* field =
+        UNITTEST::TestAllTypes::descriptor()->FindFieldByName(
+            "optional_nested_message");
+    GOOGLE_CHECK(field != nullptr);
+
+    std::string result;
+
+    {
+      io::StringOutputStream raw_output(&result);
+      io::CodedOutputStream output(&raw_output);
+
+      WireFormatLite::WriteBytes(field->number(), std::string(bytes, size),
+                                 &output);
+    }
+
+    return result;
+  }
+
+  // Make a serialized TestAllTypes in which the field optionalgroup
+  // contains exactly the given bytes -- which may be invalid -- and
+  // possibly no end tag.
+  std::string MakeInvalidGroup(const char* bytes, int size,
+                               bool include_end_tag) {
+    const FieldDescriptor* field =
+        UNITTEST::TestAllTypes::descriptor()->FindFieldByName("optionalgroup");
+    GOOGLE_CHECK(field != nullptr);
+
+    std::string result;
+
+    {
+      io::StringOutputStream raw_output(&result);
+      io::CodedOutputStream output(&raw_output);
+
+      output.WriteVarint32(WireFormat::MakeTag(field));
+      output.WriteString(std::string(bytes, size));
+      if (include_end_tag) {
+        output.WriteVarint32(WireFormatLite::MakeTag(
+            field->number(), WireFormatLite::WIRETYPE_END_GROUP));
+      }
+    }
+
+    return result;
+  }
+};
+
+TEST_F(WireFormatInvalidInputTest, InvalidSubMessage) {
+  UNITTEST::TestAllTypes message;
+
+  // Control case.
+  EXPECT_TRUE(message.ParseFromString(MakeInvalidEmbeddedMessage("", 0)));
+
+  // The byte is a valid varint, but not a valid tag (zero).
+  EXPECT_FALSE(message.ParseFromString(MakeInvalidEmbeddedMessage("\0", 1)));
+
+  // The byte is a malformed varint.
+  EXPECT_FALSE(message.ParseFromString(MakeInvalidEmbeddedMessage("\200", 1)));
+
+  // The byte is an endgroup tag, but we aren't parsing a group.
+  EXPECT_FALSE(message.ParseFromString(MakeInvalidEmbeddedMessage("\014", 1)));
+
+  // The byte is a valid varint but not a valid tag (bad wire type).
+  EXPECT_FALSE(message.ParseFromString(MakeInvalidEmbeddedMessage("\017", 1)));
+}
+
+TEST_F(WireFormatInvalidInputTest, InvalidMessageWithExtraZero) {
+  std::string data;
+  {
+    // Serialize a valid proto
+    UNITTEST::TestAllTypes message;
+    message.set_optional_int32(1);
+    message.SerializeToString(&data);
+    data.push_back(0);  // Append invalid zero tag
+  }
+
+  // Control case.
+  {
+    io::ArrayInputStream ais(data.data(), data.size());
+    io::CodedInputStream is(&ais);
+    UNITTEST::TestAllTypes message;
+    // It should fail but currently passes.
+    EXPECT_TRUE(message.MergePartialFromCodedStream(&is));
+    // Parsing from the string should fail.
+    EXPECT_FALSE(message.ParseFromString(data));
+  }
+}
+
+TEST_F(WireFormatInvalidInputTest, InvalidGroup) {
+  UNITTEST::TestAllTypes message;
+
+  // Control case.
+  EXPECT_TRUE(message.ParseFromString(MakeInvalidGroup("", 0, true)));
+
+  // Missing end tag.  Groups cannot end at EOF.
+  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("", 0, false)));
+
+  // The byte is a valid varint, but not a valid tag (zero).
+  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("\0", 1, false)));
+
+  // The byte is a malformed varint.
+  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("\200", 1, false)));
+
+  // The byte is an endgroup tag, but not the right one for this group.
+  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("\014", 1, false)));
+
+  // The byte is a valid varint but not a valid tag (bad wire type).
+  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("\017", 1, true)));
+}
+
+TEST_F(WireFormatInvalidInputTest, InvalidUnknownGroup) {
+  // Use TestEmptyMessage so that the group made by MakeInvalidGroup will not
+  // be a known tag number.
+  UNITTEST::TestEmptyMessage message;
+
+  // Control case.
+  EXPECT_TRUE(message.ParseFromString(MakeInvalidGroup("", 0, true)));
+
+  // Missing end tag.  Groups cannot end at EOF.
+  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("", 0, false)));
+
+  // The byte is a valid varint, but not a valid tag (zero).
+  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("\0", 1, false)));
+
+  // The byte is a malformed varint.
+  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("\200", 1, false)));
+
+  // The byte is an endgroup tag, but not the right one for this group.
+  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("\014", 1, false)));
+
+  // The byte is a valid varint but not a valid tag (bad wire type).
+  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("\017", 1, true)));
+}
+
+TEST_F(WireFormatInvalidInputTest, InvalidStringInUnknownGroup) {
+  // Test a bug fix:  SkipMessage should fail if the message contains a
+  // string whose length would extend beyond the message end.
+
+  UNITTEST::TestAllTypes message;
+  message.set_optional_string("foo foo foo foo");
+  std::string data;
+  message.SerializeToString(&data);
+
+  // Chop some bytes off the end.
+  data.resize(data.size() - 4);
+
+  // Try to skip it.  Note that the bug was only present when parsing to an
+  // UnknownFieldSet.
+  io::ArrayInputStream raw_input(data.data(), data.size());
+  io::CodedInputStream coded_input(&raw_input);
+  UnknownFieldSet unknown_fields;
+  EXPECT_FALSE(WireFormat::SkipMessage(&coded_input, &unknown_fields));
+}
+
+// Test differences between string and bytes.
+// Value of a string type must be valid UTF-8 string.  When UTF-8
+// validation is enabled (GOOGLE_PROTOBUF_UTF8_VALIDATION_ENABLED):
+// WriteInvalidUTF8String:  see error message.
+// ReadInvalidUTF8String:  see error message.
+// WriteValidUTF8String: fine.
+// ReadValidUTF8String:  fine.
+// WriteAnyBytes: fine.
+// ReadAnyBytes: fine.
+const char* kInvalidUTF8String = "Invalid UTF-8: \xA0\xB0\xC0\xD0";
+// This used to be "Valid UTF-8: \x01\x02\u8C37\u6B4C", but MSVC seems to
+// interpret \u differently from GCC.
+const char* kValidUTF8String = "Valid UTF-8: \x01\x02\350\260\267\346\255\214";
+
+template <typename T>
+bool WriteMessage(const char* value, T* message, std::string* wire_buffer) {
+  message->set_data(value);
+  wire_buffer->clear();
+  message->AppendToString(wire_buffer);
+  return (wire_buffer->size() > 0);
+}
+
+template <typename T>
+bool ReadMessage(const std::string& wire_buffer, T* message) {
+  return message->ParseFromArray(wire_buffer.data(), wire_buffer.size());
+}
+
+class Utf8ValidationTest : public ::testing::Test {
+ protected:
+  Utf8ValidationTest() {}
+  ~Utf8ValidationTest() override {}
+  void SetUp() override {
+  }
+
+};
+
+TEST_F(Utf8ValidationTest, WriteInvalidUTF8String) {
+  std::string wire_buffer;
+  UNITTEST::OneString input;
+  std::vector<std::string> errors;
+  {
+    ScopedMemoryLog log;
+    WriteMessage(kInvalidUTF8String, &input, &wire_buffer);
+    errors = log.GetMessages(ERROR);
+  }
+#ifdef GOOGLE_PROTOBUF_UTF8_VALIDATION_ENABLED
+  EXPECT_THAT(errors,
+              testing::ElementsAre(
+                  "String field '" + std::string(UNITTEST_PACKAGE_NAME) +
+                  ".OneString.data' "
+                  "contains invalid UTF-8 data when "
+                  "serializing a protocol buffer. Use the "
+                  "'bytes' type if you intend to send raw bytes. "));
+#else
+  ASSERT_EQ(0, errors.size());
+#endif  // GOOGLE_PROTOBUF_UTF8_VALIDATION_ENABLED
+}
+
+
+TEST_F(Utf8ValidationTest, ReadInvalidUTF8String) {
+  std::string wire_buffer;
+  UNITTEST::OneString input;
+  WriteMessage(kInvalidUTF8String, &input, &wire_buffer);
+  UNITTEST::OneString output;
+  std::vector<std::string> errors;
+  {
+    ScopedMemoryLog log;
+    ReadMessage(wire_buffer, &output);
+    errors = log.GetMessages(ERROR);
+  }
+#ifdef GOOGLE_PROTOBUF_UTF8_VALIDATION_ENABLED
+  EXPECT_THAT(errors,
+              testing::ElementsAre(
+                  "String field '" + std::string(UNITTEST_PACKAGE_NAME) +
+                  ".OneString.data' "
+                  "contains invalid UTF-8 data when "
+                  "parsing a protocol buffer. Use the "
+                  "'bytes' type if you intend to send raw bytes. "));
+
+#else
+  ASSERT_EQ(0, errors.size());
+#endif  // GOOGLE_PROTOBUF_UTF8_VALIDATION_ENABLED
+}
+
+
+TEST_F(Utf8ValidationTest, WriteValidUTF8String) {
+  std::string wire_buffer;
+  UNITTEST::OneString input;
+  std::vector<std::string> errors;
+  {
+    ScopedMemoryLog log;
+    WriteMessage(kValidUTF8String, &input, &wire_buffer);
+    errors = log.GetMessages(ERROR);
+  }
+  ASSERT_EQ(0, errors.size());
+}
+
+TEST_F(Utf8ValidationTest, ReadValidUTF8String) {
+  std::string wire_buffer;
+  UNITTEST::OneString input;
+  WriteMessage(kValidUTF8String, &input, &wire_buffer);
+  UNITTEST::OneString output;
+  std::vector<std::string> errors;
+  {
+    ScopedMemoryLog log;
+    ReadMessage(wire_buffer, &output);
+    errors = log.GetMessages(ERROR);
+  }
+  ASSERT_EQ(0, errors.size());
+  EXPECT_EQ(input.data(), output.data());
+}
+
+// Bytes: anything can pass as bytes, use invalid UTF-8 string to test
+TEST_F(Utf8ValidationTest, WriteArbitraryBytes) {
+  std::string wire_buffer;
+  UNITTEST::OneBytes input;
+  std::vector<std::string> errors;
+  {
+    ScopedMemoryLog log;
+    WriteMessage(kInvalidUTF8String, &input, &wire_buffer);
+    errors = log.GetMessages(ERROR);
+  }
+  ASSERT_EQ(0, errors.size());
+}
+
+TEST_F(Utf8ValidationTest, ReadArbitraryBytes) {
+  std::string wire_buffer;
+  UNITTEST::OneBytes input;
+  WriteMessage(kInvalidUTF8String, &input, &wire_buffer);
+  UNITTEST::OneBytes output;
+  std::vector<std::string> errors;
+  {
+    ScopedMemoryLog log;
+    ReadMessage(wire_buffer, &output);
+    errors = log.GetMessages(ERROR);
+  }
+  ASSERT_EQ(0, errors.size());
+  EXPECT_EQ(input.data(), output.data());
+}
+
+TEST_F(Utf8ValidationTest, ParseRepeatedString) {
+  UNITTEST::MoreBytes input;
+  input.add_data(kValidUTF8String);
+  input.add_data(kInvalidUTF8String);
+  input.add_data(kInvalidUTF8String);
+  std::string wire_buffer = input.SerializeAsString();
+
+  UNITTEST::MoreString output;
+  std::vector<std::string> errors;
+  {
+    ScopedMemoryLog log;
+    ReadMessage(wire_buffer, &output);
+    errors = log.GetMessages(ERROR);
+  }
+#ifdef GOOGLE_PROTOBUF_UTF8_VALIDATION_ENABLED
+  ASSERT_EQ(2, errors.size());
+#else
+  ASSERT_EQ(0, errors.size());
+#endif  // GOOGLE_PROTOBUF_UTF8_VALIDATION_ENABLED
+  EXPECT_EQ(wire_buffer, output.SerializeAsString());
+}
+
+// Test the old VerifyUTF8String() function, which may still be called by old
+// generated code.
+TEST_F(Utf8ValidationTest, OldVerifyUTF8String) {
+  std::string data(kInvalidUTF8String);
+
+  std::vector<std::string> errors;
+  {
+    ScopedMemoryLog log;
+    WireFormat::VerifyUTF8String(data.data(), data.size(),
+                                 WireFormat::SERIALIZE);
+    errors = log.GetMessages(ERROR);
+  }
+#ifdef GOOGLE_PROTOBUF_UTF8_VALIDATION_ENABLED
+  ASSERT_EQ(1, errors.size());
+  EXPECT_TRUE(
+      HasPrefixString(errors[0],
+                       "String field contains invalid UTF-8 data when "
+                       "serializing a protocol buffer. Use the "
+                       "'bytes' type if you intend to send raw bytes."));
+#else
+  ASSERT_EQ(0, errors.size());
+#endif
+}
+
+
+TEST(RepeatedVarint, Int32) {
+  RepeatedField<int32_t> v;
+
+  // Insert -2^n, 2^n and 2^n-1.
+  for (int n = 0; n < 10; n++) {
+    v.Add(-(1 << n));
+    v.Add(1 << n);
+    v.Add((1 << n) - 1);
+  }
+
+  // Check consistency with the scalar Int32Size.
+  size_t expected = 0;
+  for (int i = 0; i < v.size(); i++) {
+    expected += WireFormatLite::Int32Size(v[i]);
+  }
+
+  EXPECT_EQ(expected, WireFormatLite::Int32Size(v));
+}
+
+TEST(RepeatedVarint, Int64) {
+  RepeatedField<int64_t> v;
+
+  // Insert -2^n, 2^n and 2^n-1.
+  for (int n = 0; n < 10; n++) {
+    v.Add(-(1 << n));
+    v.Add(1 << n);
+    v.Add((1 << n) - 1);
+  }
+
+  // Check consistency with the scalar Int64Size.
+  size_t expected = 0;
+  for (int i = 0; i < v.size(); i++) {
+    expected += WireFormatLite::Int64Size(v[i]);
+  }
+
+  EXPECT_EQ(expected, WireFormatLite::Int64Size(v));
+}
+
+TEST(RepeatedVarint, SInt32) {
+  RepeatedField<int32_t> v;
+
+  // Insert -2^n, 2^n and 2^n-1.
+  for (int n = 0; n < 10; n++) {
+    v.Add(-(1 << n));
+    v.Add(1 << n);
+    v.Add((1 << n) - 1);
+  }
+
+  // Check consistency with the scalar SInt32Size.
+  size_t expected = 0;
+  for (int i = 0; i < v.size(); i++) {
+    expected += WireFormatLite::SInt32Size(v[i]);
+  }
+
+  EXPECT_EQ(expected, WireFormatLite::SInt32Size(v));
+}
+
+TEST(RepeatedVarint, SInt64) {
+  RepeatedField<int64_t> v;
+
+  // Insert -2^n, 2^n and 2^n-1.
+  for (int n = 0; n < 10; n++) {
+    v.Add(-(1 << n));
+    v.Add(1 << n);
+    v.Add((1 << n) - 1);
+  }
+
+  // Check consistency with the scalar SInt64Size.
+  size_t expected = 0;
+  for (int i = 0; i < v.size(); i++) {
+    expected += WireFormatLite::SInt64Size(v[i]);
+  }
+
+  EXPECT_EQ(expected, WireFormatLite::SInt64Size(v));
+}
+
+TEST(RepeatedVarint, UInt32) {
+  RepeatedField<uint32_t> v;
+
+  // Insert 2^n and 2^n-1.
+  for (int n = 0; n < 10; n++) {
+    v.Add(1 << n);
+    v.Add((1 << n) - 1);
+  }
+
+  // Check consistency with the scalar UInt32Size.
+  size_t expected = 0;
+  for (int i = 0; i < v.size(); i++) {
+    expected += WireFormatLite::UInt32Size(v[i]);
+  }
+
+  EXPECT_EQ(expected, WireFormatLite::UInt32Size(v));
+}
+
+TEST(RepeatedVarint, UInt64) {
+  RepeatedField<uint64_t> v;
+
+  // Insert 2^n and 2^n-1.
+  for (int n = 0; n < 10; n++) {
+    v.Add(1 << n);
+    v.Add((1 << n) - 1);
+  }
+
+  // Check consistency with the scalar UInt64Size.
+  size_t expected = 0;
+  for (int i = 0; i < v.size(); i++) {
+    expected += WireFormatLite::UInt64Size(v[i]);
+  }
+
+  EXPECT_EQ(expected, WireFormatLite::UInt64Size(v));
+}
+
+TEST(RepeatedVarint, Enum) {
+  RepeatedField<int> v;
+
+  // Insert 2^n and 2^n-1.
+  for (int n = 0; n < 10; n++) {
+    v.Add(1 << n);
+    v.Add((1 << n) - 1);
+  }
+
+  // Check consistency with the scalar EnumSize.
+  size_t expected = 0;
+  for (int i = 0; i < v.size(); i++) {
+    expected += WireFormatLite::EnumSize(v[i]);
+  }
+
+  EXPECT_EQ(expected, WireFormatLite::EnumSize(v));
+}
+
+
+}  // namespace
+}  // namespace internal
+}  // namespace protobuf
+}  // namespace google
+
+#include <google/protobuf/port_undef.inc>
